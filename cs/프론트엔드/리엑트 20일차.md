# Immutable / 복사 개념 한 번에 정리 가이드

## 1. 값(Primitive) vs 참조(Reference)

### Primitive (값 타입)

-   number
-   string
-   boolean
-   null / undefined
-   bigint / symbol

특징: **값 자체가 저장됨 (주소 개념 없음)**

``` js
let a = "kim";
let b = a;
b = "lee";
console.log(a); // kim
```

→ 값이 복사됨. 서로 영향 없음.

------------------------------------------------------------------------

### Reference (객체 타입)

-   object
-   array
-   function

특징: **주소(참조)를 저장**

``` js
let a = { age: 20 };
let b = a;
b.age = 30;
console.log(a.age); // 30
```

→ 같은 객체를 가리킴 (공유됨)

------------------------------------------------------------------------

## 2. a = b 의 의미

  타입        의미
  ----------- --------------------
  값 타입     값 복사
  객체 타입   주소 공유
  Immutable   주소 공유지만 안전

Immutable은 수정이 불가능하므로 공유해도 문제 없음.

------------------------------------------------------------------------

## 3. 얕은 복사 (Shallow Copy)

``` js
const state = {
  num: 1,
  user: { age: 20 }
};

const next = { ...state };
```

결과:

  항목   결과
  ------ --------
  num    복사됨
  user   공유됨

``` js
next.user.age = 30;
console.log(state.user.age); // 30
```

정의: \> 1단계만 복사하고 내부 객체는 공유

------------------------------------------------------------------------

## 4. 깊은 복사 (Deep Copy)

``` js
const next = JSON.parse(JSON.stringify(state));
next.user.age = 30;
console.log(state.user.age); // 20
```

전체 객체를 새로 생성한다. 비용이 큼 O(N).

------------------------------------------------------------------------

## 5. Immutable 개념

Immutable의 핵심: \> 수정(Mutation)이 아니라 새 상태 생성(Replacement)

``` js
const state = fromJS({ user: { age: 20 } });
const next = state.setIn(["user","age"],30);
```

결과:

    state.user.age = 20
    next.user.age = 30

원본 보존.

------------------------------------------------------------------------

## 6. 구조적 공유 (Structural Sharing)

Immutable은 전체 복사를 하지 않는다.

    state
     └─ user(age:20)
     └─ items(10000개)

    next
     └─ user(age:30)  ← 새로 생성
     └─ items        ← 그대로 재사용

특징: - 바뀐 경로만 새로 생성 - 나머지는 재사용 - 성능 좋음 O(log N)

------------------------------------------------------------------------

## 7. Map vs fromJS

### Map()

``` js
const state = Map({
  user: { age: 20 }
});
```

내부:

    user → 일반 JS 객체

→ 수정 가능 (위험)

------------------------------------------------------------------------

### fromJS()

``` js
const state = fromJS({
  user: { age: 20 }
});
```

내부:

    user → Map

→ 완전 불변

정리:

  함수     특징
  -------- ----------------
  Map      겉만 Immutable
  fromJS   전체 Immutable

------------------------------------------------------------------------

## 8. set vs setIn

### set

객체 교체

``` js
state.set("user", newUser)
```

### setIn

내부 값 변경(경로 갱신)

``` js
state.setIn(["user","age"],30)
```

  함수    의미
  ------- ---------------
  set     객체 교체
  setIn   부분 업데이트

------------------------------------------------------------------------

## 9. 복사 개념 비교

  방식        특징
  ----------- ----------------
  얕은복사    내부 공유
  깊은복사    전체 새 생성
  Immutable   경로만 새 생성

핵심: \> Immutable은 깊은복사가 아니라 깊은복사가 필요 없는 구조

------------------------------------------------------------------------

## 10. fromJS / toJS / JSON.stringify

### fromJS

JS → Immutable

### toJS

Immutable → JS (깊은복사)

``` js
const plain = state.toJS();
```

### JSON.stringify

JS → 문자열 (네트워크 전송용)

``` js
JSON.stringify(plain);
```

전체 흐름:

    JS → fromJS → Immutable → toJS → JS → stringify → JSON 문자열

------------------------------------------------------------------------

## 11. toJS 주의사항

``` js
return state.toJS();
```

문제: - 매 렌더 새 객체 생성 - React 리렌더 폭발

사용 위치: - API 요청 - 콘솔 출력 - 외부 라이브러리

사용 금지: - reducer return - render 내부

------------------------------------------------------------------------

## 12. 최종 핵심 요약

-   얕은복사: 값은 복사, 객체는 공유
-   깊은복사: 전체 새 객체
-   Immutable: 수정 금지 + 새 상태 생성
-   fromJS: 불변 구조 생성
-   toJS: 일반 객체로 변환
-   set/setIn: 복사본 생성 함수 역할

### 가장 중요한 한 문장

> Immutable은 깊은복사가 아니라 "상태를 고치지 못하게 해서 복사가 필요
> 없게 만든 자료구조"이다.
