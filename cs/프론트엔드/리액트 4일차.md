# JavaScript 비동기 제어 흐름 완전 정리  
## Promise / Microtask / Macrotask / Call Stack / Event Loop / React Batching

---

# 1. Call Stack 이해

## 1-1. Call Stack이란
JavaScript는 단일 스레드 언어이며 한 순간에 하나의 코드만 실행할 수 있다.  
이때 현재 어떤 함수가 실행 중인지, 호출 관계가 무엇인지 추적하기 위해 Call Stack을 사용한다.

특징
- 후입선출(LIFO)
- 함수 호출 시 push
- 함수 종료 시 pop
- Stack의 top이 현재 실행 중인 함수

## 1-2. 예제

```js
function a() {
  console.log("a 시작");
  b();
  console.log("a 끝");
}

function b() {
  console.log("b 실행");
}

a();
```

Call Stack 흐름  
1. a push  
2. console.log push → pop  
3. b push  
4. console.log push → pop  
5. b pop  
6. console.log push → pop  
7. a pop  

출력

```
a 시작
b 실행
a 끝
```

## 1-3. Stack Overflow

```js
function recur() {
  recur();
}
recur();
```

무한 호출로 Stack Overflow 발생  
`Maximum call stack size exceeded`

---

# 2. Event Loop 구조

Event Loop 규칙  
1. Call Stack이 비면  
2. Microtask Queue를 모두 처리  
3. Microtask가 끝나면 Macrotask Queue에서 작업 1개 실행  
4. 다시 반복

Microtask가 Macrotask보다 우선순위가 높다.

---

# 3. Microtask vs Macrotask

| 구분 | Microtask | Macrotask |
|------|-----------|-----------|
| 우선순위 | 가장 높음 | 낮음 |
| 실행 시점 | Call Stack이 비는 즉시 | Microtask가 끝난 후 |
| 대표 예시 | Promise.then, catch, finally / await 이후 / queueMicrotask | setTimeout, setInterval / requestAnimationFrame / I/O |
| 처리량 | 해당 tick에서 Queue가 빌 때까지 모두 처리 | tick당 1개 처리 |
| 특징 | 거의 동기처럼 빠르게 실행 | 명확한 지연 발생 |

## 예제

```js
console.log(1);

setTimeout(() => console.log(2), 0);  // Macrotask
Promise.resolve().then(() => console.log(3)); // Microtask

console.log(4);
```

출력

```
1
4
3
2
```

---

# 4. Promise

## 4-1. Promise 상태
- pending  
- fulfilled (resolve)  
- rejected (reject)

한 번 상태가 바뀌면 고정됨.

## 4-2. then/catch는 Microtask

```js
Promise.resolve()
  .then(() => console.log("micro"));
console.log("sync");
```

출력

```
sync
micro
```

## 4-3. Chaining

```js
Promise.resolve(1)
  .then(v => v + 1)
  .then(v => v + 1)
  .then(console.log); // 3
```

---

# 5. async/await 동작 원리

await 이후 코드는 Promise.then과 동일하게 Microtask Queue로 들어간다.

```js
console.log(1);

async function test() {
  console.log(2);
  await null;
  console.log(3);
}

test();
console.log(4);
```

출력

```
1
2
4
3
```

---

# 6. Microtask + Macrotask 섞인 예제

```js
setTimeout(() => console.log("A"), 0);

Promise.resolve()
  .then(() => {
    console.log("B");
    setTimeout(() => console.log("C"), 0);
  })
  .then(() => console.log("D"));
```

출력

```
B
D
A
C
```

설명  
1. Microtask: B  
2. Microtask: D  
3. Macrotask: A  
4. 다음 tick의 Macrotask: C  

---

# 7. 비동기 함수와 Call Stack 관계

비동기 함수는 기다리는 동안 Stack을 차지하지 않는다.  
실행 시점이 되면 Queue에서 Call Stack으로 올라오며 실행된다.

---

# 8. React setState와 Event Loop / Batching

React 18 이후 setState는 거의 모든 환경에서 자동 batching이 적용된다.

```js
setCount(c + 1);
setCount(c + 1);
setCount(c + 1);
```

렌더링은 여러 번 일어나지 않고 단 1번만 일어난다.

React는 다음 상황 모두 batching 처리함  
- 이벤트 핸들러  
- Promise.then  
- async/await  
- setTimeout  

즉 하나의 tick 안에서 발생한 모든 상태 변경을 모아 한 번만 렌더링한다.

---

# 9. 전체 요약

1. Call Stack은 실행 중인 함수들의 기록 공간이다.  
2. Event Loop는 Stack이 비는 순간 Microtask → Macrotask 순서로 진행한다.  
3. Promise.then, await 이후는 Microtask이다.  
4. setTimeout 등은 Macrotask이다.  
5. Microtask가 항상 우선 실행된다.  
6. React는 tick 단위로 상태 변경을 batch하여 렌더링 횟수를 최소화한다.

---