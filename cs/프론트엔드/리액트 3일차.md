# React useState, 구조분해, State 동작, Batching, Fiber, Promise 총정리 (이모티콘 없음)

## 1. 구조분해 할당(Destructuring Assignment)

### 1.1 배열 구조분해
JavaScript에서 배열 구조분해는 배열의 값을 순서대로 꺼내 변수에 할당하는 문법이다.

예:
```js
const arr = [10, 20, 30];
const [a, b] = arr;
// a = 10, b = 20
```

값을 건너뛰기:
```js
const [a, , c] = [1, 2, 3];
```

기본값 설정:
```js
const [a = 0, b = 5] = [10];
// a=10, b=5
```

---

### 1.2 객체 구조분해
객체 구조분해는 key 이름으로 값을 꺼내는 방식이다.

```js
const user = { name: "홍길동", age: 20 };
const { name, age } = user;
```

변수명 변경:
```js
const { name: userName } = user;
```

기본값:
```js
const { nick = "없음" } = user;
```

---

## 2. useState와 구조분해

### 2.1 useState는 배열을 반환한다
React의 useState는 다음과 같은 배열을 반환한다.

```js
const result = useState(초기값);
// result = [state값, setter함수]
```

따라서 우리는 배열 구조분해 문법을 사용해야 한다.

예:
```js
const [count, setCount] = useState(0);
```

- count: 현재 state 값
- setCount: 상태를 변경하는 setter 함수

---

### 2.2 setter를 쓰지 않는 구조도 가능하지만 비추천
```js
const [count] = useState(0);  // setter 없음 → 상태 변경 불가
```
실용성이 거의 없다.

또는 setter만 필요한 경우:
```js
const [, setForceRender] = useState(0);
```

---

### 2.3 왜 useState는 객체가 아니라 배열을 반환하는가?
배열 구조분해는 "순서 기반"이라 이름 충돌 없이 원하는 이름을 자유롭게 줄 수 있기 때문이다.

```js
const [age, setAge] = useState(0);
const [isOpen, setIsOpen] = useState(false);
```

객체였다면 변수명이 고정된다.
```js
const { state, setState } = useState(0); // 이름 고정됨 → 불편
```

---

## 3. State 변경이 즉시 반영되지 않는 이유

### 3.1 setState는 즉시 반영되지 않는다
```js
setCount(count + 1);
console.log(count); // 이전 값이 출력됨
```

이유:
- React는 setState를 호출해도 즉시 렌더하지 않는다.
- "업데이트 요청"만 기록하고 렌더는 나중에 실행한다.
- 그래서 마치 비동기처럼 보인다.

---

### 3.2 Batching(일괄 처리) 때문
여러 setState 호출이 있어도 렌더링은 보통 한 번 발생한다.

```js
setCount(prev => prev + 1);
setCount(prev => prev + 1);
setCount(prev => prev + 1);
```

최종 count는 3이지만 렌더는 1번만 일어난다.

---

## 4. 왜 `setCount(count + 1)` 은 꼬이고 `setCount(prev => prev + 1)` 은 안전한가?

### 4.1 count는 "렌더 시점의 snapshot"
React 컴포넌트는 렌더될 때 count의 값이 고정된다.

예:
```js
setCount(count + 1);
setCount(count + 1);
```

count가 0이라면 둘 다 `setCount(1)`만 호출한다.

---

### 4.2 prev 방식은 React가 최신값을 넣어준다
```js
setCount(prev => prev + 1);
```

React 내부 업데이트 큐:
```
prev=0 → 1  
prev=1 → 2  
prev=2 → 3  
```

연속 업데이트에서도 항상 정확하다.

---

## 5. React는 언제 batch를 끊는가?

### batch 유지되는 경우
React 18부터 아래는 모두 자동 batch 된다.

- 이벤트 핸들러
- Promise.then
- async/await
- setTimeout
- fetch().then

### batch가 끊기는 경우
- flushSync 사용
- React가 commit을 완료한 후 새로운 cycle 시작할 때

---

## 6. flushSync 동작 방식

```js
flushSync(() => {
  setCount(prev => prev + 1); // 즉시 렌더
});

setCount(prev => prev + 1); // 다음 batch
```

즉:
- flushSync 블록 내부: 즉시 렌더 및 commit
- 블록 외부: 새로운 batch로 처리

DOM의 즉시 반영이 필요한 상황에서만 사용해야 한다.

---

## 7. Fiber는 batch를 어떻게 관리하는가?

### Fiber 구조
각 컴포넌트는 Fiber 노드로 관리되며 다음을 포함한다.

- state
- props
- hook 리스트
- update queue
- lane(업데이트 우선순위)

### setState 시 동작
1. 해당 Fiber의 update queue에 업데이트 저장
2. root까지 propagate하여 rerender 필요 표시
3. lane을 기반으로 우선순위 결정
4. render phase에서 update queue를 순서대로 적용하여 최종 state 계산
5. commit phase에서 DOM에 반영

---

## 8. Promise란?

### Promise 상태
- pending
- fulfilled
- rejected

Promise는 생성 즉시 실행된다.

---

## 9. Promise 실행 순서

JavaScript의 이벤트 루프 순서:

1. Call Stack
2. Microtask Queue (Promise then)
3. Macrotask Queue (setTimeout 등)

예:
```
console.log(1)
Promise.resolve().then(()=>console.log(2))
console.log(3)

출력:
1
3
2
```

---

## 10. 콜백 함수 vs Promise 콜백

### 콜백 함수의 정의
"다른 함수에 전달되어 나중에 호출되는 함수"

### Promise 콜백의 특징
- Microtask Queue에서 실행
- 상태 기반(pending → fulfilled/rejected)으로 동작
- then/catch를 이용해 에러 흐름 개선
- 콜백 지옥을 해결할 수 있음

### 차이점 요약

| 구분 | 일반 콜백 | Promise 콜백 |
|------|-----------|--------------|
| 실행 시점 | 즉시 또는 비동기 API 실행 시 | Promise 상태 변화 후 Microtask에서 실행 |
| 에러 처리 | try/catch | catch 체이닝 |
| 지옥 발생 | 높음 | 낮음 |
| 상태 기반 | 없음 | 있음 |

---

# 전체 요약

1. useState는 `[state, setter]` 형태의 배열을 반환하며 구조분해는 배열 구조분해 문법이다.
2. setState는 batching 때문에 즉시 반영되지 않아 비동기처럼 보인다.
3. `count + 1` 은 이전 렌더 snapshot을 사용해 꼬이고, `prev => prev + 1` 은 React가 최신값을 넣어주므로 안전하다.
4. React는 동일 이벤트 루프 틱 내 setState를 모두 batch로 묶어 렌더를 1번만 수행한다.
5. flushSync는 batch를 강제로 끊어 즉시 렌더를 실행한다.
6. Fiber는 각 컴포넌트를 update queue와 lane 기반으로 스케줄링하여 상태를 렌더 단계에서 일괄 적용한다.
7. Promise는 Microtask Queue에서 실행되며 비동기 흐름 제어를 위한 상태 기반 객체이다.
8. Promise 콜백은 콜백 함수의 일종이지만 실행 방식과 흐름 제어 방식이 특별하다.

