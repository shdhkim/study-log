# React Hooks & React.memo 완전 정리 (실무 기준)

이 문서는 **React Hooks(useState, useRef, useMemo, useCallback, memo, forwardRef)** 와  
**React.memo 렌더링 조건 / 객체 참조 문제**를 정리함  


---

## 1. useState

### 정의
- 화면에 영향을 주는 상태 저장
- 값이 바뀌면 컴포넌트 **재렌더링**

```jsx
const [count, setCount] = useState(0);
setCount(count + 1);
```

### 중요한 차이
```jsx
setCount(count + 1);          // 현재 렌더 기준
setCount(prev => prev + 1);  // 항상 최신 값 기준 (권장)
```

---

## 2. useRef

### 정의
- 값은 저장하지만 **렌더링을 발생시키지 않음**
- DOM 직접 접근 가능

### DOM 접근 예제
```jsx
const inputRef = useRef(null);
<input ref={inputRef} />
inputRef.current.focus();
```

### 값 저장용 (렌더링 X)
```jsx
const renderCount = useRef(0);
renderCount.current++;
```

### useState vs useRef
| 구분 | useState | useRef |
|---|---|---|
| 렌더링 | O | X |
| DOM 접근 | X | O |

---

## 3. useMemo

### 정의
- **값 계산 결과를 캐싱**
- 참조를 고정

### AgGrid 실무 예제
```jsx
const columnDefs = useMemo(() => [
  { field: "id" },
  { field: "name" },
], []);
```

### 안 쓰면 문제
- 렌더링마다 새 배열 생성
- 자식 컴포넌트 전체 리렌더

---

## 4. React.memo

### 정의
- props가 바뀌지 않으면 **렌더링 스킵**
- 얕은 비교(shallow compare)

```jsx
const Child = React.memo(({ value }) => {
  return <div>{value}</div>;
});
```

---

## 5. memo 렌더링 조건 핵심

### 기준 공식
```text
부모가 렌더링됨
↓
자식에게 전달된 props 중
↓
참조 또는 값이 하나라도 바뀌면
↓
자식 렌더링됨
```

---

## 6. 부모 state 변경 vs 자식 렌더링

### 부모만 변경 → 자식 props 동일
```jsx
<Child name="Kim" />
```
→ 자식 렌더링 ❌

### 자식 props 값 변경
```jsx
<Child name={count} />
```
→ 자식 렌더링 ⭕

---

## 7. 가장 흔한 실수: 함수 props

```jsx
<Child onClick={() => console.log("hi")} />
```

- 렌더링마다 새 함수
- memo 무효

### 해결
```jsx
const handleClick = useCallback(() => {
  console.log("hi");
}, []);
```

---

## 8. 객체 props 문제 (중요)

### ❌ 잘못된 패턴 (불변성 위반)
```jsx
user.name = "Lee";
setUser(user); // 같은 참조
```
→ 렌더링 ❌ (버그)

### ✅ 올바른 패턴
```jsx
setUser(prev => ({
  ...prev,
  name: "Lee",
}));
```
→ 렌더링 ⭕

---

## 9. 객체 내부 값 변경 요약

| 상황 | 참조 변경 | 내부 값 | 렌더링 |
|---|---|---|---|
| 직접 수정 | X | O | ❌ |
| 새 객체 생성 | O | O | ⭕ |

---

## 10. useCallback

### 정의
- 함수 참조 고정

```jsx
const onClick = useCallback(() => {
  console.log("click");
}, []);
```

### memo와 함께 사용
```jsx
const Button = memo(({ onClick }) => (
  <button onClick={onClick}>버튼</button>
));
```

---

## 11. forwardRef

### 정의
- 부모에서 자식 DOM 접근

### 예제
```jsx
const Input = forwardRef((props, ref) => {
  return <input ref={ref} />;
});

const ref = useRef();
<Input ref={ref} />
ref.current.focus();
```

---

## 12. 실무 최종 정리

### 언제 무엇을 쓰나

| 목적 | Hook |
|---|---|
| 상태 관리 | useState |
| DOM 접근 | useRef |
| 값 캐싱 | useMemo |
| 함수 캐싱 | useCallback |
| 렌더링 방지 | memo |
| ref 전달 | forwardRef |

---

## 13. AgGrid 기준 실무 패턴

```jsx
columnDefs     → useMemo
defaultColDef  → useMemo
event handler  → useCallback
gridApi        → useRef
rowData        → useState
cellRenderer   → memo
```

---

## 핵심 문장 

> React.memo는 props의 얕은 비교를 수행하며  
> 객체 내부 값이 아닌 **참조 변경 여부**로 렌더링을 결정한다.  
> 따라서 React 상태는 반드시 불변성으로 관리해야 한다.
