# 배열 안에 객체(Array of Objects) 복사와 비교 상세 가이드

## 1. 기본 상황

    const users = [
      { name: "kim", age: 20 },
      { name: "lee", age: 30 }
    ];

중요: 배열에는 객체가 들어있는 것이 아니라 객체의 **참조(주소)** 가
들어있다.

메모리 개념:

users → \[ 주소A , 주소B \]\
주소A → { name:"kim", age:20 }\
주소B → { name:"lee", age:30 }

------------------------------------------------------------------------

## 2. 참조복사

    const copy = users;

결과:

    copy[0].age = 99;
    console.log(users[0].age); // 99

이유: copy와 users가 같은 배열을 가리킨다.

users === copy → true

------------------------------------------------------------------------

## 3. 배열 얕은복사

    const copy = [...users];

비교:

    users === copy        → false
    users[0] === copy[0]  → true

의미: - 배열 컨테이너만 새로 생성 - 내부 객체는 공유

그래서:

    copy[0].age = 99;
    console.log(users[0].age); // 99

배열은 새로지만 객체는 같은 것.

------------------------------------------------------------------------

## 4. 왜 숫자 배열은 안전한가

    const nums = [1,2,3];
    const copy = [...nums];

    copy[0] = 9;
    console.log(nums[0]); // 1

숫자는 참조가 아니라 값이기 때문이다.

------------------------------------------------------------------------

## 5. 올바른 객체 배열 복사

### map + 객체 복사

    const copy = users.map(user => ({ ...user }));

이제:

    copy[0].age = 99;
    console.log(users[0].age); // 20

배열도 새로 객체도 새로

------------------------------------------------------------------------

## 6. 깊은복사

    const copy = JSON.parse(JSON.stringify(users));

특징: - 완전 분리 - 느림 - Date, 함수 손상

------------------------------------------------------------------------

## 7. React에서 발생하는 버그

잘못된 코드:

    const newUsers = [...users];
    newUsers[0].age = 99;
    setUsers(newUsers);

문제: 자식 컴포넌트는 users\[0\]의 주소가 같아서 변경 감지 실패 가능.

------------------------------------------------------------------------

## 8. 올바른 React 상태 변경

    const newUsers = users.map((u,i)=>
      i === 0 ? { ...u, age: 99 } : u
    );

    setUsers(newUsers);

이제 이전 객체와 새 객체의 주소가 다르므로 렌더링 정상 동작.

------------------------------------------------------------------------

## 9. Immutable 방식

    const list = fromJS(users);
    const next = list.setIn([0,"age"],99);

확인:

    list.getIn([0,"age"]) // 20
    next.getIn([0,"age"]) // 99

원본 유지 + 새 상태 생성

------------------------------------------------------------------------

## 10. 구조적 공유

변경 후 내부:

이전: ListA ├ MapA {kim,20} └ MapB {lee,30}

다음: ListB ├ MapC {kim,99} ← 새로 생성 └ MapB {lee,30} ← 재사용

바뀐 경로만 새로 생성한다.

------------------------------------------------------------------------

## 11. 비교 정리

  방식        배열      내부 객체
  ----------- --------- ------------------
  참조복사    공유      공유
  얕은복사    새로      공유
  map 복사    새로      새로
  깊은복사    새로      새로
  Immutable   새 버전   변경 경로만 새로

------------------------------------------------------------------------

## 12. 핵심 요약

-   배열은 객체의 참조를 저장한다.
-   spread(\[...\])는 배열만 복사한다.
-   객체까지 분리하려면 map으로 객체도 복사해야 한다.
-   Immutable은 변경 경로만 새 객체를 만든다.
