# React Hooks / Custom Hooks / Context Deep Dive 
(슬롯, Fiber, 인덱스 매칭, 상태 변경 흐름, 실무 패턴까지)

이 문서는 다음을 예제 중심으로 정리한다.

- Hook이 “그냥 상태를 가져오는 함수”가 아닌 이유 (Fiber + Scheduler)
- Hook 인덱스 매칭(호출 순서) 원리와 규칙 위반 시 깨지는 방식
- Custom Hook이 “상태 공유”가 아니라 “구조 재사용”인 이유
- Context가 “진짜 공유”를 제공하는 방식과 Custom Hook과의 결합 패턴
- 실무에서 자주 쓰는 Custom Hook 패턴(상태+액션, effect 전용, ref 기반, context 래핑)

---

## 0. 용어 정리

- 컴포넌트(Component): JSX를 반환하는 함수. React 트리(Fiber 노드)를 만든다.
- Hook: 렌더링 중 호출되어 Fiber에 상태/효과/참조를 “슬롯”으로 등록/조회/업데이트 예약하는 API.
- 슬롯(Slot): 컴포넌트 Fiber가 가진 Hook 저장 위치(개념적으로 Hook#0, Hook#1, …).
- Custom Hook: Hook 호출을 조합한 “함수”. 별도의 Fiber/슬롯을 가지지 않는다.
- Context: 컴포넌트 트리 전체에서 값을 공유하기 위한 메커니즘(Provider value).

---

## 1. Hook이 단순 getter가 아닌 이유

### 1.1 “값 저장만” 하는 가짜 훅이 실패하는 이유

아래 코드는 값은 바뀌지만 화면은 안 바뀐다(React가 업데이트를 모름).

```js
// 가짜 상태 저장소
let globalCount = 0;

function fakeUseState() {
  return [
    globalCount,
    (v) => { globalCount = typeof v === "function" ? v(globalCount) : v; }
  ];
}

export default function App() {
  const [count, setCount] = fakeUseState();

  return (
    <button onClick={() => setCount(c => c + 1)}>
      {count}
    </button>
  );
}
```

핵심 차이:

- 진짜 useState의 setState는 “값 변경”이 아니라 “업데이트 큐 등록 + 리렌더 스케줄링”을 한다.
- fakeUseState는 React 스케줄러에 아무 것도 전달하지 않는다.

---

## 2. Hook 내부 구조(개념)와 슬롯

### 2.1 Hook 객체(개념)

```txt
Hook {
  memoizedState: 현재 훅 결과값,
  queue: { pending, dispatch },  // useState/useReducer 계열
  next: 다음 Hook
}
```

- memoizedState: 현재 state, effect deps/cleanup, ref 객체 등 “훅의 결과”
- queue.pending: setState로 쌓인 업데이트(연결 리스트)
- queue.dispatch: setState 함수(해당 Fiber + Hook 슬롯을 캡처)
- next: Hook 연결 리스트의 다음 노드

### 2.2 슬롯은 “컴포넌트 Fiber”가 가진다

```txt
Fiber(App)
  memoizedState (Hook 리스트 시작)
    ├─ Hook#0 (useState ...)
    ├─ Hook#1 (useEffect ...)
    └─ Hook#2 (useRef ...)
```

Custom Hook은 Fiber가 없으므로 슬롯을 “소유”하지 않는다.

---

## 3. 인덱스 매칭(호출 순서) 원리

React는 훅을 이름으로 찾지 않고, 렌더링 중 호출되는 “순서”로 매칭한다.

```jsx
function Comp() {
  const [a, setA] = useState(0); // Hook#0
  const [b, setB] = useState(10); // Hook#1
  useEffect(() => {}, []); // Hook#2
  return null;
}
```

렌더마다 동일 순서로 호출되면, Hook#0은 항상 a, Hook#1은 항상 b다.

---

## 4. Rules of Hooks (규칙) + “왜” (예제)

### 4.1 규칙 요약

1) Hook은 컴포넌트 함수 또는 Custom Hook에서만 호출  
2) Hook은 최상단(top-level)에서만 호출  
3) Hook은 매 렌더마다 “동일한 순서/개수”로 호출  
4) Custom Hook은 관례적으로 `use`로 시작 (eslint + 팀 규칙 강제)

---

### 4.2 조건문에서 Hook 호출: 깨지는 최소 예제

#### 잘못된 코드

```jsx
import { useEffect, useState } from "react";

export default function BadIfHook({ enabled }) {
  const [a, setA] = useState(0); // Hook#0

  if (enabled) {
    useEffect(() => {            // Hook#1 (enabled=true일 때만)
      console.log("enabled effect");
    }, []);
  }

  const [b, setB] = useState(100); // enabled=true면 Hook#2, false면 Hook#1

  return (
    <div>
      <div>a: {a}</div>
      <div>b: {b}</div>
      <button onClick={() => setA(x => x + 1)}>a++</button>
      <button onClick={() => setB(x => x + 1)}>b++</button>
    </div>
  );
}
```

#### 왜 깨지나(슬롯 관점)

- enabled=true 렌더: Hook#0=a, Hook#1=effect, Hook#2=b
- enabled=false 렌더: Hook#0=a, Hook#1=b

즉 b가 effect 자리(Hook#1)로 들어가려 해서 상태/타입 매칭이 붕괴한다.

#### 올바른 코드(호출은 고정, 실행만 조건부)

```jsx
import { useEffect, useState } from "react";

export default function GoodIfHook({ enabled }) {
  const [a, setA] = useState(0);
  const [b, setB] = useState(100);

  useEffect(() => {
    if (!enabled) return;
    console.log("enabled effect");
  }, [enabled]);

  return (
    <div>
      <div>a: {a}</div>
      <div>b: {b}</div>
      <button onClick={() => setA(x => x + 1)}>a++</button>
      <button onClick={() => setB(x => x + 1)}>b++</button>
    </div>
  );
}
```

---

### 4.3 조기 return 때문에 Hook 호출이 달라지는 예제

#### 잘못된 코드

```jsx
import { useEffect, useState } from "react";

export default function BadEarlyReturn({ loading }) {
  const [data, setData] = useState(null); // Hook#0

  if (loading) return <div>Loading...</div>; // 여기서 끝나면 아래 훅은 호출되지 않음

  useEffect(() => { // Hook#1 (loading=false일 때만)
    console.log("side effect");
  }, []);

  return <div>Done</div>;
}
```

#### 올바른 코드

```jsx
import { useEffect, useState } from "react";

export default function GoodEarlyReturn({ loading }) {
  const [data, setData] = useState(null);

  useEffect(() => {
    if (loading) return;
    console.log("side effect");
  }, [loading]);

  if (loading) return <div>Loading...</div>;
  return <div>Done</div>;
}
```

---

### 4.4 반복문에서 Hook 호출: 아이템 개수 변화로 붕괴

#### 잘못된 코드

```jsx
import { useEffect } from "react";

export default function BadLoopHook({ items }) {
  for (const item of items) {
    useEffect(() => { // items 길이 변하면 훅 개수 변함
      console.log("item:", item);
    }, [item]);
  }
  return <div>count: {items.length}</div>;
}
```

#### 올바른 코드(컴포넌트 분리)

```jsx
import { useEffect } from "react";

function ItemLogger({ item }) {
  useEffect(() => {
    console.log("item:", item);
  }, [item]);
  return null;
}

export default function GoodLoopHook({ items }) {
  return (
    <div>
      {items.map(item => (
        <ItemLogger key={item.id ?? item} item={item} />
      ))}
    </div>
  );
}
```

---

## 5. Custom Hook: 구조와 동작

### 5.1 Custom Hook 한 줄 정의

Custom Hook은 “새 훅 종류”가 아니라 “훅 호출 구조(패턴)를 재사용”하는 함수다.

- 슬롯은 Custom Hook이 아니라 “호출한 컴포넌트 Fiber”가 차지한다.
- 호출할 때마다 슬롯이 새로 소비되며 상태는 독립적이다.

---

### 5.2 슬롯이 어디에 생기는지(핵심 예제)

```jsx
import { useState } from "react";

function useCounter() {
  const [count, setCount] = useState(0); // 이 호출이 슬롯을 소비한다
  const inc = () => setCount(c => c + 1);
  return { count, inc };
}

export default function App() {
  const a = useCounter(); // App Fiber의 Hook#0
  const b = useCounter(); // App Fiber의 Hook#1

  return (
    <div>
      <button onClick={a.inc}>a: {a.count}</button>
      <button onClick={b.inc}>b: {b.count}</button>
    </div>
  );
}
```

슬롯 구조(개념):

```txt
App Fiber
  Hook#0 → a.count (useCounter 내부 useState)
  Hook#1 → b.count (useCounter 내부 useState)
```

즉 “상태 공유”가 아니라 “구조 재사용 + 호출마다 독립 상태”다.

---

### 5.3 Custom Hook 상태가 바뀌면 어떤 일이 일어나나?

다음 예제를 기준으로:

```jsx
import { useState } from "react";

function useCounter() {
  const [count, setCount] = useState(0);

  const inc = () => setCount(c => c + 1);
  return { count, inc };
}

export default function App() {
  const { count, inc } = useCounter();
  return <button onClick={inc}>{count}</button>;
}
```

동작 흐름(개념):

1) inc() 실행 → setCount(action) 호출  
2) Hook#0.queue.pending에 Update(action) 추가  
3) React Scheduler에 “App Fiber 다시 렌더” 요청  
4) App 함수가 다시 실행(리렌더)  
5) useCounter()도 다시 실행  
6) useState가 Hook#0의 pending 업데이트를 적용해 memoizedState를 갱신  
7) 새로운 count로 JSX 계산 → 커밋 후 화면 갱신

중요:

- Custom Hook “만” 리렌더되는 개념은 없다.
- 항상 “그 Custom Hook을 호출한 컴포넌트”가 리렌더된다.

---

### 5.4 return 유무는 무엇을 바꾸나?

return 유무는 “슬롯/리렌더”와 무관하고, API 설계(외부에 무엇을 노출할지) 차이다.

#### return 없는 예제(부수효과 전용)

```js
import { useEffect } from "react";

export function useLogger(value) {
  useEffect(() => {
    console.log("value:", value);
  }, [value]);
}
```

사용:

```jsx
function App({ count }) {
  useLogger(count); // 호출만 하면 됨
  return null;
}
```

#### return 있는 예제(상태/액션 제공)

```js
import { useState } from "react";

export function useToggle(initial = false) {
  const [on, setOn] = useState(initial);
  const toggle = () => setOn(v => !v);
  return { on, toggle };
}
```

---

## 6. Custom Hook 설계 패턴(실무)

### 6.1 상태 + 액션만 노출(권장)

```js
import { useState } from "react";

export function useCounter(initial = 0) {
  const [count, setCount] = useState(initial);

  const inc = () => setCount(c => c + 1);
  const dec = () => setCount(c => c - 1);
  const reset = () => setCount(initial);

  return { count, inc, dec, reset };
}
```

포인트:
- setState 자체를 노출하기보다 “행위(inc/dec/reset)”를 노출하면 API가 안전해진다.

---

### 6.2 외부 값 기반 effect 캡슐화(useDebounce)

```js
import { useEffect, useState } from "react";

export function useDebounce(value, delayMs) {
  const [debounced, setDebounced] = useState(value);

  useEffect(() => {
    const id = setTimeout(() => setDebounced(value), delayMs);
    return () => clearTimeout(id);
  }, [value, delayMs]);

  return debounced;
}
```

사용:

```jsx
function SearchBox() {
  const [q, setQ] = useState("");
  const debouncedQ = useDebounce(q, 300);

  useEffect(() => {
    // debouncedQ로 API 호출
  }, [debouncedQ]);

  return <input value={q} onChange={e => setQ(e.target.value)} />;
}
```

---

### 6.3 ref 기반: DOM 이벤트/외부 라이브러리 연결(useOutsideClick)

```js
import { useEffect } from "react";

export function useOutsideClick(ref, onOutside) {
  useEffect(() => {
    function handler(e) {
      const el = ref.current;
      if (!el) return;
      if (el.contains(e.target)) return;
      onOutside(e);
    }

    document.addEventListener("mousedown", handler);
    return () => document.removeEventListener("mousedown", handler);
  }, [ref, onOutside]);
}
```

사용:

```jsx
import { useRef, useState } from "react";
import { useOutsideClick } from "./useOutsideClick";

function Modal() {
  const ref = useRef(null);
  const [open, setOpen] = useState(true);

  useOutsideClick(ref, () => setOpen(false));

  if (!open) return null;
  return <div ref={ref}>modal</div>;
}
```

---

## 7. Context: 진짜 “공유” 메커니즘

### 7.1 Context 한 줄 정의

Context는 props drilling 없이 “트리 전체”에서 값을 공유하는 메커니즘이다.

- 상태 저장 위치: Fiber 슬롯이 아니라 “Context 값(Provider value)”
- 구독 방식: useContext로 해당 Context를 구독

---

### 7.2 기본 예제(Theme)

```jsx
import { createContext, useContext, useMemo, useState } from "react";

const ThemeContext = createContext(null);

function ThemeProvider({ children }) {
  const [theme, setTheme] = useState("light");

  // value 객체는 useMemo로 안정화(불필요 리렌더 줄이기)
  const value = useMemo(() => ({ theme, setTheme }), [theme]);

  return <ThemeContext.Provider value={value}>{children}</ThemeContext.Provider>;
}

function useTheme() {
  const ctx = useContext(ThemeContext);
  if (!ctx) throw new Error("ThemeProvider 안에서만 useTheme 사용 가능");
  return ctx;
}

function Toolbar() {
  const { theme, setTheme } = useTheme();
  return (
    <button onClick={() => setTheme(t => (t === "light" ? "dark" : "light"))}>
      theme: {theme}
    </button>
  );
}

export default function App() {
  return (
    <ThemeProvider>
      <Toolbar />
    </ThemeProvider>
  );
}
```

핵심:
- ThemeProvider의 value가 바뀌면, ThemeContext를 구독하는 컴포넌트가 리렌더된다.
- Custom Hook(useTheme)은 “공유 상태”를 직접 만들지 않고 “접근 API”를 제공한다.

---

### 7.3 Context vs Custom Hook 요약

- Custom Hook: 구조(로직) 재사용, 상태는 호출한 컴포넌트 Fiber에 저장(독립)
- Context: 값 공유, Provider 기준으로 구독자에게 전달(공유)

---

## 8. “Invalid hook call”이 나는 대표 원인 예제

### 8.1 렌더링 중이 아닌 곳에서 Hook 호출

```jsx
import { useState } from "react";

export default function App() {
  function onClick() {
    useState(0); // 잘못된 호출: 렌더링 컨텍스트가 없음
  }

  return <button onClick={onClick}>click</button>;
}
```

Hook은 “렌더링 중”에만 dispatcher가 활성화되어 동작한다.
이 규칙을 깨면 Invalid hook call 오류가 발생한다.

---

## 9. 결론

Hook은 Fiber에 상태/효과를 저장하고 업데이트를 스케줄링하는 렌더링 API다.
Custom Hook은 별도의 슬롯을 갖지 않고, 내부 훅 호출들이 “호출한 컴포넌트 Fiber”의 슬롯을 순서대로 소비하게 만드는 구조 재사용 함수다.
Context는 트리 단위로 값을 공유하며, value 변경 시 구독자 컴포넌트를 리렌더한다.

---

## 10. 체크리스트

- Custom Hook을 조건문/반복문에서 호출하지 말 것
- 조건은 Hook “콜백 내부”에서 처리할 것
- Context value 객체는 useMemo로 안정화할 것(필요 시)
- 공유가 필요하면 Context(또는 전역 상태), 재사용이면 Custom Hook
- return 유무는 동작이 아니라 “외부 노출 API” 설계 문제

