# Immutable List/Map 연산 (push / set / update / merge) 설명 가이드

## 1. 기본 개념

Immutable의 핵심: \> 기존 데이터를 수정하지 않고 새 상태(새 버전)를
생성한다.

JS:

    수정 → 원본 변경

Immutable:

    연산 → 새 객체 반환
    원본 유지

------------------------------------------------------------------------

## 2. push (List)

### JS 배열

``` js
const arr = [1,2,3];
arr.push(4);
console.log(arr); // [1,2,3,4]
```

원본이 변경된다 (mutation)

------------------------------------------------------------------------

### Immutable List

``` js
const list = fromJS([1,2,3]);
const next = list.push(4);

list.toJS(); // [1,2,3]
next.toJS(); // [1,2,3,4]
```

핵심: \> push는 수정이 아니라 새 리스트 생성이다.

구조적 공유: - 기존 list 유지 - 4가 추가된 새 버전만 생성

------------------------------------------------------------------------

## 3. set (Map, List)

특정 위치 값을 교체

``` js
const state = fromJS({ a:1, b:2 });
const next = state.set("a",10);

state.get("a"); // 1
next.get("a");  // 10
```

의미: \> 해당 key의 값을 가진 새 객체를 생성한다.

JS였다면:

``` js
state.a = 10; // 원본 변경
```

Immutable: 원본 유지 + 새 상태 반환

------------------------------------------------------------------------

## 4. setIn (중첩 구조 변경)

``` js
const state = fromJS({
  user:{ age:20, name:"kim" }
});

const next = state.setIn(["user","age"],30);
```

결과:

    state.user.age = 20
    next.user.age  = 30

내부 동작: - user 노드만 새로 생성 - name은 그대로 재사용

이걸 **구조적 공유(structural sharing)** 라고 한다.

------------------------------------------------------------------------

## 5. update

기존 값을 기반으로 변경할 때 사용

``` js
const state = fromJS({ count:0 });

const next = state.update("count", v => v + 1);

state.get("count"); // 0
next.get("count");  // 1
```

특징: \> 현재 값을 함수로 계산하여 새 상태 생성

즉: set = 값 직접 지정\
update = 기존 값 기반 계산

------------------------------------------------------------------------

## 6. merge

여러 값을 한 번에 변경

``` js
const state = fromJS({
  name:"kim",
  age:20
});

const next = state.merge({
  name:"lee",
  age:30
});
```

결과:

    state 유지
    next만 변경

여러 set을 한 번에 처리하는 것과 동일.

------------------------------------------------------------------------

## 7. mergeDeep (중첩 병합)

``` js
const state = fromJS({
  user:{ name:"kim", age:20 }
});

const next = state.mergeDeep({
  user:{ age:30 }
});
```

결과:

    name 유지
    age만 변경

깊은 구조 병합.

------------------------------------------------------------------------

## 8. 왜 이것들이 복사 역할인가

JS에서:

    복사 → 수정

Immutable:

    연산 자체가 새 객체 생성

예:

``` js
const next = state.set("a",10);
```

이미 복사본이다.

------------------------------------------------------------------------

## 9. JSON 깊은복사와 차이

JSON: - 전체 새 객체 생성 - 비용 O(N)

Immutable: - 변경 경로만 새로 생성 - 나머지 재사용 - 비용 O(log N)

------------------------------------------------------------------------

## 10. 핵심 비교표

  연산        역할
  ----------- -------------------
  push        요소 추가
  set         값 교체
  setIn       중첩 값 변경
  update      기존 값 기반 변경
  merge       여러 값 동시 변경
  mergeDeep   깊은 병합

------------------------------------------------------------------------

## 11. 한 문장

> Immutable의 모든 연산(push/set/update/merge)은 수정이 아니라 새로운
> 상태(복사본)를 생성하는 함수이다.
