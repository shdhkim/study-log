# React `forwardRef` + `useImperativeHandle`상세 정리 

> 목표: **부모가 자식 컴포넌트의 특정 “동작(메서드)”만** 안전하게 호출하게 만들기  
> 핵심 키워드: `ref` → `forwardRef` → `useImperativeHandle`

---

## 0. 먼저 `ref`가 뭐였지?

React에서 `ref`는 크게 2가지에 붙는다.

1) **DOM 요소**에 붙기  
- `ref.current`가 실제 DOM을 가리킴  
- 예: input 포커스 주기

2) **클래스 컴포넌트 인스턴스**에 붙기  
- 함수 컴포넌트는 인스턴스가 없어서 기본적으로 안 됨  
- 그래서 **함수 컴포넌트에 ref를 전달하려면 `forwardRef`**가 필요

---

## 1. `forwardRef`는 왜 필요함?

부모가 이렇게 하고 싶다고 하자:

```jsx
const inputRef = useRef(null);

return <MyInput ref={inputRef} />;
```

근데 `MyInput`이 **함수 컴포넌트**면, 기본적으로 `ref`를 props처럼 받을 수 없다.  
이때 `forwardRef`를 쓰면:

- `ref`를 **두 번째 인자**로 받을 수 있음
- 그 `ref`를 내부 DOM에 붙이거나
- `useImperativeHandle`로 “내가 공개할 것만” 공개할 수도 있음

---

## 2. `useImperativeHandle`는 뭐함?

`useImperativeHandle(ref, createHandle, deps)` 는:

- 부모가 보게 될 `ref.current`의 모양(내용)을 **내가 직접 정의**하게 해준다.
- 즉, 자식 내부의 DOM/상태를 전부 노출하지 않고
- **필요한 메서드만 노출**하는 “캡슐화” 도구다.

---

# 예제 1) 가장 흔한 케이스: 부모가 자식 input에 포커스 주기

## ✅ 1-A. (기본) `forwardRef`로 DOM ref를 그대로 전달

부모:

```jsx
import { useRef } from "react";
import MyInput from "./MyInput";

export default function Parent() {
  const inputRef = useRef(null);

  return (
    <div>
      <button onClick={() => inputRef.current?.focus()}>
        자식 input focus
      </button>

      <MyInput ref={inputRef} />
    </div>
  );
}
```

자식:

```jsx
import { forwardRef } from "react";

const MyInput = forwardRef(function MyInput(props, ref) {
  return <input ref={ref} placeholder="여기가 포커스될 input" />;
});

export default MyInput;
```

### 동작
- 부모 `inputRef.current`는 실제 `<input>` DOM
- 그래서 `.focus()`를 직접 호출 가능

---

## ✅ 1-B. (권장 패턴) `useImperativeHandle`로 “focus만” 공개

자식에서 DOM을 “그대로” 노출하는 대신, **기능만 노출**할 수 있다.

부모:

```jsx
import { useRef } from "react";
import MyInput from "./MyInput";

export default function Parent() {
  const inputApiRef = useRef(null);

  return (
    <div>
      <button onClick={() => inputApiRef.current?.focus()}>
        focus 호출
      </button>

      <button onClick={() => inputApiRef.current?.clear()}>
        clear 호출
      </button>

      <MyInput ref={inputApiRef} />
    </div>
  );
}
```

자식:

```jsx
import { forwardRef, useImperativeHandle, useRef } from "react";

const MyInput = forwardRef(function MyInput(props, ref) {
  const inputRef = useRef(null);

  useImperativeHandle(
    ref,
    () => ({
      focus() {
        inputRef.current?.focus();
      },
      clear() {
        if (inputRef.current) inputRef.current.value = "";
      },
    }),
    []
  );

  return <input ref={inputRef} placeholder="API로만 제어되는 input" />;
});

export default MyInput;
```

### 포인트
- 부모는 이제 `ref.current`를 통해 **DOM 자체가 아니라 API 객체**를 받는다.
- `ref.current.focus()` / `ref.current.clear()` 같은 “자식이 허락한 것만” 가능.

---

# 예제 2) 스크롤 컨테이너: 부모가 자식 박스를 위로 올리기

부모:

```jsx
import { useRef } from "react";
import ScrollBox from "./ScrollBox";

export default function Parent() {
  const boxRef = useRef(null);

  return (
    <div>
      <button onClick={() => boxRef.current?.scrollToTop()}>
        맨 위로
      </button>

      <ScrollBox ref={boxRef} />
    </div>
  );
}
```

자식:

```jsx
import { forwardRef, useImperativeHandle, useRef } from "react";

const ScrollBox = forwardRef(function ScrollBox(props, ref) {
  const divRef = useRef(null);

  useImperativeHandle(
    ref,
    () => ({
      scrollToTop() {
        divRef.current?.scrollTo({ top: 0, behavior: "smooth" });
      },
      scrollToBottom() {
        const el = divRef.current;
        if (!el) return;
        el.scrollTo({ top: el.scrollHeight, behavior: "smooth" });
      },
    }),
    []
  );

  return (
    <div
      ref={divRef}
      style={{
        height: 140,
        overflow: "auto",
        border: "1px solid #aaa",
        padding: 8,
      }}
    >
      {Array.from({ length: 50 }).map((_, i) => (
        <div key={i}>row {i + 1}</div>
      ))}
    </div>
  );
});

export default ScrollBox;
```

---

# 예제 3) 폼 검증: 부모가 “validate()”만 호출하고 싶을 때

이 패턴은 **부모가 제출 버튼을 갖고 있고**, 자식 폼들이 여러 개인 경우에 특히 유용하다.

부모:

```jsx
import { useRef } from "react";
import ProfileForm from "./ProfileForm";

export default function Parent() {
  const formRef = useRef(null);

  const onSubmit = () => {
    const result = formRef.current?.validate();
    if (!result?.ok) {
      alert(result?.message);
      return;
    }
    alert("제출 OK!");
  };

  return (
    <div>
      <ProfileForm ref={formRef} />
      <button onClick={onSubmit}>제출</button>
    </div>
  );
}
```

자식:

```jsx
import { forwardRef, useImperativeHandle, useState } from "react";

const ProfileForm = forwardRef(function ProfileForm(props, ref) {
  const [name, setName] = useState("");
  const [age, setAge] = useState("");

  useImperativeHandle(
    ref,
    () => ({
      validate() {
        if (name.trim().length === 0) {
          return { ok: false, message: "이름을 입력하세요" };
        }
        const n = Number(age);
        if (!Number.isFinite(n) || n <= 0) {
          return { ok: false, message: "나이는 1 이상의 숫자" };
        }
        return { ok: true };
      },
      // 필요하면 값도 가져가게 할 수 있음(선택)
      getValues() {
        return { name, age };
      },
    }),
    [name, age]
  );

  return (
    <div style={{ border: "1px solid #ddd", padding: 12 }}>
      <div>
        이름:{" "}
        <input value={name} onChange={(e) => setName(e.target.value)} />
      </div>
      <div>
        나이:{" "}
        <input value={age} onChange={(e) => setAge(e.target.value)} />
      </div>
    </div>
  );
});

export default ProfileForm;
```

### 포인트
- `useImperativeHandle`의 deps에 `[name, age]`를 둔 이유:
  - 부모가 보는 `validate()`가 최신 `name/age`를 반영하게 만들기 위함
- “부모가 자식 상태를 직접 만지는 것”이 아니라, **검증이라는 기능만** 호출

---

## 4. 언제 쓰고, 언제 피해야 하나?

### ✅ 쓰면 좋은 경우
- focus/scroll처럼 **DOM 명령형 제어가 필요한 경우**
- 부모 버튼이 있고 자식 내부 로직(검증/초기화)을 **메서드로 호출**해야 하는 경우
- 라이브러리 래핑 컴포넌트(예: 커스텀 Input, DatePicker 래퍼)에서 필요한 API만 공개

### ❌ 남발하면 안 좋은 경우
- 상태 공유/데이터 전달을 `ref`로 해결하려는 경우  
  → 보통은 `props`, `state`, `context`가 더 정석
- “부모가 자식 내부 상태를 마음대로 조작”하게 만들고 싶은 경우  
  → 유지보수 난이도 급상승

---

## 5. 자주 헷갈리는 포인트 5개

1) `forwardRef` 없으면 함수 컴포넌트에 `ref` 전달이 안 됨  
2) `useImperativeHandle`을 쓰면 `ref.current`가 DOM이 아니라 **내가 만든 객체**가 될 수 있음  
3) `ref` 값 바꿔도 렌더링은 안 일어남 (state가 아님)  
4) `ref.current`는 초기에는 `null`일 수 있음 → `?.` 등으로 안전 처리  
5) React StrictMode(dev)에서는 마운트/언마운트가 “한 번 더” 실행돼 보일 수 있음  
   - 이건 개발 모드에서 사이드이펙트 검출용이라, 실제 배포(prod) 동작과 다를 수 있음

---

## 6. 한 줄 요약

- `forwardRef`: **부모가 준 ref를 자식 함수 컴포넌트가 받을 수 있게** 해준다.
- `useImperativeHandle`: **부모가 ref로 접근 가능한 기능(메서드)만 골라서** 공개한다.

---

