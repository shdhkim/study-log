# React Hook · Ref · StrictMode · Cleanup 총정리 


---

## 1. React에서 렌더링이란?

### 렌더링의 정의
React에서 렌더링이란 **컴포넌트 함수를 실행하여 JSX 결과를 계산하는 것**이다.

```jsx
function Comp() {
  let x = 0;
  return <div>{x}</div>;
}
```

렌더링 발생 시:
- 컴포넌트 함수가 실행된다
- 함수 내부 코드가 위에서 아래까지 전부 실행된다
- 변수 선언과 초기화도 매번 다시 실행된다

---

## 2. 함수 정의 vs 함수 실행

### 함수 정의 (실행되지 않음)

```jsx
function Comp() {
  function hello() {
    console.log("hello");
  }

  return <div />;
}
```

- 렌더링 시 hello는 **정의만** 된다
- console.log는 실행되지 않는다

---

### 함수 호출 (실행됨)

```jsx
function Comp() {
  function hello() {
    console.log("hello");
  }

  hello(); // 호출

  return <div />;
}
```

- 렌더링마다 실행된다
- StrictMode에서는 두 번 실행될 수 있다

---

### 이벤트 핸들러

```jsx
<button onClick={hello}>클릭</button>
```

- 렌더링 시 실행되지 않는다
- 클릭할 때 실행된다

---

## 3. 일반 변수 vs useState

### 일반 변수

```jsx
function Counter() {
  let count = 0;

  return (
    <button onClick={() => count++}>
      {count}
    </button>
  );
}
```

- 렌더링 때마다 count는 0으로 초기화
- 값이 바뀌어도 React는 모른다
- 화면에 반영되지 않는다

---

### useState

```jsx
function Counter() {
  const [count, setCount] = useState(0);

  return (
    <button onClick={() => setCount(count + 1)}>
      {count}
    </button>
  );
}
```

- 값이 React 내부에 저장된다
- setCount 호출 시 재렌더링이 발생한다
- 화면에 반영된다

---

## 4. useRef

### useRef의 역할
렌더링과 무관하게 값을 저장하는 상자

```js
const ref = useRef(0);
ref.current++;
```

- 값은 유지된다
- 변경돼도 렌더링은 발생하지 않는다
- DOM 접근에 사용된다

---

### DOM 접근 예제

```jsx
function FocusInput() {
  const inputRef = useRef(null);

  return (
    <>
      <input ref={inputRef} />
      <button onClick={() => inputRef.current.focus()}>
        포커스
      </button>
    </>
  );
}
```

---

## 5. Render Phase vs Commit Phase

### Render Phase
- 컴포넌트 함수 실행
- JSX 계산
- 순수해야 함
- 여러 번 실행 가능

### Commit Phase
- 실제 DOM 반영
- ref 연결
- useEffect 실행
- side-effect 허용

---

## 6. useEffect와 cleanup

### 기본 구조

```js
useEffect(() => {
  // effect
  return () => {
    // cleanup
  };
}, deps);
```

---

### cleanup 예제

```js
useEffect(() => {
  window.addEventListener("resize", onResize);
  return () => {
    window.removeEventListener("resize", onResize);
  };
}, []);
```

cleanup은 실제로 실행되며:
- 컴포넌트 제거 시
- effect 재실행 직전에 호출된다

---

## 7. 부모-자식 컴포넌트와 unmount

```jsx
{show && <Child />}
```

- show가 false가 되면 Child는 unmount된다
- Child의 cleanup이 실행된다

부모가 사라지면 자식도 함께 unmount된다  
cleanup 실행 순서: 자식 → 부모

---

## 8. StrictMode

StrictMode는 개발 모드에서:
- Render Phase를 의도적으로 두 번 실행
- mount → cleanup → mount 시뮬레이션
- 부작용 있는 코드를 조기에 발견

프로덕션에는 영향이 없다

---

## 9. forwardRef

함수 컴포넌트는 기본적으로 ref를 받을 수 없다

```jsx
const Child = forwardRef((props, ref) => {
  return <input ref={ref} />;
});
```

부모 ref를 자식 내부로 전달하는 공식 방법이다

---

## 10. useImperativeHandle

부모에게 DOM 전체가 아닌 기능만 노출한다

```jsx
useImperativeHandle(ref, () => ({
  focus() {
    inputRef.current.focus();
  }
}));
```

- 정의만 해야 한다
- 즉시 실행하면 안 된다
- 실행은 부모가 호출할 때만 한다

---

## 11. 커스텀 훅과 순수성

커스텀 훅은 렌더 단계에서 실행된다  
실행만으로 부작용이 생기면 안 된다

### 잘못된 예
```js
function useBad() {
  window.addEventListener("resize", handler);
}
```

### 올바른 예
```js
function useResize(handler) {
  useEffect(() => {
    window.addEventListener("resize", handler);
    return () => {
      window.removeEventListener("resize", handler);
    };
  }, [handler]);
}
```

---

## 12. 최종 요약

- 렌더링 = 컴포넌트 함수 실행
- 변수는 렌더마다 초기화된다
- UI는 state로 제어한다
- ref는 렌더와 무관한 저장소다
- side-effect는 effect에서만 처리한다
- cleanup은 실제로 실행된다
- StrictMode는 버그 탐지용이다
