# React Hook · Rendering · Batching 총정리

본 문서는 지금까지 정리한 **Hook의 본질**, **렌더링 반영 과정**, **배칭(Batching)** 개념을 하나의 흐름으로 정리한 자료다.

---

## 1. Hook이란 무엇인가

### 1.1 Hook의 정체

* Hook은 단순한 함수가 아님
* **함수 컴포넌트에 상태/부수효과를 연결하기 위한 React 내부 메커니즘**
* 실제 상태는 JS 변수에 있는 게 아니라 **Fiber에 연결된 Hook 슬롯**에 저장됨

```txt
Fiber
 └─ hooks (linked list)
     ├─ hook[0] useState
     ├─ hook[1] useEffect
     └─ hook[2] useRef
```

* Hook은 **호출 순서로 식별됨** (이름 아님)

---

## 2. 렌더링 시 Hook이 반영되는 과정

### 2.1 최초 렌더링 (mount)

```js
const [count, setCount] = useState(0);
```

* hook 슬롯 생성
* 초기 state 저장 (0)
* setState 함수는 해당 슬롯과 연결됨

```txt
hook[0].state = 0
```

---

### 2.2 setState 호출 시

```js
setCount(1);
```

* 상태가 즉시 바뀌지 않음
* 해당 hook의 **updateQueue**에 action 추가
* Fiber를 "업데이트 필요"로 마킹

```txt
updateQueue = [1]
```

---

### 2.3 재렌더링 (render phase)

* 컴포넌트 함수 재실행
* Hook은 다시 생성되지 않고 **기존 슬롯 재사용**
* updateQueue를 순차 처리하여 최종 state 계산

```txt
prevState: 0
apply action: 1
nextState: 1
```

---

### 2.4 Commit 단계

* DOM 변경 사항 실제 반영
* useEffect 실행

```txt
Render Phase  : 계산만 수행
Commit Phase  : DOM 반영 + effect 실행
```

---

## 3. Hook 규칙의 이유

### 3.1 조건문 안에서 Hook 호출 불가

```js
if (cond) {
  useState(0);
}
```

* Hook은 **호출 순서로 매핑**되기 때문에
* 렌더마다 순서가 달라지면 상태가 꼬임

---

## 4. 배칭(Batching)이란 무엇인가

### 4.1 정의

> 배칭 = **여러 state 업데이트를 모아서 렌더링을 1번만 수행하는 정책**

```js
setA(1);
setB(2);
```

* update는 여러 개
* render + commit은 1번

---

### 4.2 배칭의 본질

* 배칭은 **업데이트를 합치는 것**이 아님
* **렌더 트리거를 지연시켜 1번만 실행하는 것**

```txt
updateQueue = [A, B]
render = 1회
```

---

## 5. 배칭과 이벤트 루프의 관계

### 5.1 핵심 결론

* ❌ 배칭 = 마이크로태스크에 묶는 것 아님
* ⭕ 배칭 = **같은 실행 경계(boundary) 안에서 발생한 업데이트를 한 번에 렌더**

---

### 5.2 실행 경계(boundary)의 의미

배칭 경계 예시:

* React 이벤트 핸들러 1회
* Promise.then 콜백 1회 (React 18)
* setTimeout 콜백 1회 (React 18)

```txt
[콜백 실행 시작]
 setState
 setState
[콜백 종료]
 → render 1회
```

---

## 6. React 17 vs React 18 배칭 차이

### React 17

* React 이벤트 안에서만 배칭
* 비동기(setTimeout, Promise)에서는 배칭 X

### React 18

* **Automatic Batching**
* 비동기 콜백에서도 기본적으로 배칭 적용

---

## 7. 왜 Promise.then 예제가 자주 나오나

```js
Promise.resolve().then(() => {
  setA(1);
  setB(2);
});
```

* React가 Promise를 만들어서 묶는 게 아님
* 개발자가 **같은 실행 경계를 만든 것**
* React 18이 그 경계에서도 배칭을 허용했을 뿐

---

## 8. 함수형 업데이트가 중요한 이유

### 잘못된 예

```js
setCount(count + 1);
setCount(count + 1);
```

* 같은 스냅샷 사용 → +1만 반영

### 올바른 예

```js
setCount(prev => prev + 1);
setCount(prev => prev + 1);
```

* updateQueue에서 순차 적용 → +2

---

## 9. 배칭을 깨는 방법

### flushSync

```js
flushSync(() => {
  setCount(1);
});
```

* 즉시 render + commit 강제
* 레이아웃 측정 등 특수 상황에서만 사용

---

## 10. 재렌더링(Re-rendering)

### 10.1 재렌더링의 정의

> 재렌더링이란 **함수 컴포넌트가 다시 실행되어 새로운 UI 결과를 계산하는 과정**이다.

* 재렌더링 ≠ DOM 전체 재생성
* 재렌더링 = **컴포넌트 함수 재실행 + Virtual DOM 재계산**

---

### 10.2 재렌더링이 발생하는 조건

다음 중 하나라도 발생하면 재렌더링이 일어난다.

1. state 변경 (`setState`, `dispatch`)
2. props 변경
3. 부모 컴포넌트 재렌더링
4. context 값 변경

---

### 10.3 재렌더링 시 내부 동작 흐름

```txt
1. 컴포넌트 함수 재실행
2. Hook 순서대로 재호출 (슬롯 재사용)
3. JSX 재계산 (Virtual DOM 생성)
4. 이전 Virtual DOM과 diff
5. 변경된 부분만 Commit 단계에서 DOM 반영
```

---

### 10.4 재렌더링과 Hook의 관계

* Hook은 재렌더링 때 **다시 호출되지만 초기화되지는 않음**
* state 값은 Fiber에 저장된 기존 슬롯에서 유지됨

```js
useState(0); // 재렌더링 시 0으로 초기화되지 않음
```

---

### 10.5 재렌더링이 발생하지 않는 경우

```js
let count = 0;
count++; // React가 인지하지 못함
```

```js
ref.current++; // 값은 변경되지만 재렌더링 발생 X
```

---

### 10.6 배칭과 재렌더링의 관계

* 여러 setState가 발생해도
* 같은 배칭 경계 안에 있으면
* **재렌더링은 1번만 발생**

```txt
setState × N
→ updateQueue 누적
→ 재렌더링 1회
```

---

## 11. DOM 반영 시점 (Render vs Commit)

### 11.1 React에서 DOM은 언제 반영되는가

> **DOM은 render 단계가 끝난 뒤, commit 단계에서만 실제로 반영된다.**

React의 렌더링은 항상 두 단계로 나뉜다.

```txt
1️⃣ Render Phase  : 계산만 수행 (DOM 변경 ❌)
2️⃣ Commit Phase  : 실제 DOM 반영 (DOM 변경 ⭕)
```

---

### 11.2 Render Phase에서 하는 일

* 컴포넌트 함수 재실행 (재렌더링)
* Hook 처리 (state 계산)
* JSX → Virtual DOM 생성
* 이전 Virtual DOM과 diff

📌 Render Phase에서는 **절대 DOM을 건드리지 않는다**

```txt
❌ document.querySelector
❌ DOM 수정
❌ layout 측정
```

---

### 11.3 Commit Phase에서 하는 일

Commit 단계에서만 실제 브라우저 DOM이 변경된다.

```txt
✔ DOM 노드 생성 / 삭제
✔ attribute 변경
✔ text 변경
✔ ref 연결
✔ effect 실행 준비
```

---

### 11.4 전체 업데이트 타임라인

```txt
setState 호출
 ↓
[Render Phase]
- 컴포넌트 재실행
- Virtual DOM 계산
 ↓
[Commit Phase]
- 실제 DOM 반영
 ↓
[Paint]
- 브라우저 화면 출력
 ↓
useEffect 실행
```

---

### 11.5 useLayoutEffect vs useEffect 실행 시점

#### useLayoutEffect

```js
useLayoutEffect(() => {
  // DOM 반영 직후, paint 이전
});
```

```txt
Commit Phase
 → DOM 반영
 → useLayoutEffect 실행
 → Paint
```

* DOM 측정 가능
* 화면 깜빡임 없음

---

#### useEffect

```js
useEffect(() => {
  // DOM 반영 + paint 이후
});
```

```txt
Commit Phase
 → DOM 반영
 → Paint
 → useEffect 실행
```

* 비동기적 실행
* 사용자에게 화면이 먼저 보임

---

### 11.6 배칭과 DOM 반영의 관계

```js
setA(1);
setB(2);
```

* updateQueue에는 여러 update 누적
* render 1회
* commit 1회
* DOM 반영 1회

DOM은 **배칭 결과의 최종 상태만 반영**된다.

---

## 12. 최종 요약

* Hook은 Fiber에 저장된 **순서 기반 슬롯**이다
* setState는 **즉시 변경이 아니라 재렌더링 예약**이다
* 배칭은 **렌더/커밋을 1번으로 줄이는 정책**이다
* 재렌더링은 **DOM 재생성이 아니라 컴포넌트 함수 재실행**이다
* DOM 변경은 **항상 Commit Phase에서만 발생**한다
* DOM 측정이 필요하면 **useLayoutEffect**, 일반 부수효과는 **useEffect**를 사용한다
