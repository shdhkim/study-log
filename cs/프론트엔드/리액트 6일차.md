# JavaScript 비동기 & React Batching 정리



---

## 1. 콜백(Callback)이란?

### 정의
콜백 함수란 **다른 함수에 인자로 전달되어, 나중에 실행되는 함수**다.

```js
function run(cb) {
  console.log("run start");
  cb();
  console.log("run end");
}

run(() => {
  console.log("callback");
});
```

### 실행 순서
```
run start
callback
run end
```

> 콜백 자체는 동기/비동기를 결정하지 않는다.  
> **어디에서 호출/등록되느냐**가 전부다.

---

## 2. 동기 콜백 vs 비동기 콜백

### 2-1. 동기 콜백

```js
function sync(cb) {
  console.log("1");
  cb();
  console.log("3");
}

sync(() => {
  console.log("2");
});
```

출력
```
1
2
3
```

- 콜백이 **즉시 실행**
- 콜스택에서 처리

---

### 2-2. 비동기 콜백

```js
console.log("1");

setTimeout(() => {
  console.log("2");
}, 0);

console.log("3");
```

출력
```
1
3
2
```

- 콜백이 **매크로태스크 큐**에 들어감
- 콜스택 종료 후 실행

---

## 3. 콜스택(Call Stack)

### 개념
- 실행 중인 함수가 쌓이는 공간
- LIFO 구조

### 예제

```js
function a() {
  console.log("a");
  b();
}

function b() {
  console.log("b");
  c();
}

function c() {
  console.log("c");
}

a();
```

### 콜스택 흐름
```
a → b → c → 종료
```

---

## 4. 이벤트 루프(Event Loop)

### 전체 실행 사이클
```
1. 콜스택 실행
2. 마이크로태스크 전부 실행
3. 렌더링
4. 매크로태스크 1개 실행
5. 반복
```

---

## 5. 마이크로태스크(Microtask)

### 특징
- 콜스택 직후 실행
- 큐가 빌 때까지 전부 실행
- 매크로태스크보다 우선

### 예제

```js
console.log("A");

Promise.resolve().then(() => {
  console.log("B");
});

console.log("C");
```

출력
```
A
C
B
```

---

## 6. 매크로태스크(Macrotask)

### 특징
- 이벤트 단위 작업
- 이벤트 루프 한 사이클에 1개

### 예제

```js
console.log("A");

setTimeout(() => {
  console.log("B");
}, 0);

console.log("C");
```

출력
```
A
C
B
```

---

## 7. 왜 setTimeout(0)도 늦게 실행될까?

```js
console.log("1");

setTimeout(() => {
  console.log("2");
}, 0);

Promise.resolve().then(() => {
  console.log("3");
});

console.log("4");
```

출력
```
1
4
3
2
```

이유:
- Promise.then → 마이크로태스크
- setTimeout → 매크로태스크
- 마이크로태스크가 항상 먼저

---

## 8. 이벤트 핸들러(Event Handler)

### 순수 JS

```js
button.addEventListener("click", () => {
  console.log("clicked");
});
```

- 브라우저가 호출
- 매크로태스크로 실행

---

## 9. React 이벤트 핸들러

```jsx
function App() {
  const handleClick = () => {
    console.log("click");
  };

  return <button onClick={handleClick}>Click</button>;
}
```

특징:
- Synthetic Event
- 이벤트 핸들러 = 하나의 렌더 트랜잭션

---

## 10. React Batching

### 기본 예제

```jsx
const handleClick = () => {
  setCount(c => c + 1);
  setCount(c => c + 1);
  setCount(c => c + 1);
};
```

- 렌더링 1번
- count +3

---

## 11. 잘못된 setState 예제

```jsx
const handleClick = () => {
  setCount(count + 1);
  setCount(count + 1);
};
```

문제:
- 같은 스냅샷 사용
- 값 꼬임

해결:
```js
setCount(prev => prev + 1);
```

---

## 12. React 18 자동 Batching + Promise

```jsx
const handleClick = async () => {
  setCount(c => c + 1);
  await Promise.resolve();
  setCount(c => c + 1);
};
```

- 같은 이벤트 루프 턴
- 렌더링 1번

---

## 13. batching이 끊기는 경우

```jsx
const handleClick = () => {
  setCount(c => c + 1);

  setTimeout(() => {
    setCount(c => c + 1);
  }, 0);
};
```

- 다음 매크로태스크
- 렌더링 2번

---

## 14. flushSync

### 개념
- batching 강제 종료
- 즉시 렌더링

```js
import { flushSync } from "react-dom";

flushSync(() => {
  setCount(1);
});
```

---

## 15. flushSync 실제 사용 예

```js
flushSync(() => {
  setOpen(true);
});

const height = ref.current.offsetHeight;
```

- DOM이 최신 상태여야 할 때만 사용

---

## 16. 전체 흐름 요약

```
콜백은 함수다
동기 → 콜스택
Promise / await → 마이크로태스크
setTimeout / 이벤트 → 매크로태스크

React는 같은 이벤트 루프 턴이면 batching
flushSync는 batching을 강제로 중단
```

---

## 17. 면접용 한 문장 요약

JavaScript는 단일 스레드 환경에서 이벤트 루프를 통해 비동기를 처리하며,  
Promise는 마이크로태스크, setTimeout은 매크로태스크로 실행된다.  
React는 성능 최적화를 위해 상태 업데이트를 배치 처리하고,  
flushSync는 이를 강제로 즉시 반영할 때 사용하는 도구다.
