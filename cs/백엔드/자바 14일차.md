# Java Comparator · Lambda · Method Reference 완전 정리

## 1. Comparator.sort 기본 구조

```java
users.sort(Comparator<User>);
```

- `sort()`는 **Comparator 인터페이스**를 요구한다.
- Comparator는 두 객체를 비교해 정렬 순서를 결정한다.

```java
@FunctionalInterface
public interface Comparator<T> {
    int compare(T o1, T o2);
}
```

---

## 2. 람다식으로 Comparator 구현

```java
users.sort((a, b) -> Integer.compare(a.getAge(), b.getAge()));
```

### 특징
- Comparator를 **직접 구현**
- 비교 로직을 자유롭게 작성 가능
- 중간 단계 없음

### 내부 개념 (설명용)
```java
Comparator<User> c = (u1, u2) -> {
    return Integer.compare(u1.getAge(), u2.getAge());
};
```

---

## 3. Comparator.comparing 구조

### 3.1 기본 comparing (키 추출만)

```java
users.sort(Comparator.comparing(User::getAge));
```

#### 시그니처
```java
static <T, U extends Comparable<? super U>>
Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor)
```

- 객체 `T` → 키 `U` 추출
- 키는 `Comparable`이어야 함
- `compareTo()`로 비교

---

### 3.2 comparing + 키 비교기

```java
users.sort(
    Comparator.comparing(
        User::getAge,
        Comparator.reverseOrder()
    )
);
```

#### 시그니처
```java
static <T, U>
Comparator<T> comparing(
    Function<? super T, ? extends U> keyExtractor,
    Comparator<? super U> keyComparator
)
```

- 키 추출 방식 지정
- 키 비교 방식 직접 지정

---

## 4. Function과 Comparator의 관계

```java
users.sort(Comparator.comparing(User::getAge));
```

### 동작 흐름
1. `User::getAge` → `Function<User, Integer>` 로 해석
2. `comparing()`이 Function을 받아 Comparator 생성
3. `sort()`는 Comparator만 사용

### 개념 흐름
```
User::getAge
  ↓ (타깃 타입)
Function<User, Integer>
  ↓
Comparator<User>
  ↓
sort()
```

---

## 5. 메서드 참조와 람다의 관계

### 메서드 참조
```java
User::getAge
```

### 동치 람다 (설명용)
```java
(User u) -> u.getAge()
```

- 실제로 람다 코드로 변환되는 것은 아님
- 동작이 동일함을 설명하기 위한 표현
- 둘 다 결과는 Function 구현체

---

## 6. Function은 함수가 아니라 인터페이스

```java
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}
```

```java
Function<User, Integer> f = User::getAge;
```

의미:
- `apply(User)`를 호출하면 `Integer` 반환
- Function은 **객체 타입**

---

## 7. 람다 / 메서드 참조 vs 익명 클래스

### 7.1 익명 클래스

### 익명 클래스를 화살표 함수(람다)로 풀어쓴 형태 

```java
// 익명 클래스 방식
Function<User, Integer> f1 = new Function<>() {
    @Override
    public Integer apply(User u) {
        return u.getAge();
    }
};

// 위 익명 클래스를 람다식으로 표현하면 아래와 같다
Function<User, Integer> f2 = (User u) -> u.getAge();
```

- 두 코드는 **동작 결과는 동일**하다.
- 하지만 구현 방식은 다르다.
  - 익명 클래스: 컴파일 시 별도의 클래스 구조가 만들어질 수 있음
  - 람다식: 컴파일 시 `invokedynamic` 기반으로 런타임에 연결됨
- 또한 `this`의 의미가 다르다.
  - 익명 클래스의 `this` → 익명 클래스 인스턴스
  - 람다식의 `this` → 바깥 클래스 인스턴스


---

### 7.2 람다 / 메서드 참조

### 메서드 참조를 화살표 함수(람다)로 풀어쓴 형태 

```java
// 메서드 참조
Function<User, Integer> f1 = User::getAge;

// 위 코드를 동작 기준으로 풀어쓰면 아래 람다와 동일하다 (설명용)
Function<User, Integer> f2 = (User u) -> u.getAge();
```

- 위 두 코드는 **동작 의미가 동일**하다.
- 실제 컴파일 시 `User::getAge`가 자동으로 람다 코드로 치환되는 것은 아니다.
- 컴파일러는 “`Function.apply(User)`가 호출되면 `u.getAge()`를 실행하라”는 **연결 정보**만 기록한다.
- 람다는 동작을 이해하기 쉽게 풀어쓴 **동치 표현(semantic equivalence)** 이다.

#### 핵심 정리
- 메서드 참조(`::`) : *이미 존재하는 메서드를 그대로 연결*
- 람다식(`->`) : *동작 로직을 직접 기술*
- 결과적으로 둘 다 **Function 구현체**가 된다.


```java
Function<User, Integer> f = User::getAge;
```

- 컴파일 시 클래스 생성 없음
- 런타임에 JVM이 객체 생성
- `invokedynamic` 사용
- `this`는 **바깥 클래스 this**

---

## 8. 람다에서의 this (중요)

```java
class Test {
    void run() {
        Function<User, Integer> f = u -> {
            System.out.println(this);
            return u.getAge();
        };
    }
}
```

- 람다는 자기 자신 `this`가 없음
- 항상 **바깥 클래스의 this**
- 익명 클래스와 가장 큰 차이점

---

## 9. comparing vs comparingInt (오토박싱)

### 9.1 comparing (문제점)

```java
users.sort(Comparator.comparing(User::getAge));
```

내부 동작:
```java
Integer k1 = u1.getAge(); // int → Integer
Integer k2 = u2.getAge();
k1.compareTo(k2);
```

- 매 비교마다 Integer 객체 생성
- 오토박싱 발생
- GC 부담 증가

---

### 9.2 comparingInt (권장)

```java
users.sort(Comparator.comparingInt(User::getAge));
```

#### 시그니처
```java
static <T> Comparator<T> comparingInt(ToIntFunction<? super T> keyExtractor)
```

```java
@FunctionalInterface
interface ToIntFunction<T> {
    int applyAsInt(T value);
}
```

#### 내부 동작
```java
int k1 = extractor.applyAsInt(u1);
int k2 = extractor.applyAsInt(u2);
return Integer.compare(k1, k2);
```

- 객체 생성 없음
- 오토박싱 제거
- 성능, 메모리 효율 우수

---

## 10. 언제 무엇을 써야 하나?

| 상황 | 권장 방식 |
|----|----|
| 단순 필드 정렬 | comparingInt / comparing |
| primitive 반환 | comparingInt / comparingLong / comparingDouble |
| 복잡한 조건 | 직접 람다 |
| 키 비교 방식 변경 | comparing + Comparator |
| 성능 중요 | primitive Comparator |

---

## 11. 핵심 요약

- `sort()`는 Comparator만 받는다
- `comparing()`은 Function을 받아 Comparator를 만든다
- 메서드 참조는 Function으로 해석된다
- 람다는 새로운 `this`를 만들지 않는다
- `comparingInt`는 오토박싱을 제거해 더 효율적이다

---

## 12. 면접 한 줄 요약

`Comparator.comparing`은 객체에서 키를 추출하는 Function을 받아 Comparator를 생성하며,
메서드 참조는 해당 Function의 구현으로 해석된다.
primitive 타입의 경우 `comparingInt`를 사용하면 오토박싱을 제거할 수 있다.
