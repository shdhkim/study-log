# Java `sort`에서 람다(화살표) vs 메서드 참조(`::`) 차이와 컴파일/런타임 동작 정리

## 0. 결론 요약 
- **람다식**과 **메서드 참조**는 둘 다 “함수형 인터페이스 구현체”를 만들기 위한 문법이다.
- `List.sort(...)`는 **Comparator**를 받는다. `::`는 Comparator가 아니라 보통 **Function/ToIntFunction** 같은 “키 추출 함수”로 해석되고, `Comparator.comparing*()`이 그것을 받아 **Comparator를 생성**한다.
- 컴파일 시점에는 둘 다 보통 **새 `.class` 파일(익명 클래스)을 만들지 않고**, 바이트코드에 **`invokedynamic` 호출점**과 “어떤 메서드를 연결할지” 메타데이터를 남긴다.
- 런타임에 JVM이 해당 호출점에서 **함수 객체(람다 객체)**를 만들어 연결한다. (캡처 유무에 따라 생성/재사용 특성이 달라진다.)

---

## 1. `.sort()`가 실제로 요구하는 것
```java
users.sort(Comparator<User> c);
```

`Comparator`는 다음의 단 하나의 추상 메서드를 가진 함수형 인터페이스이다.

```java
@FunctionalInterface
public interface Comparator<T> {
    int compare(T o1, T o2);
}
```

따라서 `.sort(...)`에 들어가는 최종 인자는 **반드시 Comparator 구현체**여야 한다.

---

## 2. 람다식(화살표)로 `.sort()`에 바로 Comparator 전달

### 2.1 코드
```java
users.sort((a, b) -> Integer.compare(a.getAge(), b.getAge()));
```

### 2.2 의미(동작)
- `(a, b) -> ...` 는 **Comparator<User>** 자리에 들어가므로
- 컴파일러는 이를 `compare(User, User) -> int` 구현으로 해석한다.

### 2.3 개념적으로 풀어쓴 형태(설명용)
```java
Comparator<User> c = (u1, u2) -> Integer.compare(u1.getAge(), u2.getAge());
users.sort(c);
```

### 2.4 컴파일 시점(중요)
- Java 8+ 일반적인 구현에서 람다는 **익명 클래스(`new Comparator(){...}`)를 생성하지 않는다.**
- 대신 바이트코드에 `invokedynamic` 호출점을 남기고, 런타임에 JVM이 람다 객체를 만든다.
- 즉 “소스가 익명 클래스로 바뀐다”가 아니라, **동적으로 연결되는 형태**로 컴파일된다.

---

## 3. 메서드 참조(`::`)가 `.sort()`에 직접 못 들어가는 이유

### 3.1 잘못된 예(컴파일 에러)
```java
users.sort(User::getAge); // 컴파일 에러
```

### 3.2 이유
- `User::getAge`는 보통 `Function<User, Integer>` 또는 `ToIntFunction<User>` 같은 **키 추출 함수**로 해석된다.
- 하지만 `.sort()`는 **Comparator<User>**를 요구한다.
- 즉 타입이 맞지 않는다.

---

## 4. `Comparator.comparing(...)`에서 `::`가 쓰이는 구조

### 4.1 대표 코드
```java
users.sort(Comparator.comparing(User::getAge));
```

### 4.2 comparing의 시그니처
```java
static <T, U extends Comparable<? super U>>
Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor)
```

즉 `comparing(...)`은 **Function(키 추출기)** 를 받아서 **Comparator**를 만들어서 반환한다.

### 4.3 여기서 `User::getAge`의 타깃 타입(Target Type)
`comparing(...)`의 인자 자리는 `Function<? super User, ? extends Integer>` 이다.

따라서 컴파일러는 다음처럼 해석한다.
```java
Function<User, Integer> f = User::getAge;
```

그리고 동작을 설명하기 위해 흔히 다음 동치 표현을 사용한다(설명용).
```java
(User u) -> u.getAge()
```

중요: 위 람다는 “실제 소스 변환 결과”가 아니라 **동작 동치(semantic equivalence)** 설명이다.

### 4.4 comparing이 Comparator를 만드는 방식(개념 코드)
```java
public static <T, U extends Comparable<? super U>>
Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor) {

    return (o1, o2) -> {
        U k1 = keyExtractor.apply(o1);
        U k2 = keyExtractor.apply(o2);
        return k1.compareTo(k2);
    };
}
```

정리:
- `User::getAge` → (타깃 타입) `Function<User,Integer>`
- `comparing(Function)` → `Comparator<User>` 생성
- `sort(Comparator)` → 정렬

---

## 5. `comparing(keyExtractor, keyComparator)`도 가능하다 (키 추출 + 키 비교 방식 지정)

### 5.1 오버로드 시그니처
```java
static <T, U>
Comparator<T> comparing(
    Function<? super T, ? extends U> keyExtractor,
    Comparator<? super U> keyComparator
)
```

### 5.2 예시: 나이 내림차순
```java
users.sort(
    Comparator.comparing(User::getAge, Comparator.reverseOrder())
);
```

의미:
- 키 추출: `User::getAge`
- 키 비교기: `Comparator.reverseOrder()`
- 최종적으로 Comparator를 만들어 `.sort()`에 전달

---

## 6. 컴파일 시점 관점: 람다 vs `::`의 차이

### 6.1 공통점
- 둘 다 대개 컴파일 시 **별도의 익명 클래스 파일을 생성하지 않고**,
- 바이트코드에 `invokedynamic` + 메타데이터를 남긴 뒤,
- 런타임에 JVM이 함수 객체를 만들어 연결한다.

### 6.2 차이점(핵심)
- **람다식**: “여기서 이 로직을 수행하라”를 직접 기술
  - `(a, b) -> Integer.compare(a.getAge(), b.getAge())`
- **메서드 참조**: “이미 존재하는 메서드를 그대로 연결하라”를 지시
  - `User::getAge` 같은 형태
- 즉 `::`는 **직접 로직을 작성할 수 없고**, 단일 메서드 호출 형태로만 연결 가능하다.
  - `u -> u.getAge() + 1` 같은 가공은 `::`로 표현 불가

---

## 7. 런타임 관점: 객체가 몇 개 만들어지나?

### 7.1 직접 Comparator 람다(보통 1개)
```java
users.sort((a, b) -> Integer.compare(a.getAge(), b.getAge()));
```
- Comparator 람다 객체 1개 (일반적으로)

### 7.2 comparing + method reference(보통 2개)
```java
users.sort(Comparator.comparing(User::getAge));
```
일반적인 구조:
1) `Function<User,Integer>` (키 추출기) 람다 객체  
2) `Comparator<User>` (comparing이 만든 비교기) 람다 객체

주의:
- JIT 최적화에 따라 “실제 생성/재사용”은 달라질 수 있다.
- 캡처(바깥 변수 참조)가 없으면 재사용 가능성이 커진다.

---

## 8. 람다/메서드 참조 vs 익명 클래스(`new ... {}`) 차이 (컴파일/스코프)

### 8.1 익명 클래스 예
```java
Comparator<User> c = new Comparator<>() {
    @Override
    public int compare(User a, User b) {
        return Integer.compare(a.getAge(), b.getAge());
    }
};
```

특징:
- 컴파일 시 **별도의 클래스(예: Outer$1.class)** 생성 가능
- 익명 클래스 내부의 `this`는 **익명 클래스 인스턴스 자신**

### 8.2 람다 예
```java
Comparator<User> c = (a, b) -> Integer.compare(a.getAge(), b.getAge());
```

특징:
- 보통 `invokedynamic` 기반으로 연결(별도 클래스 파일을 직접 만들지 않는 방식)
- 람다 내부의 `this`는 **바깥 클래스의 this** (람다는 새로운 this 스코프를 만들지 않음)

---

## 9. `comparingInt(User::getAge)`가 더 좋은 이유 (오토박싱 제거)

### 9.1 `comparing(User::getAge)`의 문제: 오토박싱
```java
users.sort(Comparator.comparing(User::getAge));
```

`getAge()`가 `int`를 반환하더라도 `comparing`은 `Function<User, Integer>`를 쓰는 형태가 되기 쉬워서
- `int` → `Integer`로 **박싱**이 발생할 수 있다.
- 정렬은 비교를 많이 수행하므로, 박싱/객체 생성이 누적되면 비용이 커질 수 있다.

### 9.2 primitive 전용: comparingInt
```java
users.sort(Comparator.comparingInt(User::getAge));
```

시그니처(핵심):
```java
static <T> Comparator<T> comparingInt(ToIntFunction<? super T> keyExtractor)
```

`ToIntFunction`:
```java
@FunctionalInterface
public interface ToIntFunction<T> {
    int applyAsInt(T value);
}
```

효과:
- 키 추출이 `int`로 유지됨
- `Integer` 객체 생성이 줄어듦(오토박싱 제거)
- 성능/GC 부담 측면에서 유리

---

## 10. 실전 선택 가이드

### 10.1 가장 추천되는 패턴
- primitive 키(int/long/double): `comparingInt / comparingLong / comparingDouble`
```java
users.sort(Comparator.comparingInt(User::getAge));
```

### 10.2 키가 Comparable이고 단순하면
```java
users.sort(Comparator.comparing(User::getName));
```

### 10.3 복잡한 비교 조건이면 직접 Comparator 람다
```java
users.sort((a, b) -> {
    if (a.isVip() && !b.isVip()) return -1;
    if (!a.isVip() && b.isVip()) return 1;
    return Integer.compare(a.getAge(), b.getAge());
});
```

### 10.4 키 비교 방식까지 지정해야 하면 comparing 2인자 오버로드
```java
users.sort(Comparator.comparing(User::getName, String.CASE_INSENSITIVE_ORDER));
```

---

## 11. 한 줄 요약
- `.sort()`는 Comparator만 받는다.
- 람다/메서드 참조는 함수형 인터페이스 구현체를 만들기 위한 문법이며, 보통 `invokedynamic` 기반으로 런타임에 연결된다.
- `Comparator.comparing*()`은 키 추출기(Function/ToIntFunction)를 받아 Comparator를 생성한다.
- primitive 키는 `comparingInt/Long/Double`을 써서 오토박싱을 줄이는 것이 유리하다.
