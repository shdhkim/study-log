
# Java Comparator · Lambda · Method Reference 정리

## 1. Comparator.sort 기본 구조

```java
users.sort(Comparator<User>);
```

- `sort()`는 Comparator 인터페이스를 요구
- Comparator는 두 객체를 비교해 정렬 순서를 결정

```java
@FunctionalInterface
public interface Comparator<T> {
    int compare(T o1, T o2);
}
```

---

## 2. 람다식으로 Comparator 구현

```java
users.sort((a, b) -> Integer.compare(a.getAge(), b.getAge()));
```

### 특징
- Comparator를 직접 구현
- 비교 로직을 자유롭게 작성 가능
- 중간 단계 없음

---

## 3. Comparator.comparing 구조

### 3.1 기본 comparing (키 추출만)

```java
users.sort(Comparator.comparing(User::getAge));
```

```java
static <T, U extends Comparable<? super U>>
Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor)
```

- 객체에서 정렬 기준 키 추출
- 키는 Comparable이어야 함

---

### 3.2 comparing + 키 비교기

```java
users.sort(
    Comparator.comparing(
        User::getAge,
        Comparator.reverseOrder()
    )
);
```

```java
static <T, U>
Comparator<T> comparing(
    Function<? super T, ? extends U> keyExtractor,
    Comparator<? super U> keyComparator
)
```

- 키 추출 + 키 비교 방식 지정

---

## 4. Function과 Comparator의 관계

```java
users.sort(Comparator.comparing(User::getAge));
```

### 동작 흐름
1. `User::getAge` → `Function<User, Integer>`
2. `comparing()`이 Function으로 Comparator 생성
3. `sort()`는 Comparator만 사용

---

## 5. 메서드 참조와 람다의 관계

```java
User::getAge
```

동치 표현:

```java
(User u) -> u.getAge()
```

- 실제 변환이 아니라 동작 설명용 표현

---

## 6. Function은 함수가 아니라 인터페이스

```java
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}
```

```java
Function<User, Integer> f = User::getAge;
```

---

## 7. 람다/메서드 참조 vs 익명 클래스

### 익명 클래스

```java
Function<User, Integer> f = new Function<>() {
    @Override
    public Integer apply(User u) {
        return u.getAge();
    }
};
```

- 컴파일 시 클래스 생성
- `this`는 익명 클래스 인스턴스

### 람다 / 메서드 참조

```java
Function<User, Integer> f = User::getAge;
```

- 컴파일 시 클래스 생성 없음
- 런타임에 JVM이 객체 생성
- `this`는 바깥 클래스 this

---

## 8. 람다에서의 this

```java
class Test {
    void run() {
        Function<User, Integer> f = u -> {
            System.out.println(this);
            return u.getAge();
        };
    }
}
```

- 람다는 새로운 this를 만들지 않음
- 항상 바깥 클래스 this

---

## 9. comparing vs comparingInt (오토박싱)

### comparing

```java
users.sort(Comparator.comparing(User::getAge));
```

- Integer 객체 생성
- 오토박싱 발생

### comparingInt

```java
users.sort(Comparator.comparingInt(User::getAge));
```

```java
@FunctionalInterface
interface ToIntFunction<T> {
    int applyAsInt(T value);
}
```

- primitive int 사용
- 오토박싱 제거

---

## 10. 사용 기준

| 상황 | 권장 방식 |
|----|----|
| primitive 반환 | comparingInt |
| 단순 필드 | comparing |
| 복잡한 조건 | 직접 람다 |
| 성능 중요 | primitive Comparator |

---

## 11. 핵심 요약

- sort는 Comparator만 받음
- comparing은 Function을 받아 Comparator 생성
- 메서드 참조는 Function으로 해석
- 람다는 바깥 클래스 this 사용
- comparingInt는 오토박싱 제거

---

## 12. 면접 한 줄 요약

Comparator.comparing은 키 추출 Function을 받아 Comparator를 생성하며,
primitive 타입은 comparingInt를 사용해 오토박싱을 제거한다.
