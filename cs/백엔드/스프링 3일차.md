
# JPA `cascade` / `orphanRemoval` & 복합키(Composite Key)

> `cascade`, `orphanRemoval`, 그리고 **복합키 매핑**을 정리합니다.  
> 예제는 모두 **Cart(부모)**–**Item(자식)** (1:N) 과 **JobRole–JobRoleKeyword–Keyword** (N:M을 조인 엔티티로 푼 구조)를 사용합니다.

---

요약

- **연관관계 주인(owner)**: **FK(외래키)를 가진 쪽(자식)** → 관계 변경(INSERT/UPDATE)은 **자식 변경**으로 결정됨.
- **`cascade`**: “부모에 한 **영속성 연산**을 자식에게 **전파**”. 관계(FK) 값을 자동으로 맞추지는 **않음**.
- **`orphanRemoval`**: “부모와 **연결이 끊긴 자식**을 **행 자체 DELETE**”.
- **복합키**:
  - **권장**: `@EmbeddedId + @MapsId` — 중복 매핑 없음, 연관만 세팅해도 ID 채워짐.
  - 대안: `@IdClass` — 단순하지만 컬럼 중복 쓰기 주의(연관은 읽기 전용으로 두는 패턴).

---

## 1) 1:N — `cascade` / `orphanRemoval`을 가장 쉽게 이해하기

### 1.1 엔티티 (Cart–Item)

```java
// 부모
@Entity
class Cart {
  @Id @GeneratedValue Long id;

  @OneToMany(mappedBy = "cart",
             cascade = CascadeType.ALL,
             orphanRemoval = true)
  private List<Item> items = new ArrayList<>();

  // 편의 메서드(양쪽 동기화)
  public void addItem(Item i){ items.add(i); i.setCart(this); }
  public void removeItem(Item i){ items.remove(i); i.setCart(null); }
}

// 자식 (FK 보유 = 연관관계 주인)
@Entity
class Item {
  @Id @GeneratedValue Long id;
  @Column(nullable = false) String name;

  @ManyToOne(fetch = FetchType.LAZY, optional = false)
  @JoinColumn(name = "cart_id", nullable = false)
  private Cart cart;

  public void setCart(Cart cart){ this.cart = cart; }
}
```

> 핵심: **DB에 실제로 반영되는 쪽은 자식(Item)의 `setCart(...)`(FK 보유자)**.  
> 부모 컬렉션만 만져서는 DB가 바뀌지 않음 → **편의 메서드로 항상 양쪽을 동시에** 맞추자.

### 1.2 상황별 동작 & SQL

#### A) 부모 저장 시 자식도 함께 INSERT — `cascade=PERSIST`
```java
Cart c = new Cart();
Item a = new Item(); a.setName("Keyboard");
Item b = new Item(); b.setName("Mouse");

c.addItem(a); // 내부에서 a.setCart(c)
c.addItem(b);

cartRepo.save(c); // 부모 저장 → 자식도 INSERT 전파
```
**SQL(예시)**
```sql
INSERT INTO cart (id) VALUES (1);
INSERT INTO item (name, cart_id, id) VALUES ('Keyboard', 1, 10);
INSERT INTO item (name, cart_id, id) VALUES ('Mouse', 1, 11);
```

#### B) 부모 삭제 시 자식도 모두 삭제 — `cascade=REMOVE`
```java
Cart c = cartRepo.findById(1L).orElseThrow();
cartRepo.delete(c);
```
**SQL**
```sql
DELETE FROM item WHERE cart_id = 1; -- 자식 먼저
DELETE FROM cart WHERE id = 1;      -- 부모 다음
```

#### C) 컬렉션에서 자식을 빼면 그 자식 행을 삭제 — `orphanRemoval=true`
```java
Cart c = cartRepo.findById(1L).orElseThrow();
Item i = c.getItems().get(0);

c.removeItem(i); // 내부에서 i.setCart(null)
```
**SQL**
```sql
DELETE FROM item WHERE id = ?;
```
- `orphanRemoval=false`라면 위 코드는 **DB 변화 없음**(컬렉션만 빠짐).

#### D) 자식을 “다른 부모로 이동” — FK **UPDATE** (삭제 아님)
```java
Item i = itemRepo.findById(10L).orElseThrow();
Cart to = cartRepo.findById(2L).orElseThrow();
Cart from = i.getCart();

i.setCart(to);              // ★ 주인(자식) 변경 → FK UPDATE 근거
from.getItems().remove(i);  // 메모리 동기화
to.getItems().add(i);       // 메모리 동기화
```
**SQL**
```sql
UPDATE item SET cart_id = 2 WHERE id = 10;
```

### 1.3 3줄 표 비교: 삭제 전파 vs 고아 삭제

| 구분 | 트리거(방아쇠) | 삭제 대상 | 필요 설정 | 대표 코드 |
|---|---|---|---|---|
| **삭제 전파** | **부모 삭제** | 그 부모의 **모든 자식** | `cascade=REMOVE`(또는 `ALL`) | `cartRepo.delete(cart)` |
| **고아 삭제** | **연결 해제**(컬렉션 remove / `setParent(null)`) | **끊긴 그 자식만** | **`orphanRemoval=true`** | `cart.removeItem(item)` |

> DB `ON DELETE CASCADE`는 **부모 삭제**에만 반응(=삭제 전파 유사).  
> **연결 해제 시 삭제(고아 삭제)** 는 JPA `orphanRemoval`의 개념이라 DB만으로 대체 불가.

---

## 2) 복합키(Composite Key) — 가장 쉬운 2가지 패턴

도메인: **JobRole**–**JobRoleKeyword(중간/자식)**–**Keyword**  
중간 엔티티가 **두 FK**(=두 부모)로 **복합 PK**를 가짐.

### 2.1 권장 패턴: `@EmbeddedId` + `@MapsId`

#### 2.1.1 키 클래스
```java
@Embeddable
public class JobRoleKeywordId implements Serializable {
  @Column(name = "job_role_id") private String jobRoleId;
  @Column(name = "keyword_id")  private Integer keywordId;

  // equals/hashCode 필수 (lombok 사용시 @EqualsAndHashCode)
}
```

#### 2.1.2 엔티티
```java
@Entity
@Table(name = "job_role_keywords")
public class JobRoleKeyword {

  @EmbeddedId
  private JobRoleKeywordId id;

  @ManyToOne(fetch = FetchType.LAZY) @MapsId("jobRoleId")
  @JoinColumn(name = "job_role_id", nullable = false)
  private JobRole jobRole;      // FK1

  @ManyToOne(fetch = FetchType.LAZY) @MapsId("keywordId")
  @JoinColumn(name = "keyword_id", nullable = false)
  private Keyword keyword;      // FK2

  private Boolean selected;
}
```
> **장점**: 중복 매핑이 **없다** → `setJobRole`, `setKeyword`만 해도 `id`가 알아서 맞춰짐.

#### 2.1.3 저장/조회 예시
```java
JobRole jr = jobRoleRepo.getReferenceById("DEV");
Keyword kw = keywordRepo.getReferenceById(101);

JobRoleKeyword e = new JobRoleKeyword();
e.setJobRole(jr);   // @MapsId 가 e.id.jobRoleId 를 채움
e.setKeyword(kw);   // @MapsId 가 e.id.keywordId 를 채움
e.setSelected(true);

repo.save(e);       // INSERT (DEV, 101)
```
**PK 변경(예: 101→102)** 은 **삭제 후 삽입**이 안전(식별자 변경 비권장).

```java
// 변경 대신
repo.deleteById(new JobRoleKeywordId("DEV", 101));
JobRoleKeyword neo = new JobRoleKeyword();
neo.setJobRole(jr);
neo.setKeyword(keywordRepo.getReferenceById(102));
neo.setSelected(true);
repo.save(neo);
```

### 2.2 대안: `@IdClass` + **원시 FK 필드로만 쓰기**(연관은 조회 전용)

#### 2.2.1 키 클래스
```java
public class JobRoleKeywordId implements Serializable {
  private String jobRoleId;
  private Integer keywordId;

  // equals/hashCode 필수
}
```

#### 2.2.2 엔티티
```java
@Entity
@IdClass(JobRoleKeywordId.class)
@Table(name = "job_role_keywords")
public class JobRoleKeyword {

  @Id @Column(name = "job_role_id") private String jobRoleId;
  @Id @Column(name = "keyword_id")  private Integer keywordId;

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "job_role_id", insertable = false, updatable = false)
  private JobRole jobRole;   // 조회 전용 (중복 쓰기 방지)

  @ManyToOne(fetch = FetchType.LAZY)
  @JoinColumn(name = "keyword_id", insertable = false, updatable = false)
  private Keyword keyword;   // 조회 전용

  private Boolean selected;
}
```
> **왜 연관은 조회 전용?** 같은 컬럼을 값 필드와 연관 필드가 **동시에 쓰기**로 매핑하면 **중복 쓰기 매핑 에러**.  
> 저장/수정은 **항상 `jobRoleId`, `keywordId`** 로! 연관은 조회 편의용.

#### 2.2.3 저장/조회 예시
```java
JobRoleKeyword e = new JobRoleKeyword();
e.setJobRoleId("DEV");  // 진짜 쓰기 주체
e.setKeywordId(101);
e.setSelected(true);
repo.save(e);           // INSERT (DEV, 101)

// 조회
JobRoleKeywordId id = new JobRoleKeywordId("DEV", 101);
JobRoleKeyword found = repo.findById(id).orElseThrow();

// 연관 접근(지연로딩) — 필요할 때만
String roleName = found.getJobRole().getName();
```

---

## 3) 실무 체크리스트

- [ ] **주인(자식)** 만 바꿔야 FK가 DB에 반영된다. (부모 컬렉션은 비주인/뷰)
- [ ] `cascade`는 **연산 전파**일 뿐, **관계값 추론 X** → 자식 `setParent(...)` 필수
- [ ] `orphanRemoval=true`면 **끊긴 자식은 DELETE**, 이동은 **FK UPDATE**
- [ ] 복합키는 **`@EmbeddedId + @MapsId` 권장**, `@IdClass`는 연관을 읽기 전용으로
- [ ] N+1 방지: LAZY + `join fetch`/`@EntityGraph`/`@BatchSize`
- [ ] DTO 갱신은 **diff 기반**으로 add/remove/update만 적용(고아삭제 오작동 방지)
- [ ] FK 컬럼 **인덱스** 필수, 예약어/테이블명 주의(`like` 등)

---

## 4) 부록 — 간단 SQL 스키마 예시(MySQL 느낌)

```sql
CREATE TABLE job_role (
  id VARCHAR(20) PRIMARY KEY
);

CREATE TABLE keyword (
  id INT PRIMARY KEY,
  name VARCHAR(100) NOT NULL
);

CREATE TABLE job_role_keywords (
  job_role_id VARCHAR(20) NOT NULL,
  keyword_id  INT NOT NULL,
  selected    BOOLEAN NOT NULL,
  PRIMARY KEY (job_role_id, keyword_id),
  CONSTRAINT fk_jrk_jobrole FOREIGN KEY (job_role_id) REFERENCES job_role(id),
  CONSTRAINT fk_jrk_keyword  FOREIGN KEY (keyword_id)  REFERENCES keyword(id)
);

CREATE TABLE cart (
  id BIGINT PRIMARY KEY AUTO_INCREMENT
);

CREATE TABLE item (
  id BIGINT PRIMARY KEY AUTO_INCREMENT,
  name VARCHAR(100) NOT NULL,
  cart_id BIGINT NOT NULL,
  CONSTRAINT fk_item_cart FOREIGN KEY (cart_id) REFERENCES cart(id),
  INDEX idx_item_cart_id (cart_id)
);
```

---

