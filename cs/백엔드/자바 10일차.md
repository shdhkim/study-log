# Stream.sorted / 람다 / Comparator.comparing 관계 정리

## 1. 핵심 결론 요약

- `Stream.sorted()`는 **Comparator만** 사용한다
- `Function`은 **정렬 기준(key)을 추출**하는 역할만 한다
- **비교는 항상 Comparator가 수행**한다
- 람다(애로우)와 `Comparator.comparing()`의 차이는
  - Comparator를 **직접 구현하느냐**
  - Function을 받아 **Comparator를 생성하느냐**의 차이다
- Function 타입을 **추론하는 주체는 comparing이 아니라 컴파일러**다

---

## 2. sorted의 실제 시그니처

```java
Stream<T> sorted(Comparator<? super T> comparator)
```

- `sorted`는 Function을 받지 않는다
- 반드시 Comparator가 필요하다

---

## 3. 애로우(람다)를 사용한 sorted

```java
stream.sorted((u1, u2) -> Integer.compare(u1.getAge(), u2.getAge()));
```

### 이 람다의 정체

```java
Comparator<User> comparator =
    (User u1, User u2) -> Integer.compare(u1.getAge(), u2.getAge());
```

- 이 람다는 **Comparator의 compare 메서드 구현체**
- Function을 따로 정의하지 않았을 뿐
- 내부에 key 추출 로직이 섞여 있음

---

## 4. Comparator.comparing 사용

```java
stream.sorted(Comparator.comparing(User::getAge));
```

### comparing 메서드 시그니처

```java
static <T, U extends Comparable<? super U>>
Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor)
```

### 내부 구조 (개념적)

```java
Function<User, Integer> keyExtractor = u -> u.getAge();

Comparator<User> comparator =
    (u1, u2) -> keyExtractor.apply(u1).compareTo(keyExtractor.apply(u2));
```

---

## 5. Function을 추론하는 주체

- `User::getAge`를 Function으로 해석하는 주체는 **컴파일러**
- comparing은 Function을 **요구만** 할 뿐, 추론하지 않는다

---

## 6. 애로우 vs comparing 비교

| 구분 | 애로우 Comparator | Comparator.comparing |
|----|----|----|
| 구현 대상 | Comparator 직접 구현 | Function → Comparator |
| Function 분리 | 없음 | 있음 |
| 안정성 | 보통 | 높음 |
| 가독성 | 보통 | 높음 |

---

## 7. 정확한 문장 정리

- 애로우는 **Comparator를 직접 구현**
- comparing은 **Function을 받아 Comparator 생성**
- Function 타입 추론은 **컴파일러 책임**

---

## 8. 가장 중요한 문장

람다는 그 자체로 Function이나 Comparator가 아니다.  
**타깃 타입에 따라 의미가 결정된다.**

---

## 9. 실무 권장 패턴

```java
stream.sorted(Comparator.comparingInt(User::getAge));
```

- 오버플로우 없음
- 오토박싱 없음
- 가장 안전한 방식
