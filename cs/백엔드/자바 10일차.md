# Stream.sorted / 람다 / Comparator.comparing 관계 정리 

## 1. 핵심 결론 요약

- `Stream.sorted()`는 **Comparator만** 사용한다
- `Function`은 **정렬 기준(key)을 추출**하는 역할만 한다
- **비교는 항상 Comparator가 수행**한다
- 람다(애로우)와 `Comparator.comparing()`의 차이는
  - Comparator를 **직접 구현하느냐**
  - Function을 받아 **Comparator를 생성하느냐**의 차이다
- Function 타입을 **추론하는 주체는 comparing이 아니라 컴파일러**다
- 람다는 그 자체로 타입을 가지지 않으며 **타깃 타입에 의해 의미가 결정된다**

---

## 2. sorted의 실제 시그니처

```java
Stream<T> sorted(Comparator<? super T> comparator)
```

- `sorted`는 Function을 받지 않는다
- 반드시 Comparator가 필요하다

---

## 3. 애로우(람다)를 사용한 sorted

```java
stream.sorted((u1, u2) -> Integer.compare(u1.getAge(), u2.getAge()));
```

### 이 람다의 정체

```java
Comparator<User> comparator =
    (User u1, User u2) -> Integer.compare(u1.getAge(), u2.getAge());
```

- 이 람다는 **Comparator의 compare 메서드 구현체**
- Function을 따로 정의하지 않았을 뿐
- 내부에 key 추출 로직과 비교 로직이 **함께 섞여 있음**

### 내부 동작을 단계별로 풀면

```java
int k1 = u1.getAge(); // key 추출 (Function 역할)
int k2 = u2.getAge(); // key 추출 (Function 역할)
return Integer.compare(k1, k2); // 비교 (Comparator 역할)
```

- 개념적으로는 Function + Comparator 구조
- 구현상으로는 Comparator 하나에 합쳐진 형태

---

## 4. Comparator.comparing 사용

```java
stream.sorted(Comparator.comparing(User::getAge));
```

### comparing 메서드 시그니처

```java
static <T, U extends Comparable<? super U>>
Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor)
```

### 내부 구조 (개념적)

```java
Function<User, Integer> keyExtractor = u -> u.getAge();

Comparator<User> comparator =
    (u1, u2) -> keyExtractor.apply(u1).compareTo(keyExtractor.apply(u2));
```

- key 추출(Function)
- 비교(Comparator)
- 역할이 명확히 분리됨

---

## 5. Function을 추론하는 주체

```java
User::getAge
u -> u.getAge()
```

이 표현들이 Function으로 해석되는 이유:

- comparing이 Function을 요구하는 위치이기 때문
- **Function으로 해석하는 주체는 컴파일러**
- comparing은 Function을 요구만 할 뿐, 추론 로직을 가지지 않는다

---

## 6. 왜 `u -> u.getAge()`는 Function인가

### Function 인터페이스

```java
@FunctionalInterface
public interface Function<T, R> {
    R apply(T t);
}
```

### 람다 형태 비교

```java
u -> u.getAge();              // (T) -> R
(u1, u2) -> ...               // (T, T) -> int
```

- `u -> u.getAge()`
  - 매개변수 1개
  - 반환값 존재
  - `(T) -> R` 형태
  - **Function과 시그니처 일치**

### Function이 되는 조건

```java
Function<User, Integer> f = u -> u.getAge();
Comparator.comparing(u -> u.getAge());
```

- Function을 요구하는 자리에 놓였을 때
- 그 순간 컴파일러가 Function으로 해석

---

## 7. 왜 sorted에는 `u -> u.getAge()`를 못 쓰는가

```java
stream.sorted(u -> u.getAge()); // 컴파일 에러
```

이유:

- sorted는 Comparator를 요구
- Comparator는 `(T, T) -> int`
- `u -> u.getAge()`는 `(T) -> R`
- 시그니처가 다르므로 불가능

---

## 8. 애로우 Comparator vs Comparator.comparing 비교

| 구분 | 애로우 Comparator | Comparator.comparing |
|----|----|----|
| 구현 대상 | Comparator 직접 구현 | Function → Comparator |
| Function 분리 | 없음 | 있음 |
| 안정성 | 보통 | 높음 |
| 가독성 | 보통 | 높음 |
| 확장성 | 낮음 | 높음 |
| 실무 권장 | 제한적 | 적극 권장 |

---

## 9. 정확한 문장 정리

- 애로우는 **Comparator의 compare 메서드를 직접 구현**
- comparing은 **Function을 받아 Comparator를 생성**
- Function 타입 추론은 **컴파일러 책임**
- 람다는 **타깃 타입 없이는 의미를 가지지 않는다**

---

## 10. 가장 중요한 문장

람다는 그 자체로 Function이나 Comparator가 아니다.  
**어떤 함수형 인터페이스 자리에 놓이느냐에 따라 의미가 결정된다.**

---

## 11. 실무 권장 패턴

```java
stream.sorted(Comparator.comparingInt(User::getAge));
```

- 오버플로우 없음
- 오토박싱 없음
- 가장 안전하고 명확한 방식
