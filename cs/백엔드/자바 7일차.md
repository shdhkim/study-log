# equals / hashCode를 오버라이딩하지 않으면 왜 문제가 되는가 

이 문서는 다음 질문에 대한 답을 중심으로 정리한다.

- equals / hashCode를 오버라이딩하지 않으면 무엇을 기준으로 비교되는가
- 왜 값 객체(Value Object)에서 문제가 되는가
- HashMap / HashSet에서 왜 치명적인 버그로 이어지는가
- 자바가 기본 구현을 이렇게 설계한 이유
- 왜 오버라이딩은 선택이 아니라 설계 선언인가

---

## 1. 오버라이딩하지 않으면 무엇을 사용하나?

### 1.1 equals() 기본 구현

```java
public boolean equals(Object obj) {
    return this == obj;
}
```

- 객체의 **주소(참조)** 비교
- 같은 객체(같은 메모리)만 true
- 값이 같아도 객체가 다르면 false

---

### 1.2 hashCode() 기본 구현

```java
public native int hashCode();
```

- 객체의 **정체성(identity)** 기반 값
- JVM이 객체를 구분하기 위해 사용하는 값
- 값 내용과는 무관

즉, 기본 구현의 의미는 다음과 같다.

> “이 객체는 누구인가?”는 알지만  
> “이 객체의 값이 같은가?”는 판단하지 않는다.

---

## 2. 왜 항상 문제는 아닌가?

기본 equals/hashCode는 **객체 정체성(identity)** 기준이므로  
다음과 같은 경우에는 오히려 올바르다.

```java
Thread t1 = new Thread();
Thread t2 = new Thread();

t1.equals(t2); // false (정상)
```

- Thread는 값 객체가 아님
- 서로 다른 객체는 의미적으로도 다름

즉, **정체성 객체(Entity-like object)** 에서는 문제가 없다.

---

## 3. 언제 문제가 터지는가? (값 객체)

```java
User u1 = new User("kim", 27);
User u2 = new User("kim", 27);
```

사람 기준:
- 같은 값

기본 equals 기준:
- 다른 객체 → 다름

```java
u1.equals(u2); // false
```

여기서부터 **의도와 코드의 판단 기준이 어긋난다**.

---

## 4. HashMap / HashSet에서 치명적인 이유

HashMap / HashSet은 다음을 전제로 동작한다.

> “같다고 정의된 객체는  
> 같은 hashCode를 가질 것이다.”

하지만 기본 구현은:
- equals → 주소 비교
- hashCode → identity 기반

결과:

```java
Set<User> set = new HashSet<>();
set.add(new User("kim", 27));
set.add(new User("kim", 27));

set.size(); // 2
```

개발자 의도:
- 중복 제거

실제 결과:
- 중복 허용

이것은 **컴파일 에러도, 런타임 에러도 아닌 조용한 논리 버그**다.

---

## 5. 왜 equals만 오버라이딩해도 안 되는가?

```java
@Override
public boolean equals(Object o) {
    return true;
}
```

- equals는 값 기준
- hashCode는 여전히 identity 기반

HashMap은:
1. hashCode로 버킷 선택
2. 같은 버킷 안에서만 equals 비교

따라서:
- hashCode가 다르면 equals는 호출되지 않을 수도 있다
- 논리적으로 같아도 찾지 못하는 상황 발생

그래서 규약이 강제된다.

> **equals가 true이면 hashCode는 반드시 같아야 한다**

---

## 6. 자바는 왜 기본 구현을 이렇게 두었는가?

자바 언어는 다음을 알 수 없다.

- 어떤 클래스가 값 객체인지
- 어떤 필드가 비교 대상인지
- 어떤 기준이 “같음”인지

그래서 자바의 선택은:

- 기본값 = 가장 안전한 기준 (객체 정체성)
- 의미 부여 = 개발자 책임

즉,

> **자바는 임의로 값 비교를 강제하지 않는다.**

---

## 7. 오버라이딩은 “선택”이 아니라 “설계 선언”

```java
class Money {
    int amount;
    String currency;
}
```

이 클래스에서 equals/hashCode를:

- 오버라이딩하지 않으면  
  → “이 객체는 정체성으로 비교한다”는 선언
- 오버라이딩하면  
  → “이 객체는 값으로 비교한다”는 선언

즉,

> **equals/hashCode 오버라이딩 여부 = 이 객체의 정체성 정의**

---

## 8. 한 문장 정리 

> equals와 hashCode를 오버라이딩하지 않으면  
> Object의 기본 구현이 사용되어 객체의 정체성 기준으로 비교되며,  
> 값 객체나 해시 컬렉션의 키로 사용할 경우  
> 의도와 다른 결과를 초래할 수 있습니다.

---

## 9. 핵심 요약

- 기본 equals = 주소 비교
- 기본 hashCode = identity 기반
- 값 객체에서는 반드시 오버라이딩 필요
- HashMap/HashSet에서는 안 하면 조용히 망가진다
- 오버라이딩은 문법 문제가 아니라 **설계 의도 선언**이다
