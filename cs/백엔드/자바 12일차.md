# Java Set, String vs StringBuilder, Stream / IntStream 정리 

---

## 1) Java `Set` 핵심 정리

### 1.1 Set의 기본 성질

* 중복 허용 안 함
* 순서 보장 여부는 구현체에 따라 다름
* 중복 판단 기준: `equals()` + `hashCode()`

```java
Set<String> set = new HashSet<>();
set.add("A");
set.add("A");
System.out.println(set.size()); // 1
```

---

### 1.2 주요 구현체 차이

| 구현체           | 중복 | 순서 | 내부 구조             | 특징       |
| ------------- | -- | -- | ----------------- | -------- |
| HashSet       | X  | X  | Hash Table        | 가장 빠름    |
| LinkedHashSet | X  | O  | Hash + LinkedList | 입력 순서 유지 |
| TreeSet       | X  | 정렬 | Red-Black Tree    | 정렬/범위 검색 |

```java
Set<Integer> tree = new TreeSet<>();
tree.add(3);
tree.add(1);
tree.add(2);
System.out.println(tree); // [1, 2, 3]
```

---

### 1.3 equals / hashCode 중요성

```java
class User {
    String name;
    int age;
}
```

* 오버라이딩 안 하면 객체 주소 기준 비교
* Set / Map Key 사용 시 논리적 중복 제거 실패

---

## 2) `String` vs `StringBuilder`

---

### 2.1 String (불변 객체)

```java
String s = "hello";
s.replace('h', 'H');
System.out.println(s); // hello
```

```java
s = s.replace('h', 'H');
System.out.println(s); // Hello
```

* 모든 변경 연산은 **새 객체 반환**

---

### 2.2 StringBuilder (가변 객체)

```java
StringBuilder sb = new StringBuilder("hello");
sb.replace(0, 1, "H");
System.out.println(sb); // Hello
```

* 내부 char 배열 직접 수정
* 반복 수정에 최적

---

### 2.3 `charAt()` 비교

```java
String s = "java";
char c1 = s.charAt(1); // 'a'

StringBuilder sb = new StringBuilder("java");
char c2 = sb.charAt(2); // 'v'
```

* 읽기 전용
* 수정은 `StringBuilder`만 가능

---

### 2.4 `replace()` 차이

```java
String s = "banana";
String r = s.replace('a', 'o');
// s는 그대로 "banana"

StringBuilder sb = new StringBuilder("banana");
sb.replace(1, 3, "OO");
// 결과: bOOnana
```

---

### 2.5 `setCharAt()` (StringBuilder 전용)

```java
StringBuilder sb = new StringBuilder("java");
sb.setCharAt(0, 'J');
System.out.println(sb); // Java
```

---

### 2.6 성능 요약

| 상황           | 추천            |
| ------------ | ------------- |
| 문자열 수정 거의 없음 | String        |
| 반복 수정        | StringBuilder |
| 멀티스레드        | StringBuffer  |

---

## 3) Stream vs IntStream

---

### 3.1 `Stream<Integer>`

```java
List<Integer> list = List.of(1,2,3,4,5);

int sum = list.stream()
    .filter(n -> n % 2 == 0)
    .map(n -> n * 10)
    .reduce(0, Integer::sum);
```

* 박싱 / 언박싱 발생

---

### 3.2 `IntStream.range()`

```java
IntStream.range(1, 6)
         .forEach(System.out::println);
```

---

### 3.3 `IntStream.of()`

```java
IntStream.of(1, 2, 3, 4, 5)
         .sum();
```

* 가장 직관적인 숫자 스트림 생성

---

### 3.4 Stream → IntStream 변환

```java
int sum = list.stream()
    .mapToInt(Integer::intValue)
    .sum();
```

---

### 3.5 `IntSummaryStatistics`

```java
IntSummaryStatistics st =
    IntStream.of(10, 20, 30)
             .summaryStatistics();

int sum = st.getSum();
double avg = st.getAverage();
int max = st.getMax();
int min = st.getMin();
```

* 단일 순회로 통계 계산

---

## 4) Stream vs IntStream 비교

| 구분    | Stream<Integer> | IntStream |
| ----- | --------------- | --------- |
| 타입    | Wrapper         | primitive |
| 박싱    | O               | X         |
| 성능    | 보통              | 빠름        |
| 숫자 연산 | 불편              | 최적        |

---

## 5) 선택 가이드

* 중복 제거 → Set
* 문자열 수정 많음 → StringBuilder
* 숫자 연산 → IntStream
* 컬렉션 숫자 처리 → `mapToInt`
* 인덱스 반복 → `IntStream.range`

---

## 6) 한 줄 요약

* Set: 중복 제거
* String: 불변
* StringBuilder: 가변
* Stream<Integer>: 객체 스트림
* IntStream: 숫자 연산 특화
