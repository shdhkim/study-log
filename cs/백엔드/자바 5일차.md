# Java Object / equals / hashCode / Casting 

이 문서는 다음 내용을 중심으로 정리한다.
- Object 클래스의 의미와 기본 동작
- equals / hashCode를 오버라이딩하지 않았을 때의 기본 구현과 결과
- equals만 또는 hashCode만 오버라이딩했을 때 발생하는 문제
- 업캐스팅/다운캐스팅(컴파일러 vs JVM) 개념과 이유
- 캐스팅과 equals/hashCode의 관계


---

## 1. Object 클래스

### 1.1 Object란?
- `java.lang.Object`는 자바의 모든 클래스의 최상위 부모 클래스다.
- 어떤 클래스를 만들더라도 명시하지 않으면 자동으로 `Object`를 상속한다.

```java
class User { }
// 실제로는
class User extends Object { }
```

### 1.2 Object의 핵심 메서드
- `toString()` : 객체를 문자열로 표현(로그/디버깅)
- `equals(Object)` : 객체의 동등성 비교
- `hashCode()` : 해시 기반 컬렉션의 버킷 결정 기준
- `getClass()` : 런타임 타입 정보
- `wait()/notify()/notifyAll()` : 스레드 동기화
- `clone()` : 객체 복사(현업에서는 거의 사용하지 않음)

---

## 2. equals / hashCode를 오버라이딩하지 않으면 무엇을 쓰는가?

### 2.1 equals() 기본 동작
오버라이딩하지 않으면 `Object.equals()`가 그대로 사용된다.

```java
public boolean equals(Object obj) {
    return this == obj;
}
```

- 주소(참조) 비교
- 같은 객체만 `true`
- 값이 같아도 객체가 다르면 `false`

---

### 2.2 hashCode() 기본 동작
오버라이딩하지 않으면 `Object.hashCode()`가 사용된다.

```java
public native int hashCode();
```

- 객체의 정체성(identity) 기반 값
- 같은 객체는 같은 hashCode
- 다른 객체는 보통 다른 hashCode

핵심:
- 기본 equals가 주소 비교이므로
- 기본 hashCode도 객체 단위 구분에 최적화되어 있다

---

## 3. 기본 구현을 그대로 쓸 때의 실제 결과

```java
class User {
    String name;
    int age;
    User(String name, int age) {
        this.name = name;
        this.age = age;
    }
}

public class Main {
    public static void main(String[] args) {
        User u1 = new User("kim", 27);
        User u2 = new User("kim", 27);

        System.out.println(u1 == u2);        // false
        System.out.println(u1.equals(u2));   // false
        System.out.println(u1.hashCode());
        System.out.println(u2.hashCode());   // 대부분 다름
    }
}
```

사람 눈에는 값이 같아 보이지만,
JVM 기준에서는 서로 다른 객체이므로 같지 않다고 판단한다.

---

## 4. HashMap / HashSet이 equals와 hashCode를 함께 요구하는 이유

### 4.1 내부 동작 순서(개념)
1. `hashCode()`로 버킷 위치 결정
2. 같은 버킷에 충돌이 있으면 `equals()`로 최종 비교

즉, `hashCode → equals` 순서다.

---

### 4.2 equals / hashCode 규약
- `equals`가 `true`이면 `hashCode`는 반드시 같아야 한다
- `hashCode`가 같아도 `equals`가 `true`일 필요는 없다

이 규약을 깨면 해시 컬렉션의 동작이 깨진다.

---

## 5. equals만 오버라이딩했을 때의 문제

```java
class User {
    String name;
    int age;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof User)) return false;
        User u = (User) o;
        return age == u.age && Objects.equals(name, u.name);
    }
    // hashCode는 오버라이딩하지 않음
}
```

```java
Set<User> set = new HashSet<>();
set.add(new User("kim", 27));
set.add(new User("kim", 27));

System.out.println(set.size()); // 2
```

이유:
- equals는 같다고 판단
- hashCode는 여전히 identity 기반 → 서로 다른 버킷
- 중복 제거 실패

---

## 6. hashCode만 오버라이딩했을 때의 문제

```java
class User {
    String name;
    int age;

    @Override
    public int hashCode() {
        return 1;
    }
    // equals는 Object.equals (주소 비교)
}
```

결과:
- 모든 객체가 같은 버킷으로 몰림
- equals는 주소 비교 → 서로 다른 객체
- 기능적으로는 동작하지만 성능과 의미 모두 붕괴

---

## 7. 올바른 equals / hashCode 구현

```java
class User {
    String name;
    int age;

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof User)) return false;
        User u = (User) o;
        return age == u.age && Objects.equals(name, u.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name, age);
    }
}
```

이제 값이 같은 객체는:
- equals → true
- hashCode → 동일
- 해시 컬렉션에서 정상 동작

---

## 8. 실무에서 자주 터지는 케이스: 키 객체 변경

```java
Map<User, String> map = new HashMap<>();
User u = new User("kim", 27);
map.put(u, "DATA");

u.name = "lee"; // 위험
```

- hashCode가 변함
- 기존 버킷을 다시 찾지 못함
- `map.get(u)`가 null이 될 수 있음

권장:
- 키 객체는 불변 객체로 설계
- 또는 변하지 않는 식별자(id)만 사용

---

## 9. 업캐스팅 (Upcasting)

### 9.1 개념
- 자식 객체를 부모 타입으로 참조
- 자동 변환
- 항상 안전

```java
Dog d = new Dog();
Animal a = d;
```

### 9.2 왜 명시 캐스팅이 필요 없는가?
- `Dog is-a Animal` 관계는 컴파일 타임에 100% 보장
- 접근 범위가 줄어들 뿐 위험이 없다
- 컴파일러가 안전성을 완전히 증명 가능

---

## 10. 다운캐스팅 (Downcasting)

### 10.1 개념
- 부모 타입 참조를 자식 타입으로 변환
- 명시적 캐스팅 필요

```java
Animal a = new Dog();
Dog d = (Dog) a;
```

### 10.2 왜 명시해야 하는가?
- 컴파일러는 실제 객체 타입을 알 수 없다
- 런타임에 Dog인지 Cat인지 결정됨
- 명시 캐스팅은 개발자의 책임 선언

---

## 11. JVM 관점에서 다운캐스팅

실행 시 JVM은 다음을 수행한다.
1. 캐스팅 지점 도달
2. 실제 객체 타입 검사
3. 가능하면 통과
4. 불가능하면 `ClassCastException`

```java
Animal a = new Cat();
Dog d = (Dog) a; // 런타임 예외
```

---

## 12. instanceof로 안전하게 다운캐스팅

```java
if (a instanceof Dog) {
    Dog d = (Dog) a;
}
```

- 런타임 타입을 명시적으로 검사
- 예외 없이 안전한 캐스팅 가능

---

## 13. 캐스팅과 equals / hashCode의 관계

### 13.1 캐스팅은 객체를 바꾸지 않는다
- 캐스팅은 참조 타입만 변경
- 같은 객체를 가리키면 hashCode도 동일

```java
Dog d = new Dog();
Animal a = d;

System.out.println(d.hashCode());
System.out.println(a.hashCode()); // 동일
```

### 13.2 다운캐스팅도 성공하면 동일
```java
Animal a = new Dog();
Dog d = (Dog) a;

System.out.println(a.hashCode());
System.out.println(d.hashCode()); // 동일
```

---

## 14. 핵심 요약

- 오버라이딩 안 하면 equals는 주소 비교, hashCode는 identity 기반
- equals만 또는 hashCode만 오버라이딩하면 해시 컬렉션이 깨진다
- equals와 hashCode는 반드시 함께 오버라이딩해야 한다
- 해시 컬렉션의 키 객체는 불변이어야 안전하다
- 업캐스팅은 항상 안전해 자동
- 다운캐스팅은 런타임 위험이 있어 명시 필요
- 명시 캐스팅은 오류 방지가 아니라 책임 선언이다
