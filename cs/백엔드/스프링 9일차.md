# Spring Security 인증·인가 완전 정리 (Session vs JWT)

이 문서는 **Spring Security 기반 인증/인가 구조**를 세션 방식과 JWT 방식으로 나누어,
요청 흐름, 필터/인터셉터/DispatcherServlet 위치, 권한 처리, 예외·로깅 전략까지 **실무 관점에서 일관되게 정리**한 자료다.

---

## 1. 전체 요청 흐름 (공통)

```
Client
  ↓
Filter (Spring Security Filter Chain)
  ↓
DispatcherServlet
  ↓
HandlerInterceptor
  ↓
Controller
  ↓
HandlerInterceptor
  ↓
Response
```

* **보안의 핵심은 Filter**
* Interceptor는 MVC 내부 공통 처리
* ControllerAdvice는 컨트롤러 영역 예외 처리

---

## 2. Filter / DispatcherServlet / Interceptor 역할 정리

| 구분                | 위치                   | 역할                |
| ----------------- | -------------------- | ----------------- |
| Filter            | DispatcherServlet 이전 | 인증, JWT 검증, 보안 차단 |
| DispatcherServlet | MVC 진입점              | Controller 라우팅    |
| Interceptor       | DispatcherServlet 내부 | 흐름 제어, 성능 로깅      |
| ControllerAdvice  | Controller 내부        | 전역 예외 처리          |

Spring Security는 **Interceptor가 아닌 Filter 기반**이다.

---

## 3. 세션(Session) 방식 인증 구조

### 3-1. 구조

```
Browser
 └─ JSESSIONID (쿠키)

Server
 └─ HttpSession
     └─ SecurityContext
         └─ Authentication
             ├─ principal (UserDetails)
             └─ authorities (ROLE_*)
```

### 3-2. 로그인 흐름

1. POST /login
2. UsernamePasswordAuthenticationFilter
3. AuthenticationManager
4. UserDetailsService.loadUserByUsername()
5. 비밀번호 검증 (PasswordEncoder)
6. Authentication 생성
7. SecurityContext에 저장
8. HttpSession에 보관

### 3-3. UserDetailsService 예시

```java
@Service
@RequiredArgsConstructor
public class CustomUserDetailsService implements UserDetailsService {
  private final UserRepository userRepository;

  @Override
  public UserDetails loadUserByUsername(String email) {
    User user = userRepository.findWithRolesByEmail(email)
        .orElseThrow(() -> new UsernameNotFoundException("User not found"));

    List<GrantedAuthority> authorities = user.getRoles().stream()
        .map(r -> new SimpleGrantedAuthority(r.getName()))
        .toList();

    return org.springframework.security.core.userdetails.User
        .withUsername(user.getEmail())
        .password(user.getPassword())
        .authorities(authorities)
        .build();
  }
}
```

* DB User → UserDetails 변환
* Role → GrantedAuthority 변환

### 3-4. 권한 검사

```java
.requestMatchers("/admin/**").hasRole("ADMIN")

@PreAuthorize("hasRole('ADMIN')")
```

* authorities에 `ROLE_ADMIN`이 있어야 통과

---

## 4. JWT 방식 인증 구조

### 4-1. 구조

```
Client
 └─ JWT (Header 또는 HttpOnly Cookie)

Server
 └─ JWT Filter
     └─ 서명 검증
     └─ claims 추출
     └─ Authentication 생성
     └─ SecurityContext 설정
```

### 4-2. JWT Payload 예시

```json
{
  "sub": "user@email.com",
  "roles": ["ROLE_USER", "ROLE_ADMIN"],
  "exp": 1730000000
}
```

### 4-3. JWT 발급 (로그인 시)

```java
String token = Jwts.builder()
  .subject(user.getEmail())
  .claim("roles", roles)
  .issuedAt(new Date())
  .expiration(expiry)
  .signWith(key)
  .compact();
```

* 권한은 **JWT claims에 포함**
* 로그인 시 DB에서 조회 후 고정

### 4-4. JWT 인증 필터 예시

```java
public class JwtAuthFilter extends OncePerRequestFilter {

  @Override
  protected void doFilterInternal(HttpServletRequest req, HttpServletResponse res,
                                  FilterChain chain) throws IOException, ServletException {

    String header = req.getHeader("Authorization");
    if (header != null && header.startsWith("Bearer ")) {
      String token = header.substring(7);

      Claims claims = jwtProvider.parse(token).getPayload();
      String email = claims.getSubject();
      List<String> roles = (List<String>) claims.get("roles");

      List<GrantedAuthority> authorities = roles.stream()
          .map(SimpleGrantedAuthority::new)
          .toList();

      Authentication auth =
        new UsernamePasswordAuthenticationToken(email, null, authorities);

      SecurityContextHolder.getContext().setAuthentication(auth);
    }

    chain.doFilter(req, res);
  }
}
```

### 4-5. JWT 권한 검사

* 세션과 동일하게 `hasRole`, `@PreAuthorize` 사용
* 차이점: 권한 원본이 세션이 아니라 **토큰**

---

## 5. 세션 vs JWT 비교

| 항목       | 세션        | JWT         |
| -------- | --------- | ----------- |
| 상태       | Stateful  | Stateless   |
| 권한 위치    | 서버 세션     | 토큰 claims   |
| 서버 재시작   | 로그인 풀림 가능 | 영향 없음       |
| 권한 변경 반영 | 즉시        | 토큰 만료 후     |
| 로그아웃     | 세션 삭제     | 토큰 만료/블랙리스트 |

---

## 6. 권한(Role)과 DB 관계

### 6-1. 권한 원본

* **권한의 Source of Truth는 DB**
* 세션/JWT는 DB 권한의 복사본

### 6-2. 권한 모델 예시

```
USER
ROLE
USER_ROLE
```

* ROLE: ROLE_USER, ROLE_ADMIN

---

## 7. 예외 처리 전략

### 7-1. ControllerAdvice

* Controller/Service 예외 처리
* DispatcherServlet 내부 예외만 가능

```java
@RestControllerAdvice
public class GlobalExceptionHandler {

  @ExceptionHandler(IllegalArgumentException.class)
  public ResponseEntity<?> handleBadRequest(Exception e) {
    return ResponseEntity.badRequest().body(e.getMessage());
  }
}
```

### 7-2. Filter 예외 처리

* ControllerAdvice에서 처리 불가
* Security 설정에서 처리

```java
http.exceptionHandling(e -> e
  .authenticationEntryPoint((req, res, ex) -> res.setStatus(401))
  .accessDeniedHandler((req, res, ex) -> res.setStatus(403))
);
```

---

## 8. 로깅 전략 (실무 정석)

| 위치               | 로깅 목적          |
| ---------------- | -------------- |
| Filter           | 요청/응답, 보안, JWT |
| Interceptor      | 실행 시간, 흐름      |
| ControllerAdvice | 비즈니스 예외        |

---

## 9. 자주 나오는 오해 정리

* ControllerAdvice는 전역 예외 처리지만 **Filter 예외는 못 잡음**
* Spring Security는 Interceptor 기반이 아님
* JWT도 탈취되면 세션 탈취와 동일하게 위험
* 프론트 권한 체크는 UX용, 보안은 서버 책임

---

## 9. 페이지 접근 제어 상세 정리 (인증 + 인가 흐름 중심)

이 절은 **"로그인은 이미 끝난 상태"**가 아니라,
**"페이지 요청이 들어왔을 때 인증(Authentication)과 인가(Authorization)가 실제로 어떻게 흘러가는지"**를
요청 단위로 상세하게 설명한다.

---

## 9-1. 페이지 접근에서 인증/인가의 정확한 의미

### 인증(Authentication)

* 이 요청을 보낸 사용자가 **누구인지 증명**하는 과정
* 세션/JWT가 유효한지 확인

### 인가(Authorization)

* 인증된 사용자가 **이 리소스에 접근할 권한이 있는지** 확인
* ROLE / 권한 기반 판단

페이지 접근은 항상 다음 순서를 따른다.

```
1. 인증 (로그인 상태 확인)
2. 인가 (권한 확인)
3. 컨트롤러 실행
```

---

## 9-2. 세션 방식 페이지 접근 인증 흐름 (요청 단위)

### 구조 요약

```
Browser
 └─ JSESSIONID 쿠키

Server
 └─ HttpSession
     └─ SecurityContext
         └─ Authentication
```

---

### 1단계: 브라우저 → 페이지/API 요청

```http
GET /admin/dashboard
Cookie: JSESSIONID=abc123
```

---

### 2단계: Security Filter Chain (인증)

1. SecurityContextPersistenceFilter
2. JSESSIONID로 세션 조회
3. 세션에 저장된 SecurityContext 복원

```text
세션 존재?
 ├─ NO  → Authentication 없음 → 401
 └─ YES → Authentication 복원
```

---

### 3단계: 인가 검사 (FilterSecurityInterceptor)

```java
.requestMatchers("/admin/**").hasRole("ADMIN")
```

```text
Authentication.authorities 에
ROLE_ADMIN 존재?
 ├─ NO  → 403 Forbidden
 └─ YES → 통과
```

---

### 4단계: DispatcherServlet → Controller 실행

* 인증/인가가 끝난 요청만 Controller 도달
* 페이지 데이터/API 정상 응답

---

## 9-3. JWT 방식 페이지 접근 인증 흐름 (요청 단위)

### 구조 요약

```
Client
 └─ JWT (Authorization Header or HttpOnly Cookie)

Server
 └─ JWT Filter
```

---

### 1단계: 브라우저 → 페이지/API 요청

```http
GET /admin/dashboard
Authorization: Bearer eyJhbGciOi...
```

또는

```http
Cookie: access_token=eyJhbGciOi...
```

---

### 2단계: JWT 인증 필터 (인증)

```text
토큰 존재?
 ├─ NO  → Authentication 없음 → 401
 └─ YES
      ├─ 서명 검증 실패 → 401
      ├─ 만료(exp) → 401
      └─ 검증 성공
```

---

### 3단계: JWT → Authentication 생성

```text
claims.sub    → principal
claims.roles  → GrantedAuthority
```

```java
Authentication auth =
 new UsernamePasswordAuthenticationToken(principal, null, authorities);
SecurityContextHolder.getContext().setAuthentication(auth);
```

---

### 4단계: 인가 검사 (FilterSecurityInterceptor)

```java
.requestMatchers("/admin/**").hasRole("ADMIN")
```

* 세션과 완전히 동일한 방식으로 검사

---

## 9-4. 페이지 접근과 프론트엔드의 역할 (UX)

### 프론트엔드 페이지 가드의 역할

* 사용자 경험 개선
* 권한 없는 페이지 진입 차단
* 보안 책임은 아님

```text
프론트 가드 = UX
서버 인가   = 보안
```

---

### JWT(HttpOnly 쿠키) 사용 시 프론트 패턴

```text
GET /me
→ 서버에서 인증 + 권한 추출
→ { email, roles }
```

```jsx
if (!roles.includes("ROLE_ADMIN")) {
  navigate("/403");
}
```

---

## 9-5. 페이지 접근 실패 시 응답 정리

| 상황     | HTTP 상태          |
| ------ | ---------------- |
| 인증 안 됨 | 401 Unauthorized |
| 권한 없음  | 403 Forbidden    |
| 페이지 없음 | 404 Not Found    |

---

## 9-6. 절대 하면 안 되는 잘못된 설계

* 프론트 페이지 가드만으로 보안 처리
* JWT를 프론트에서 decode만 하고 신뢰
* API 권한 체크 없이 페이지 제공
* 관리자 페이지 HTML을 무조건 제공

---

## 10. 핵심 요약

```
페이지 요청 → 인증 → 인가 → Controller

세션 인증  : JSESSIONID → SecurityContext
JWT 인증   : Token → Filter → SecurityContext
인가 처리  : FilterSecurityInterceptor
프론트 가드: UX 전용
```

```
인증 위치  : Filter
인가 위치  : FilterSecurityInterceptor
권한 원본  : DB
세션       : 서버 상태 기반
JWT        : 토큰 기반
전역 예외  : ControllerAdvice (MVC 한정)
```

---


