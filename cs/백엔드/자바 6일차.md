# HashMap에서 hashCode와 equals 비교 순서 정리

이 문서는 HashMap / HashSet에서 **hashCode와 equals가 어떤 순서로 사용되는지**를
핵심만 뽑아 정리한 문서다.

---

## 1. 결론 요약

- **hashCode로 먼저 비교 범위를 제한한다**
- **equals는 hashCode가 같은 경우에만 호출된다**
- hashCode가 다르면 equals는 아예 실행되지 않는다

즉,

```
hashCode → 후보군 선택
equals   → 최종 판정
```

---

## 2. HashMap의 기본 동작 흐름

### 2.1 put(key, value)

1. `key.hashCode()` 호출
2. hashCode를 이용해 버킷(index) 계산
3. 해당 버킷 안에서만 기존 엔트리와 비교
4. 같은 hashCode + equals true면 덮어쓰기
5. 없으면 새 엔트리 추가

개념 코드:

```java
int h = key.hashCode();
int index = h % table.length;

for (Node n : table[index]) {
    if (n.hash == h && n.key.equals(key)) {
        // 같은 key → 값 덮어쓰기
    }
}
```

---

### 2.2 get(key)

1. `key.hashCode()` 호출
2. hashCode로 버킷(index) 계산
3. 해당 버킷 안에서만 탐색
4. equals가 true인 엔트리를 찾으면 반환
5. 없으면 null 반환

개념 코드:

```java
int h = key.hashCode();
int index = h % table.length;

for (Node n : table[index]) {
    if (n.hash == h && n.key.equals(key)) {
        return n.value;
    }
}
return null;
```

중요:
- **다른 버킷은 아예 탐색하지 않는다**
- equals는 같은 버킷 안에서만 실행된다

---

## 3. 왜 equals 전에 hashCode를 쓰는가?

HashMap의 목표는:

```
get / put / remove 평균 O(1)
```

이를 위해:
- 전체를 뒤지지 않고
- hashCode로 후보 범위를 극단적으로 줄인다

만약 모든 엔트리를 equals로 비교한다면:
- O(n)
- HashMap의 의미가 사라진다

---

## 4. 그래서 생기는 핵심 규약

### 반드시 지켜야 하는 규칙

> **equals가 true이면 hashCode는 반드시 같아야 한다**

이 규칙이 깨지면:

- equals는 “같다”고 판단
- HashMap은 “다른 버킷”으로 판단
- equals 비교 자체가 실행되지 않음

---

## 5. 예제: equals는 true인데 못 찾는 경우

```java
User u1 = new User("kim", 27);
User u2 = new User("kim", 27);

u1.equals(u2); // true
u1.hashCode() != u2.hashCode();

map.put(u1, "DATA");
map.get(u2);   // null
```

이유:
- u2.hashCode()로 다른 버킷을 찾음
- u1이 있는 버킷을 보지 않음
- equals가 호출될 기회 자체가 없음

---

## 6. 반대는 허용된다

```java
hashCode 같음
equals false
```

- 같은 버킷에 들어감
- equals로 최종 판별
- 충돌(collision) 처리

이는 정상 동작이다.

---

## 7. 한 문장 정리

> HashMap은 먼저 hashCode로 비교 범위를 제한하고,
> 같은 hashCode 범위(버킷) 안에서만 equals로 최종 비교한다.

---

## 8. 핵심 요약

```
hashCode 다르면 equals 안 함
equals true면 hashCode 반드시 같아야 함
equals는 버킷 내부 판별용이다
```

