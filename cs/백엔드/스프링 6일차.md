
# JPA 엔티티 생명주기 및 Lazy Loading 정리

## 1. 상태 개념 요약

| 상태 | JPA 관리 여부 | DB Row 존재 | 특징 |
|------|--------------|-------------|------|
| 비영속(Transient) | X | 보통 X | JPA가 모르는 새 객체 |
| 영속(Managed) | O | O 또는 INSERT 예정 | Dirty Checking 및 1차 캐시 관리 |
| 준영속(Detached) | X | O | 예전에 영속이었으나 지금은 추적 끊김 |
| 삭제(Removed) | O(삭제 예약) | 곧 삭제 | flush 시 DELETE 실행 |

---

## 2. 상태 전이 흐름

비영속
 ↓ persist()
영속
 ↓ detach(), clear(), close(), 트랜잭션 종료
준영속
 ↓ merge()
영속
 ↓ remove()
삭제
 ↓ flush + commit
DB 삭제 완료

---

## 3. 각 상태에서 CRUD 동작

| 상태 | INSERT | UPDATE | DELETE |
|------|--------|--------|--------|
| 비영속 | persist()로 INSERT | X | X |
| 영속 | 이미 저장 or INSERT 예정 | Dirty Checking 자동 UPDATE | remove()로 DELETE |
| 준영속 | merge 시 INSERT 가능성 있음 | merge 필요 | find/merge 후 remove |
| 삭제 | 삭제 예약 | X | flush 시 DELETE |

---

## 4. 영속성 컨텍스트 & 트랜잭션 관계

| 위치 | 영속 여부 | 설명 |
|------|---------|-----|
| Service 내부(@Transactional) | 영속 | flush/commit 시 DB 반영 |
| Controller, View, 프론트 전송 | 준영속 | 수정해도 DB 반영 X |

영속 상태 조건
- 트랜잭션 내부
- EntityManager가 살아있음
- find() 또는 persist() 호출됨

---

## 5. Dirty Checking

동작 조건
- 영속 상태
- 트랜잭션 안
- 스냅샷 존재

동작 흐름

find() → 스냅샷 저장
setter 변경 → 스냅샷 비교
→ flush 시 UPDATE SQL 자동 생성

---

## 6. merge 사용이 필요한 경우 (준영속/비영속 UPDATE)

```java
@Transactional
public void updateDetached(Comment dto) {
    Comment managed = em.merge(dto);
}
```

- 기존 객체(dto)와 동일성 불일치  
- 필드 누락 시 데이터 null 덮어쓰기 위험  
- 실무에서는 지양

---

## 7. UPDATE Best Practice

```java
@Transactional
public void update(Long id, String content) {
    Comment c = commentRepository.findById(id)
        .orElseThrow();
    c.setContent(content);
}
```

- 동일성 유지  
- 스냅샷 비교로 필요한 필드만 UPDATE  
- 성능 최적화

---

## 8. Lazy Loading 동작 원리 및 주의점

Lazy Loading 정상 동작 조건
- 영속 상태
- 트랜잭션 안
- DB 세션 및 영속성 컨텍스트 활성화

정상 예시
```java
@Transactional
public void getComment(Long id){
    Comment c = em.find(Comment.class, id);
    c.getParent(); // Lazy 로딩 가능
}
```

오류 예시: 트랜잭션 밖에서 호출
```java
public String getComment(Long id) {
    Comment c = service.getComment(id); // 여기서 준영속
    c.getParent(); // Lazy 로딩 실패
}
```

실제 발생 예외
```
org.hibernate.LazyInitializationException:
could not initialize proxy - no Session
```

해결 방법
- Service 계층에서 DTO로 변환하여 반환
- fetch join 사용하여 필요한 연관 엔티티 미리 로딩

---

## 9. Fetch 전략 비교

| 전략 | 설명 | 장점 | 단점 |
|------|-----|-----|-----|
| LAZY | 필요한 순간 로딩 | 성능 최적화 | 트랜잭션 밖에서 오류 가능 |
| EAGER | 즉시 로딩 | Lazy 문제 없음 | 과도한 쿼리, N+1 문제 발생 |

권장: LAZY + fetch join 조합

---

## 10. 핵심 요약

비영속  → persist() → 영속  
영속    → 트랜잭션 종료 → 준영속  
준영속  → merge() → 영속  
영속    → remove() → 삭제 → flush → DB 제거  

Update는 오직 영속 상태에서 Dirty Checking 자동 수행  
준영속/비영속은 UPDATE 안 되고, merge/save 필요  

Lazy 로딩은 영속 상태 + 트랜잭션 안에서만 가능  
Controller로 넘어가면 준영속이므로 Lazy 로딩 실패 가능

---

## 11. 실무 Best Practice

- Controller에서는 엔티티 대신 DTO 사용
- Service @Transactional 내부에서 수정/조회 처리
- 연관 관계는 기본 LAZY, 필요한 경우 fetch join

