# 익명 클래스 / Comparator / Stream sort / Function 타입 추론 정리 

## 1. 익명 클래스(Anonymous Class)

### 1.1 개념
- 이름이 없는 클래스(클래스 선언 + 객체 생성이 한 번에 일어남)
- 인터페이스 구현 또는 추상 클래스 상속을 “한 번만” 쓰고 싶을 때 자주 사용
- 단점: 코드가 길고 가독성이 떨어져서, 요즘은 람다/메서드 참조로 대체되는 경우가 많음

### 1.2 Comparator 익명 클래스 예시
```java
List<Integer> list = Arrays.asList(5, 3, 1, 4);

list.sort(new Comparator<Integer>() {
    @Override
    public int compare(Integer a, Integer b) {
        return a - b; // 오름차순
    }
});
```

## 2. Comparator 정렬의 핵심

### 2.1 Comparator의 정체
Comparator는 “정렬 기준”을 외부에서 정의하는 인터페이스.

```java
@FunctionalInterface
public interface Comparator<T> {
    int compare(T o1, T o2);
}
```

- 입력(Input): (T, T) 2개
- 출력(Output): int (음수/0/양수로 순서 결정)

### 2.2 람다로 표현
익명 클래스를 람다로 줄이면 다음 형태가 됨.

```java
list.sort((a, b) -> a - b);
```

정렬에서 빼기 연산은 오버플로우 위험이 있으므로 보통 아래를 선호:
```java
list.sort((a, b) -> Integer.compare(a, b));
```

## 3. Function 관점에서 Input/Output 찾는 법

### 3.1 판별 공식
- 람다에서 매개변수(파라미터) = Input
- return 값(또는 메서드 반환) = Output

### 3.2 대표 함수형 인터페이스(치트키)
| 이름 | 추상 메서드 | Input 개수 | Output |
|---|---|---:|---|
| Function<T,R> | R apply(T t) | 1 | R |
| Predicate<T> | boolean test(T t) | 1 | boolean |
| Consumer<T> | void accept(T t) | 1 | 없음 |
| Supplier<T> | T get() | 0 | T |
| BiFunction<T,U,R> | R apply(T t, U u) | 2 | R |
| Comparator<T> | int compare(T a, T b) | 2 | int |

## 4. 메서드 참조(::)가 “어떤 타입(Function/Comparator/… )인지” 아는 법

### 4.1 핵심 결론: 문맥(Context)으로 결정된다
메서드 참조/람다는 자체로 “고정 타입”이 있는 게 아니라,
“그 자리에 요구되는 함수형 인터페이스”에 맞춰 타입이 정해진다.

판별 순서(실전 3단계):
1) 이 자리에 어떤 타입이 와야 하는가? (대입의 좌변 타입 / 메서드 파라미터 타입 / return 타입)
2) 그 함수형 인터페이스의 추상 메서드 시그니처는? (파라미터 개수, 타입, 반환)
3) 메서드 참조(또는 람다)가 그 시그니처와 호환되는가?

### 4.2 예시: User::getAge가 Function이 되는 이유
```java
Function<User, Integer> f = User::getAge;
```

- 좌변이 Function<User, Integer>이므로, 우변은 apply(User) -> Integer 형태여야 함
- User::getAge는 다음과 동치로 해석됨:
```java
(User u) -> u.getAge()
```
- getAge()가 int를 반환해도 오토박싱으로 Integer와 호환됨

결론:
- Input: User
- Output: Integer
- 즉 Function<User, Integer>

### 4.3 static 메서드 참조 예시: Integer::parseInt
```java
Function<String, Integer> f = Integer::parseInt;
```

parseInt 시그니처:
```java
public static int parseInt(String s)
```

동치 변환:
```java
(String s) -> Integer.parseInt(s)
```

결론:
- Input: String
- Output: Integer
- 즉 Function<String, Integer>

### 4.4 Integer::compare는 무엇이 되나?
Integer.compare 시그니처:
```java
public static int compare(int x, int y)
```

이건 입력이 2개이므로 보통 BiFunction으로 매칭 가능:
```java
BiFunction<Integer, Integer, Integer> f = Integer::compare;
// (a, b) -> Integer.compare(a, b)
```

주의:
- Integer.compare 자체가 Comparator는 아님
- Comparator는 (T, T) -> int (두 “객체”를 비교)
- Integer.compare는 (int, int) -> int (두 “숫자”를 비교)
- 하지만 Comparator 안에서 비교 도구로 자주 사용됨:
```java
Comparator<User> c = (u1, u2) -> Integer.compare(u1.getAge(), u2.getAge());
```

## 5. Comparator.comparing(User::getAge)는 어떻게 변환되는가?

### 5.1 comparing의 역할
comparing은 “키 추출 함수(Function)”를 받아서 “Comparator”를 만들어주는 팩토리 메서드(변환기).

대표 시그니처(개념):
```java
static <T, U extends Comparable<? super U>>
Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor)
```

즉:
- 입력: Function<T, U> (키 추출기)
- 출력: Comparator<T>

### 5.2 핵심 코드
```java
Comparator<User> c = Comparator.comparing(User::getAge);
```

이때 문맥/추론 흐름:
1) 좌변이 Comparator<User>이므로 comparing 결과는 Comparator<User>여야 함
2) 그러면 comparing의 T는 User로 확정
3) comparing은 파라미터로 Function<User, U> 형태를 요구
4) 따라서 User::getAge는 Function<User, Integer>로 해석됨
5) comparing이 그 Function을 이용해 Comparator<User>를 생성

### 5.3 완전 풀어쓰기(개념적으로 거의 동일)
```java
Function<User, Integer> keyExtractor = (User u) -> u.getAge();

Comparator<User> c = new Comparator<User>() {
    @Override
    public int compare(User u1, User u2) {
        Integer k1 = keyExtractor.apply(u1);
        Integer k2 = keyExtractor.apply(u2);
        return k1.compareTo(k2);
    }
};
```

람다로 더 줄이면:
```java
Comparator<User> c =
    (u1, u2) -> Integer.compare(u1.getAge(), u2.getAge());
```

중요 포인트:
- Comparator는 항상 (User, User) 2개를 입력으로 받는다
- User::getAge는 Comparator가 아니라, “정렬 키를 뽑는 Function”이다
- comparing이 그 Function을 이용해 Comparator를 “만들어준다”

### 5.4 users.sort(Comparator.comparing(User::getAge)) 분류 흐름
```java
users.sort(Comparator.comparing(User::getAge));
```

컴파일러가 분류하는 단계:
1) List.sort는 Comparator<User>를 요구
2) Comparator.comparing은 Function<User, 키>를 요구
3) 그래서 User::getAge는 Function<User, Integer>로 결정
4) comparing이 Comparator<User> 생성
5) sort가 그 Comparator로 정렬 실행

## 6. “클래스.함수” vs “객체.함수” vs “Class::instanceMethod” 구분

### 6.1 호출 형태로 구분
- 왼쪽이 “클래스(타입)”이면 static 호출인 경우가 많음:
  - Integer.parseInt("123") : static
- 왼쪽이 “객체(값)”이면 인스턴스 호출:
  - u.getAge() : 인스턴스

### 6.2 메서드 참조 4종(핵심)
1) static 메서드 참조
```java
Integer::parseInt
// (String s) -> Integer.parseInt(s)
```

2) 특정 객체의 인스턴스 메서드 참조
```java
u::getAge
// () -> u.getAge()
```

3) 임의 객체의 인스턴스 메서드 참조(가장 헷갈리는 케이스)
```java
User::getAge
// (User u) -> u.getAge()
```
여기서 호출 주체는 “나중에 들어오는 입력 객체(u)”이다.

4) 생성자 참조
```java
User::new
```

## 7. Stream 정렬(sorted) vs List 정렬(sort)

### 7.1 차이 요약
| 구분 | List.sort | Stream.sorted |
|---|---|---|
| 원본 변경 | 변경함(in-place) | 원본 유지(새 스트림) |
| 반환 | void | Stream<T> |
| 스타일 | 명령형에 가깝다 | 함수형 파이프라인 |

### 7.2 Stream sorted 예시
```java
List<User> sorted =
    users.stream()
         .sorted(Comparator.comparing(User::getAge))
         .toList();
```

## 8. 최종 핵심 요약(한 줄씩)
- Comparator는 항상 (T, T) -> int 형태로 비교한다.
- Function은 T -> R 형태로 “값을 뽑거나 변환”한다.
- Comparator.comparing은 Function을 받아 Comparator를 만들어주는 변환기(factory)다.
- 메서드 참조/람다의 타입은 “표현식 자체”가 아니라 “그 자리에 필요한 함수형 인터페이스(문맥)”로 결정된다.
- Integer.parseInt는 static 메서드(입력 1개)라 보통 Function<String,Integer>로 매칭된다.
- Integer.compare는 입력 2개라 BiFunction으로 매칭 가능하며, Comparator 내부에서 비교 도구로 많이 사용된다.
