# Comparator.comparing(User::getAge) 동작 흐름 상세 정리

## 0. 원본 코드

```java
users.sort(Comparator.comparing(User::getAge));
```

이 한 줄의 코드에서 일어나는 일은
컴파일 타임과 런타임을 거쳐 여러 단계로 나뉜다.

---

## 1. User::getAge 는 단독으로는 타입이 없다

```java
User::getAge
```

이 표현식은 다음 중 어느 것도 아니다.

- Function
- Comparator
- 메서드 호출

즉, **아직 아무 타입도 없는 메서드 참조 표현식**이다.

메서드 참조는 반드시
어떤 함수형 인터페이스에 대입될 때 의미가 결정된다.

---

## 2. 타깃 타입 결정: Comparator.comparing()

```java
Comparator.comparing(User::getAge)
```

`comparing()` 메서드의 시그니처는 다음과 같다.

```java
static <T, U extends Comparable<? super U>>
Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor)
```

중요한 점은:

- comparing은 **Function 하나를 인자로 받는다**
- 따라서 `User::getAge`는 반드시 `Function` 형태로 해석되어야 한다

---

## 3. 이 시점에서 User::getAge의 타입이 확정된다

컴파일러는 다음과 같이 해석한다.

```java
User::getAge
≡ (User u) -> u.getAge()
```

즉, 타입은 다음과 같이 결정된다.

```java
Function<User, Integer>
```

이를 **타깃 타입(Target Type)에 의한 타입 결정**이라고 한다.

---

## 4. Function<User, Integer>의 실제 의미

```java
Function<User, Integer> f = User::getAge;
```

이는 개념적으로 다음과 같다.

```java
Integer apply(User u) {
    return u.getAge();
}
```

즉,

- 입력: User
- 출력: Integer (나이)

---

## 5. comparing() 내부에서 Comparator가 생성된다

`comparing(f)`는 내부적으로 다음과 같은 Comparator를 만든다.

```java
Comparator<User> comp = (u1, u2) -> {
    Integer k1 = f.apply(u1);
    Integer k2 = f.apply(u2);
    return k1.compareTo(k2);
};
```

중요한 특징:

- Comparator는 User를 직접 비교하지 않는다
- Function으로 추출한 **비교 키(key)** 만 비교한다

---

## 6. sort()는 Comparator만 사용한다

```java
users.sort(comp);
```

`List.sort()`의 시그니처는 다음과 같다.

```java
void sort(Comparator<? super E> c)
```

즉,

- sort는 Function을 모른다
- User::getAge도 모른다
- 오직 Comparator만 사용한다

---

## 7. 정렬 중 실제 실행 흐름 (런타임)

정렬 알고리즘이 비교가 필요할 때마다 다음이 반복된다.

```java
comp.compare(u1, u2);
```

compare 내부 동작:

```java
f.apply(u1); // u1.getAge()
f.apply(u2); // u2.getAge()
compareTo(...)
```

이 과정이 정렬이 끝날 때까지 반복된다.

---

## 8. 전체 흐름 요약 다이어그램

```text
User::getAge
   ↓ (타깃 타입: Function 요구)
Function<User, Integer>
   ↓ (comparing 내부)
Comparator<User>
   ↓
users.sort(Comparator)
   ↓
compare(u1, u2) 반복 호출
```

---

## 9. 컴파일러 관점 핵심 정리

1. 메서드 참조는 단독으로 타입이 없다
2. comparing()이 Function을 요구한다
3. 메서드 참조가 Function<User, Integer>로 변환된다
4. comparing()이 Comparator<User>를 생성한다
5. sort()는 Comparator만 사용한다

---

## 10. 한 문장 요약 

`User::getAge`는 comparing()의 타깃 타입에 의해  
Function<User, Integer>로 해석되고,  
comparing()은 이 Function으로 Comparator<User>를 생성하며,  
sort()는 생성된 Comparator만을 사용해 정렬을 수행한다.
