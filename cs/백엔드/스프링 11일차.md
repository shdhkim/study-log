# Spring Security 인증 총정리 (회원가입 + Session/JWT 로그인·로그아웃·권한 접근)


---

## 0. 전체 구조 한눈에 보기

```text
회원가입
 → DB(User, Role 저장)
 → 로그인
    → Authentication 생성
    → (Session or JWT)
 → 요청
    → 인증 복원(Authentication)
    → 권한(authorities) 검사
 → 로그아웃
    → Session 무효화 또는 토큰 폐기
```

핵심 원칙:
- **권한 판단은 항상 Authentication.authorities 기준**
- 프론트는 role을 “증명”하지 않는다
- 프론트는 **인증 수단(세션 쿠키 / JWT)** 만 전달한다

---

## 1. 회원가입(Sign Up) 상세

### 1.1 회원가입의 본질
회원가입은 **인증(Authentication)이 아니다**.

> 회원가입 = “로그인에 필요한 데이터(User, Password, Role)를 DB에 저장하는 작업”

아직 SecurityContext ❌  
아직 로그인 상태 ❌

---

### 1.2 회원가입 요청 예시

```http
POST /api/signup
Content-Type: application/json

{
  "username": "kim",
  "password": "1234",
  "email": "kim@test.com"
}
```

---

### 1.3 회원가입 시 서버가 반드시 해야 할 것

#### (1) 비밀번호 암호화 (절대 평문 저장 ❌)

```java
@Service
@RequiredArgsConstructor
public class UserService {

  private final UserRepository userRepository;
  private final PasswordEncoder passwordEncoder;

  public void signup(SignupRequest dto) {

    if (userRepository.existsByUsername(dto.getUsername())) {
      throw new IllegalStateException("이미 존재하는 사용자");
    }

    User user = new User();
    user.setUsername(dto.getUsername());
    user.setPassword(passwordEncoder.encode(dto.getPassword()));
    user.setEmail(dto.getEmail());

    userRepository.save(user);
  }
}
```

- `passwordEncoder.encode()` 필수
- DB에는 **해시된 값만 저장**

---

#### (2) 기본 권한(Role) 부여

```java
Role userRole = roleRepository.findByName("USER");

user.addRole(userRole);
```

보통 DB에는:
```text
USER
ADMIN
```

권한은 로그인 시 `"ROLE_" + name` 형태로 변환된다.

---

### 1.4 회원가입 후 자동 로그인?

선택 사항이다.

- 보안 엄격: ❌ 자동 로그인
- UX 우선: ⭕ 자동 로그인

자동 로그인 시:
- 회원가입 성공 직후 Authentication 생성
- SecurityContext에 저장
- 세션/JWT 발급

하지만 **초기 설계에서는 분리하는 게 안전**하다.

---

## 2. Session 기반 로그인(Login)

### 2.1 로그인 요청

```http
POST /login
Content-Type: application/x-www-form-urlencoded

username=kim&password=1234
```

---

### 2.2 내부 인증 흐름

```text
로그인 요청
 → AuthenticationFilter
 → AuthenticationManager
 → AuthenticationProvider
 → UserDetailsService.loadUserByUsername()
 → PasswordEncoder.matches()
 → Authentication 생성
 → SecurityContext 저장
 → HttpSession 저장
```

---

### 2.3 로그인 성공 후

```http
Set-Cookie: JSESSIONID=XYZ; HttpOnly
```

- 브라우저가 자동 저장
- 이후 요청마다 자동 전송

---

## 3. Session 기반 권한 접근

### 3.1 Security 설정 예시

```java
http.authorizeHttpRequests(auth -> auth
    .requestMatchers("/admin/**").hasRole("ADMIN")
    .requestMatchers("/user/**").hasAnyRole("USER","ADMIN")
    .anyRequest().authenticated()
);
```

### 3.2 접근 흐름

```text
요청
 → JSESSIONID
 → 세션 조회
 → SecurityContext 복원
 → Authentication.authorities 검사
 → 통과/차단
```

---

## 4. Session 기반 로그아웃

### 4.1 로그아웃 요청

```http
POST /logout
Cookie: JSESSIONID=XYZ
```

### 4.2 서버 처리

- SecurityContext 제거
- HttpSession.invalidate()
- Set-Cookie로 JSESSIONID 삭제 지시

```http
Set-Cookie: JSESSIONID=; Max-Age=0
```

---

## 5. JWT 기반 로그인(Login)

### 5.1 로그인 요청

```http
POST /api/login
Content-Type: application/json

{
  "username": "kim",
  "password": "1234"
}
```

---

### 5.2 로그인 성공 시 서버 동작

1. username/password 검증
2. JWT Access Token 생성
3. (선택) Refresh Token 생성

JWT payload 예시:

```json
{
  "sub": "kim",
  "roles": ["ROLE_USER"],
  "iat": 1700000000,
  "exp": 1700003600
}
```

---

### 5.3 토큰 전달 방식

#### (1) Authorization 헤더
```json
{ "accessToken": "eyJhbGciOi..." }
```

프론트:
```http
Authorization: Bearer eyJhbGciOi...
```

#### (2) HttpOnly Cookie (권장 케이스 많음)

```http
Set-Cookie: accessToken=eyJhbGciOi...; HttpOnly; Secure
```

---

## 6. JWT 기반 권한 접근

### 6.1 요청 처리 흐름

```text
요청
 → JWT 필터
 → 토큰 검증
 → roles claim 추출
 → GrantedAuthority 생성
 → Authentication 생성
 → SecurityContextHolder 저장
 → hasRole 판단
```

### 6.2 권한 실패

- 토큰 없음 / 만료 → 401
- 권한 부족 → 403

---

## 7. JWT 기반 로그아웃

### 7.1 Stateless 로그아웃

- 프론트: 토큰 삭제
- 서버: 아무것도 안 함

⚠️ 토큰이 유효하면 다시 인증됨

---

### 7.2 Refresh Token 기반 로그아웃 (실무 권장)

- 서버: Refresh Token 폐기(DB/Redis)
- 서버 → Set-Cookie로 refreshToken 삭제 지시
- 프론트: Access Token 삭제

---

## 8. 회원가입 → 로그인 → 접근 제어 전체 연결

```text
회원가입
 → DB(User, Password(hash), Role)
 → 로그인
 → Authentication(authorities 포함)
 → Session/JWT 발급
 → 요청
 → hasRole / hasAuthority
 → 접근 허용/차단
 → 로그아웃
 → 인증 정보 폐기
```

---

## 9. 실무 설계 기준 요약

- 회원가입은 SecurityContext를 만들지 않는다
- 비밀번호는 반드시 해시 저장
- 권한은 로그인 시 Authentication에 고정
- Session: 즉시 차단 가능
- JWT: Refresh Token 전략 필수
- Set-Cookie는 Body가 아닌 Response Header

---

## 10. 요약 한 문장

> Spring Security에서 회원가입은 사용자와 권한 데이터를 DB에 저장하는 단계이며,  
> 로그인 시 Authentication을 생성해 Session 또는 JWT로 인증 상태를 유지하고,  
> 이후 모든 접근 제어는 Authentication의 authorities를 기준으로 수행된다.

---

### 끝
