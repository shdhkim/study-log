# Java Object / Casting / foreach / Stream / JVM 총정리

## 1. JVM과 타입 시스템 개요

### 1.1 JVM 역할
- Java 바이트코드를 실행하는 런타임 환경
- 메모리 관리 (Heap / Stack / Metaspace)
- 클래스 로딩
- 런타임 타입 체크

### 1.2 컴파일러 vs JVM
| 구분 | 컴파일러 | JVM |
|----|----|----|
| 시점 | 컴파일 타임 | 런타임 |
| 기준 | 참조 타입 | 실제 객체 타입 |
| 역할 | 문법/타입 검사 | 실제 실행/검증 |

---

## 2. Object 클래스

### 2.1 Object란?
- java.lang.Object
- 모든 클래스의 최상위 부모
- 모든 객체는 Object 타입으로 참조 가능

```java
Object o = new Dog();
```

### 2.2 Object 주요 메서드
- toString()
- equals(Object o)
- hashCode()
- getClass()
- wait(), notify()
- clone()

### 2.3 equals / hashCode 규약
- equals가 true면 hashCode도 반드시 같아야 함
- HashMap / HashSet 동작 기준

---

## 3. 업캐스팅 (Upcasting)

### 3.1 정의
- 자식 객체 → 부모 타입 참조
- 자동 캐스팅
- 항상 안전

```java
Animal a = new Dog();
```

### 3.2 JVM 관점
- Heap에는 Dog 객체만 존재
- 참조 타입만 Animal로 제한됨
- JVM 검증 불필요

```text
Stack: a (Animal)
Heap : Dog 객체
```

### 3.3 특징
- 다형성 가능
- 오버라이딩 메서드는 실제 객체 기준 실행

---

## 4. 다운캐스팅 (Downcasting)

### 4.1 정의
- 부모 타입 참조 → 자식 타입 변환
- 명시적 캐스팅 필요
- 런타임 위험 존재

```java
Dog d = (Dog) a;
```

### 4.2 왜 명시 캐스팅이 필요한가?
- 컴파일러는 실제 객체 타입을 모름
- JVM만 런타임에 확인 가능
- 개발자에게 책임을 요구

### 4.3 JVM 동작 과정
1. 캐스팅 코드 실행
2. JVM이 실제 객체 타입 검사
3. 맞으면 통과
4. 틀리면 ClassCastException

```java
Animal a = new Cat();
Dog d = (Dog) a; // 런타임 예외
```

### 4.4 instanceof
```java
if (a instanceof Dog) {
    Dog d = (Dog) a;
}
```

- 런타임 타입을 명시적으로 검사
- JVM이 안전함을 보장

---

## 5. 메모리 관점 정리

```text
Stack  : 참조 변수 (타입 정보)
Heap   : 실제 객체
```

- 캐스팅은 객체가 아니라 참조 타입을 바꿈
- 객체는 절대 변하지 않음

---

## 6. foreach (Enhanced for)

### 6.1 문법
```java
for (Type v : collection) { }
```

### 6.2 내부 동작
- Iterator 기반

```java
Iterator<T> it = collection.iterator();
while (it.hasNext()) {
    T v = it.next();
}
```

### 6.3 업캐스팅과 함께 사용
```java
for (Animal a : list) {
    a.sound();
}
```

### 6.4 다운캐스팅과 함께 사용
```java
for (Animal a : list) {
    if (a instanceof Dog) {
        ((Dog) a).bite();
    }
}
```

---

## 7. Collection.forEach()

### 7.1 특징
- Java 8부터 추가
- 람다 기반 반복

```java
list.forEach(System.out::println);
```

- break / continue 불가
- 단순 반복 처리용

---

## 8. Stream

### 8.1 Stream 개념
- 데이터 처리 파이프라인
- 반복이 목적 아님

```java
list.stream()
    .filter(x -> x > 10)
    .map(x -> x * 2)
    .toList();
```

### 8.2 지연 실행
- 최종 연산 전까지 실행되지 않음

### 8.3 Stream.forEach
- 파이프라인 종료 연산
- 병렬 시 순서 보장 안 됨

---

## 9. 병렬 Stream과 JVM

```java
list.parallelStream().forEach(System.out::println);
```

- ForkJoinPool 사용
- 멀티스레드 실행
- 상태 공유 시 위험

---

## 10. 언제 무엇을 써야 하나?

### 10.1 for / foreach
- 제어 흐름 필요
- 다운캐스팅
- 상태 변경

### 10.2 Stream
- 필터링
- 매핑
- 집계
- 불변 데이터 처리

---

## 11. 핵심 요약

- 모든 객체는 Object를 상속
- 업캐스팅은 자동, 안전
- 다운캐스팅은 명시 필요, JVM이 런타임 검사
- instanceof는 JVM 타입 검증 도구
- foreach는 Iterator 기반 반복
- Collection.forEach는 람다 반복
- Stream은 지연 실행 데이터 처리 파이프라인
- Stream.forEach는 마지막 단계
- 캐스팅은 객체가 아니라 참조 타입의 문제
