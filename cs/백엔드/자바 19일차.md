# Java 함수형 인터페이스 (Functional Interface) 완전 정리

## 1. 함수형 인터페이스란?

함수형 인터페이스(Function Interface)는  
**추상 메서드가 정확히 하나만 존재하는 인터페이스**를 의미한다.

```java
@FunctionalInterface
public interface Consumer<T> {
    void accept(T t);
}
```

핵심 조건
- 추상 메서드 1개
- default / static 메서드는 개수 제한 없음

---

## 2. 왜 함수형 인터페이스가 필요한가?

함수형 인터페이스는 **람다 표현식(Lambda Expression)의 대상 타입(Target Type)**이 되기 위해 필요하다.

```java
Consumer<Integer> c = x -> System.out.println(x);
```

람다는 스스로 타입을 가지지 않으며  
반드시 **함수형 인터페이스의 추상 메서드에 매핑**되어야 한다.

---

## 3. @FunctionalInterface 애노테이션

역할
- 컴파일 타임 검증
- 추상 메서드가 2개 이상이면 컴파일 에러 발생

---

## 4. 함수형 인터페이스의 핵심 규칙

- 추상 메서드는 1개만 허용
- Object 클래스 메서드는 추상 메서드 수에 포함되지 않음

---

## 5. 람다와 익명 클래스 관계

람다는 **함수형 인터페이스의 유일한 추상 메서드를 구현한 표현식**이다.

```java
Consumer<Integer> c = new Consumer<Integer>() {
    @Override
    public void accept(Integer x) {
        System.out.println(x);
    }
};
```

---

## 6. 익명 클래스 vs 람다

익명 클래스
- 인터페이스, 추상 클래스, 일반 클래스 가능
- 필드 보유 가능

람다
- 함수형 인터페이스만 가능
- 상태 없음

---

## 7. 대표적인 Java 표준 함수형 인터페이스

- Consumer<T>
- Supplier<T>
- Function<T, R>
- Predicate<T>
- Runnable
- Comparator<T>

---

## 8. forEach와 Consumer

```java
list.forEach(System.out::println);
```

forEach는 내부적으로 Consumer.accept를 반복 호출한다.

---

## 9. 핵심 요약

람다는 함수형 인터페이스의 유일한 추상 메서드를 구현한 표현식이다.
