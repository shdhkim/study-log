# JPA 복합키, equals/hashCode, HashMap/Set, 영속성 컨텍스트 정리

> **목표**:  
> - `equals`, `hashCode`가 **왜 중요한지**  
> - **HashMap / HashSet / 버킷** 구조가 어떻게 동작하는지  
> - JPA **영속성 컨텍스트 + 복합키(@EmbeddedId)** 에서  
>   이게 어떻게 연결되어 **문제가 터지는지**  
>   + MVC / Service / Repository 구조에서 흐름까지 이해하기

---

## 1. HashMap / HashSet / 버킷 구조 기본기

### 1-1. HashMap을 겉에서 보면

우리가 평소에 쓰는 HashMap은 그냥 **Key-Value 쌍** 저장소다.

```java
Map<String, Integer> map = new HashMap<>();
map.put("A", 10);
map.put("B", 20);
```

겉에서 볼 때는:

- `"A" → 10`
- `"B" → 20`

이렇게 보인다.

---

### 1-2. HashMap 내부 구조 (버킷 + Node 리스트)

내부적으로는 이렇게 생김:

```text
HashMap
 └─ table[]  ← 버킷 배열 (hashCode 기반 index)
      ├─ bucket[0] → Node(key, value, next)
      ├─ bucket[1] → Node → Node → ... (연결 리스트 or 트리)
      ├─ bucket[2] → null
      └─ ...
```

Node 구조(자바 내부 개념):

```java
static class Node<K,V> {
    final int hash;
    final K key;
    V value;
    Node<K,V> next; // 같은 버킷 내에서 연결 리스트(또는 트리)
}
```

#### 정리

- **hashCode()** → `table[index]`에서 **버킷 위치** 결정
- 같은 index(버킷)에 여러 Key가 모이면 → **연결 리스트**나 **트리**로 관리
- 그 안에서 `equals()`로 비교해서 **“진짜 같은 Key냐”**를 판단

---

### 1-3. HashSet은 사실 내부에 HashMap이 있다

HashSet 구현을 보면 (개념):

```java
public class HashSet<E> implements Set<E> {
    private transient HashMap<E, Object> map;
    private static final Object PRESENT = new Object();

    public boolean add(E e) {
        return map.put(e, PRESENT) == null;
    }
}
```

- **Set에 넣는 값(E)** → HashMap의 **Key**가 됨
- Value는 의미 없는 `PRESENT` 더미 객체

즉,

> **HashSet = 내부적으로 HashMap의 Key만 사용하는 구조**

그래서 **Set의 “중복 없음” 기준은**  
→ HashMap의 Key 비교 기준, 즉 **hashCode + equals** 이다.

---

## 2. hashCode / equals 역할 정리

### 2-1. 두 메서드의 역할 차이

| 메서드       | 역할                             | 비유                 |
|------------|----------------------------------|----------------------|
| `hashCode` | 어느 **버킷(사물함)**에 둘지 결정 | “몇 동에 사는지”     |
| `equals`   | 같은 버킷 안에서 **진짜 같은지**  | “같은 호수인지 확인” |

HashMap/HashSet 동작 흐름:

```text
1) key.hashCode() → table[index] 버킷 선택
2) 그 버킷에 들어 있는 Node들만 대상으로 key.equals(...) 비교
```

> **hashCode가 다르면** → 아예 다른 버킷 → equals 비교 기회도 없음  
> **hashCode가 같으면** → 같은 버킷 → 그 안에서 equals로 비교

---

### 2-2. “키가 같다”의 정확한 의미

HashMap에서 **“같은 Key”** 라는 건:

```text
(1) hashCode가 같고
(2) equals가 true
```

둘 다 만족해야 한다.

- 이때는 **기존 Value를 덮어쓴다** (`put` 호출 시)
- 그 외는 **다른 Key**로 취급

---

### 2-3. 세 가지 케이스 예시

```java
Key k1 = new Key(1);
Key k2 = new Key(1);
```

1. **hashCode 같고 equals도 true** → 진짜 같은 Key
   - 기존 값 덮어쓰기
2. **hashCode 같고 equals는 false** → 해시 충돌(다른 Key)
   - 같은 버킷 안 리스트에 추가 저장
3. **hashCode 다름** → 완전 다른 Key
   - 다른 버킷에 저장 → equals 비교 자체를 안 함

---

## 3. Set과 hashCode/equals 관계

### 3-1. Set의 중복 기준

HashSet은 내부적으로 HashMap을 쓰기 때문에:

- 요소 추가 시 → HashMap의 Key로 저장
- 중복 체크 기준:

```text
(1) hashCode 같고
(2) equals true
  → 같은 요소로 보고 add 안 함

둘 중 하나라도 다르면
  → 다른 요소로 보고 add 함 (중복 발생)
```

### 3-2. 잘못된 hashCode 구현 예시

```java
class User {
    String id;

    @Override
    public boolean equals(Object o) {
        return (o instanceof User) && Objects.equals(id, ((User)o).id);
    }

    @Override
    public int hashCode() {
        return new Random().nextInt(); // ❌ 매번 다른 값
    }
}

Set<User> set = new HashSet<>();
set.add(new User("A")); // hash = 100
set.add(new User("A")); // hash = -392822
System.out.println(set.size()); // 2 → 중복!
```

- 값은 같지만 **hashCode 다름**
- 서로 다른 버킷 → equals 비교 기회도 없음
- Set인데도 **중복 허용되는 꼴**

> 이게 JPA에서 **복합키 + Set + equals/hashCode 미구현**일 때 그대로 터지는 문제다.

---

## 4. JPA 영속성 컨텍스트와 HashMap

### 4-1. 영속성 컨텍스트(1차 캐시) 구조

Hibernate 기준으로 보면, JPA 영속성 컨텍스트는 개념적으로:

```java
Map<EntityKey, Object> persistenceContext;
```

- Key: `EntityKey`
  - 내부에 **엔티티 타입** + **식별자(PK)** 가 들어있음
- Value: 실제 엔티티 인스턴스

```java
class EntityKey {
    String entityName; // "com.example.Enrollment"
    Object identifier; // PK 값 (단일 PK or 복합키)

    @Override
    public boolean equals(Object o) { ... } // identifier.equals(...) 사용
    @Override
    public int hashCode() { ... }           // identifier.hashCode() 사용
}
```

> 결론: **식별자(PK) 객체의 equals/hashCode가 영속성 컨텍스트에 직결된다.**

특히 복합키(`@EmbeddedId`, `@IdClass`)를 쓰면  
**그 복합키 객체의 equals/hashCode가 그대로 들어감**.

---

### 4-2. em.find()가 동작하는 방식

```java
EnrollmentId id = new EnrollmentId(1L, 10L);
Enrollment e = em.find(Enrollment.class, id);
```

1. JPA가 내부적으로 `EntityKey("Enrollment", id)` 생성
2. `persistenceContext.get(key)` 호출
3. 있으면 → 1차 캐시에서 반환 (DB 조회 X)
4. 없으면 → DB에서 SELECT 후, Map에 put

#### 여기서 중요한 점

- Map의 Key 비교 → 결국 **identifier(복합키)의 equals/hashCode에 의존**
- equals/hashCode가 깨져 있으면
  - 같은 PK라도 **다른 Key**로 취급
  - 1차 캐시에 **같은 row에 대한 엔티티가 여러 개** 생김

---

## 5. 복합키(@EmbeddedId) 구조 예제

### 5-1. 복합키 클래스

```java
@Embeddable
public class EnrollmentId implements Serializable {

    private Long studentId;
    private Long courseId;

    protected EnrollmentId() {}

    public EnrollmentId(Long studentId, Long courseId) {
        this.studentId = studentId;
        this.courseId = courseId;
    }

    public Long getStudentId() { return studentId; }
    public Long getCourseId() { return courseId; }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof EnrollmentId)) return false;
        EnrollmentId that = (EnrollmentId) o;
        return Objects.equals(studentId, that.studentId) &&
               Objects.equals(courseId, that.courseId);
    }

    @Override
    public int hashCode() {
        return Objects.hash(studentId, courseId);
    }
}
```

### 5-2. 엔티티

```java
@Entity
public class Enrollment {

    @EmbeddedId
    private EnrollmentId id;

    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("studentId")
    @JoinColumn(name = "student_id")
    private Student student;

    @ManyToOne(fetch = FetchType.LAZY)
    @MapsId("courseId")
    @JoinColumn(name = "course_id")
    private Course course;

    private String grade;

    protected Enrollment() {}

    public Enrollment(Student student, Course course) {
        this.student = student;
        this.course = course;
        this.id = new EnrollmentId(student.getId(), course.getId());
    }
}
```

### 5-3. Student 엔티티(Set 사용)

```java
@Entity
public class Student {

    @Id @GeneratedValue
    private Long id;

    private String name;

    @OneToMany(mappedBy = "student",
               cascade = CascadeType.ALL,
               orphanRemoval = true)
    private Set<Enrollment> enrollments = new HashSet<>();

    public void addEnrollment(Enrollment enrollment) {
        enrollments.add(enrollment); // 여기서 hashCode/equals 사용
        enrollment.setStudent(this);
    }
}
```

- `Set<Enrollment>` 사용 → **중복 수강신청 방지**
- Set 내부는 **HashSet**, 즉 `hashCode + equals`로 중복 결정

---

## 6. MVC + Service + Repository + 영속성 컨텍스트 흐름

### 6-1. Repository

```java
public interface EnrollmentRepository
        extends JpaRepository<Enrollment, EnrollmentId> {

    List<Enrollment> findByStudentId(Long studentId);
}
```

Spring Data JPA가 내부적으로 EntityManager를 사용해서 구현.

개념적인 구현:

```java
public class SimpleEnrollmentRepository implements EnrollmentRepository {

    @PersistenceContext
    private EntityManager em;

    @Override
    public Optional<Enrollment> findById(EnrollmentId id) {
        Enrollment entity = em.find(Enrollment.class, id);
        return Optional.ofNullable(entity);
    }

    @Override
    public Enrollment save(Enrollment entity) {
        if (em.contains(entity) || entity.getId() != null) {
            return em.merge(entity);
        } else {
            em.persist(entity);
            return entity;
        }
    }
}
```

---

### 6-2. Service 계층

```java
@Service
@RequiredArgsConstructor
public class EnrollmentService {

    private final EnrollmentRepository enrollmentRepository;
    private final StudentRepository studentRepository;
    private final CourseRepository courseRepository;

    @Transactional
    public void enroll(Long studentId, Long courseId) {

        EnrollmentId id = new EnrollmentId(studentId, courseId);

        // 1) 이미 수강신청 되어 있는지 조회
        if (enrollmentRepository.findById(id).isPresent()) {
            throw new IllegalStateException("이미 수강 신청된 과목입니다.");
        }

        // 2) 엔티티 조회
        Student student = studentRepository.findById(studentId)
                .orElseThrow(() -> new IllegalArgumentException("학생 없음"));
        Course course = courseRepository.findById(courseId)
                .orElseThrow(() -> new IllegalArgumentException("과목 없음"));

        // 3) Enrollment 생성 및 연관관계 설정
        Enrollment enrollment = new Enrollment(student, course);
        student.addEnrollment(enrollment); // Set에 추가

        // 4) 저장
        enrollmentRepository.save(enrollment);
    }
}
```

---

### 6-3. Controller 계층

```java
@RestController
@RequiredArgsConstructor
public class EnrollmentController {

    private final EnrollmentService enrollmentService;

    @PostMapping("/enroll")
    public ResponseEntity<String> enroll(
            @RequestParam Long studentId,
            @RequestParam Long courseId) {

        enrollmentService.enroll(studentId, courseId);
        return ResponseEntity.ok("등록 완료");
    }
}
```

---

### 6-4. equals/hashCode가 제대로 구현된 경우 흐름

1. **findById(id)** → `em.find(Enrollment.class, id)`
   - 1차 캐시에서 동일 PK 엔티티가 있으면 재사용
2. **Set<Enrollment>에 add** → 중복이면 삽입 안 됨
3. **@Transactional 종료 시 flush**
   - 변경된 엔티티 + 컬렉션만 INSERT/UPDATE/DELETE

> **동일 PK = 항상 동일 엔티티 인스턴스**로 관리됨 → 안정적

---

## 7. equals/hashCode 미구현(잘못 구현) 시 복합키 문제

### 7-1. 기본 동작 (Object 기준)

equals/hashCode를 안 만들면:

```java
EnrollmentId id1 = new EnrollmentId(1L, 10L);
EnrollmentId id2 = new EnrollmentId(1L, 10L);

id1.equals(id2);          // false (주소 비교)
id1.hashCode()==id2.hashCode(); // 대부분 false
```

→ 값 같아도 **다른 객체**로 본다.

---

### 7-2. 문제 1: 같은 PK인데 1차 캐시에 엔티티 2개

```java
EnrollmentId id1 = new EnrollmentId(1L,10L);
Enrollment e1 = em.find(Enrollment.class, id1); // DB 조회 → 캐시에 저장

EnrollmentId id2 = new EnrollmentId(1L,10L);
Enrollment e2 = em.find(Enrollment.class, id2); // 또 DB 조회...
```

- 첫 번째 조회: `key1(id1)`로 Map에 저장
- 두 번째 조회: `key2(id2)`로 찾는데
  - `key1.hashCode() != key2.hashCode()`
  - `key1.equals(key2) == false`

→ 1차 캐시에서 못 찾음 → 다시 DB 조회 → 엔티티 `e2` 새로 생성

**결과:**

```text
persistenceContext:
 key1(id1) → e1
 key2(id2) → e2
```

- 같은 row인데 엔티티 두 개 관리
- Dirty Checking, merge, remove 전부 혼란

---

### 7-3. 문제 2: Set 컬렉션에서 중복 삽입

```java
Enrollment e1 = new Enrollment(student, course); // 내부 id1(1,10)
Enrollment e2 = new Enrollment(student, course); // 내부 id2(1,10)

Set<Enrollment> set = new HashSet<>();
set.add(e1);
set.add(e2); // 같은 PK인데 2개 저장
```

- `e1.hashCode()` → 내부에서 `id1.hashCode()` 사용 (A)
- `e2.hashCode()` → `id2.hashCode()` 사용 (B)
- A != B 이면 같은 Set 안에 **2개 다 들어감**

→ JPA 영속성 컨텍스트 & flush 시:

```sql
insert into enrollment (student_id, course_id, grade) values (1,10,'A');
insert into enrollment (student_id, course_id, grade) values (1,10,'A'); -- PK 중복
```

**결과:**

- DB PK 제약 위반 → `ConstraintViolationException`  
- 실제 운영에서 터지면 에러 페이지, 트랜잭션 롤백

---

### 7-4. 문제 3: Dirty Checking 실패 / 이상한 UPDATE

```java
Enrollment e1 = em.find(...); // grade=B
Enrollment e2 = em.find(...); // 같은 row지만 다른 인스턴스

e1.setGrade("A");
e2.setGrade("C");
```

- 어떤 엔티티를 기준으로 스냅샷/변경 비교를 할지 애매해짐
- 상황에 따라:
  - UPDATE가 1번만 나가서 값이 기대와 다르게 끝남
  - UPDATE가 2번 나가서 값이 롤백된 것처럼 보임
  - 심하면 Lock 경합, Deadlock까지 유발

---

### 7-5. 문제 4: merge / detach / remove 동작 꼬임

```java
Enrollment detached = ... // 준영속 상태 엔티티
em.merge(detached);
```

- 같은 PK 영속 엔티티를 못 찾고 새로 만들거나
- 잘못된 엔티티에 값 덮어쓰기
- remove 할 때도 1차 캐시에 남거나, DB에서만 지워지고 메모리에는 남는 식의 비일관성 발생

---

## 8. 락(lock)과 equals/hashCode의 관계 (요약)

- **락(lock)** 자체는 DB 트랜잭션/동시성 문제 (별개 개념)
- 다만, equals/hashCode가 깨져 있으면
  - 같은 row에 대해 **UPDATE/INSERT가 중복 발생**
  - 동시에 락이 2배, 3배 걸리는 셈 → **deadlock / timeout 위험↑**

결론:

> equals/hashCode는  
> **JPA 내부 논리(1차 캐시, 컬렉션, Dirty Checking)를 안정화**시키고,  
> 그 결과 락 문제 가능성도 **줄여주는 역할**을 한다.

---

## 9. equals/hashCode 구현 시 체크리스트

1. **복합키 클래스(@Embeddable, @IdClass)에는 무조건 구현**
   - 식별자 필드(예: `studentId`, `courseId`)만 사용
2. **엔티티에서 equals/hashCode를 구현할 경우**
   - 가급적 **식별자(PK)만 기준**으로
   - 연관관계 필드(다른 엔티티) 넣지 말 것 (무한 루프 위험)
3. **식별자 필드는 가능하면 불변처럼 사용**
   - PK 값 바뀌면 hashCode도 바뀌어서 Set/Map에서 못 찾는 문제 발생
4. Lombok 사용할 경우:

```java
@EqualsAndHashCode(onlyExplicitlyIncluded = true)
public class EnrollmentId {

    @EqualsAndHashCode.Include
    private Long studentId;

    @EqualsAndHashCode.Include
    private Long courseId;
}
```

---

## 10. 한 줄 요약들

- **HashMap / HashSet** 은 내부적으로 `hashCode → 버킷 선택 → equals로 최종판단` 구조
- **Set의 중복 기준**도 결국 HashMap Key 기준 → `hashCode + equals`
- **영속성 컨텍스트 1차 캐시**는 `Map<EntityKey, Entity>` 구조 → PK 객체의 equals/hashCode가 핵심
- **복합키에서 equals/hashCode 미구현** 시:
  - 같은 row에 대해 엔티티 여러 개
  - Set 컬렉션 중복 삽입
  - Dirty Checking/merge/remove 꼬임
  - PK 중복/무결성 에러
- **MVC + Service + Repository 구조에서**
  - Service는 `new 복합키` 만들어 Repository에 넘김
  - Repository는 내부적으로 EntityManager 사용
  - EntityManager는 1차 캐시 Map을 이용 → 이때 복합키 equals/hashCode가 제대로 되어 있어야 정상동작
- **락(lock)** 문제는 별개지만
  - equals/hashCode 버그로 UPDATE/INSERT 중복 발생 시
  - DB 락 경합/Deadlock 가능성이 크게 증가한다.


