# Tomcat/Proxy · Spring Security 인증 흐름 · 로그아웃 · JWT · Set-Cookie 수신까지 상세 정리


---

## 1. Tomcat이란 무엇인가

### 1.1 한 줄 정의
Tomcat은 **자바 웹 애플리케이션을 실행하는 WAS(Web Application Server)** 이다.  
HTTP 요청을 받아서 **Servlet/Filter를 실행**하고, Spring MVC의 `DispatcherServlet`을 호출해 컨트롤러까지 연결한다.

### 1.2 Tomcat이 담당하는 것
- HTTP 연결 수신 및 스레드 관리
- Servlet 실행 (`DispatcherServlet` 포함)
- Servlet Filter 실행
- HttpSession 생성/조회/만료
- 요청/응답 객체 생성 및 전달

### 1.3 Spring 요청 흐름(개념)
```text
Client
 → Tomcat(서버 소켓/스레드/HTTP 파싱)
 → Servlet Filter 체인
 → DispatcherServlet
 → Controller
 → Service/Repository
 → Response
```

---

## 2. Proxy란 무엇인가 (Forward / Reverse)

### 2.1 한 줄 정의
Proxy는 **요청을 대신 받아 다른 곳으로 전달하는 중개자**다.

### 2.2 Forward Proxy vs Reverse Proxy
- Forward Proxy: **클라이언트의 대리인** (회사망 프록시, 우회, 통제)
- Reverse Proxy: **서버의 대리인** (Nginx/HAProxy, 로드밸런싱, SSL 종료)

### 2.3 실무에서 Tomcat 앞에 Reverse Proxy(Nginx)를 두는 이유
- 보안: Tomcat 포트(예: 8080) 외부 노출 최소화
- HTTPS(SSL) 종료: 프록시에서 TLS 처리
- 정적 리소스 고속 처리: JS/CSS/Image는 Nginx가 효율적
- 로드밸런싱/무중단 배포: 다중 WAS로 트래픽 분산
- 라우팅: `/api`는 WAS, `/static`은 프록시 등 분리

---

## 3. SimpleGrantedAuthority("ROLE_" + role.getName())는 무엇인가

### 3.1 어디서 오는가
`SimpleGrantedAuthority`는 **Spring Security 제공 클래스**다.

```java
import org.springframework.security.core.authority.SimpleGrantedAuthority;
```

### 3.2 왜 필요한가
Spring Security는 권한을 문자열로 직접 비교하지 않고, `GrantedAuthority` 인터페이스로 다룬다.

```java
public interface GrantedAuthority {
    String getAuthority();
}
```

`SimpleGrantedAuthority`는 `"ROLE_ADMIN"` 같은 문자열 권한을 **GrantedAuthority 객체로 감싸는 기본 구현체**다.

### 3.3 ROLE_ 접두사 이유
- `hasRole("ADMIN")`은 내부적으로 `"ROLE_ADMIN"`을 찾는다.
- 따라서 DB에 `ADMIN`만 저장해도 코드에서 `"ROLE_" + name`으로 통일하는 방식이 흔하다.

---

## 4. UserDetailsService는 무엇인가

### 4.1 한 줄 정의
`UserDetailsService`는 **로그인 시 사용자 정보를 조회해 `UserDetails`로 반환하는 Spring Security 전용 인터페이스**다.

```java
public interface UserDetailsService {
    UserDetails loadUserByUsername(String username);
}
```

### 4.2 핵심 포인트
- “인증(비밀번호 비교)”을 하는 곳이 아니다.
- “사용자 조회 + 권한 로딩”을 담당한다.
- 일반적으로 **로그인 시점에 1회 호출**된다(세션 기반 기준).

---

## 5. 로그인 인증 흐름 (초상세)

아래 흐름은 Spring Security의 전형적인 폼 로그인/username-password 인증 기준이다.

```text
로그인 요청
 → Authentication Filter
 → AuthenticationManager
 → AuthenticationProvider
 → UserDetailsService.loadUserByUsername()
 → UserDetails 반환
 → 비밀번호 비교(PasswordEncoder.matches)
 → 인증 완료 Authentication 생성
 → SecurityContext 저장(세션이면 HttpSession에도 저장)
```

### 5.1 Authentication Filter가 하는 일
대표: `UsernamePasswordAuthenticationFilter`
- `/login` 요청을 가로채고
- username/password를 추출
- “인증 전” Authentication을 생성한다.

```java
Authentication authRequest =
    new UsernamePasswordAuthenticationToken(username, password);
// authenticated = false 상태
```

### 5.2 AuthenticationManager(ProviderManager)
- 여러 `AuthenticationProvider` 중에서 **현재 토큰 타입을 처리할 수 있는 provider**를 선택한다.

### 5.3 AuthenticationProvider(DaoAuthenticationProvider)
- `UserDetailsService`로 사용자 조회
- `PasswordEncoder.matches(raw, encoded)`로 비밀번호 비교
- 성공 시 “인증 완료 Authentication”을 생성한다.

```java
Authentication successAuth =
    new UsernamePasswordAuthenticationToken(userDetails, null, authorities);
// authenticated = true 상태
```

### 5.4 SecurityContext 저장
```java
SecurityContextHolder.getContext().setAuthentication(successAuth);
```

세션 기반이면 추가로 세션에 저장된다(개념):

```text
HttpSession
 └── SPRING_SECURITY_CONTEXT
      └── SecurityContext(Authentication 포함)
```

---

## 6. form 데이터 vs 쿼리 파라미터 차이

### 6.1 쿼리 파라미터
```http
GET /login?username=kim&password=1234
```

- URL에 노출
- 히스토리/로그/프록시에 남기 쉬움
- 민감정보 전송에 부적합

### 6.2 form 데이터(application/x-www-form-urlencoded)
```http
POST /login
Content-Type: application/x-www-form-urlencoded

username=kim&password=1234
```

- Body에 실림(주소창 노출 X)
- HTML `<form>` 기본 전송 방식
- “상태 변경” 성격(로그인/세션 생성)에 맞음

※ 서블릿 레벨에서는 `request.getParameter("username")`으로 읽는 방식이 유사해 보여도, **HTTP 의미/노출/로그 특성**이 다르다.

---

## 7. 세션 로그아웃하면 세션은 어떻게 되나

### 7.1 서버 측 핵심: invalidate
세션 기반 로그아웃의 본질은 **서버 세션 무효화**다.

```java
HttpSession session = request.getSession(false);
if (session != null) {
    session.invalidate();
}
```

- 서버 세션 저장소(메모리/Redis)의 세션 데이터가 삭제된다.
- `SPRING_SECURITY_CONTEXT` 포함 전부 제거된다.

### 7.2 쿠키(JSESSIONID)는 누가 “삭제”하나
서버가 브라우저 쿠키를 직접 지우는 게 아니다.  
서버는 응답 헤더로 “삭제해라”를 지시하고, 실제 삭제는 브라우저가 한다.

```http
Set-Cookie: JSESSIONID=; Max-Age=0; Path=/; HttpOnly
```

Spring Security 설정 예시:
```java
http.logout(logout -> logout
    .logoutUrl("/logout")
    .invalidateHttpSession(true)
    .deleteCookies("JSESSIONID")
);
```

---

## 8. 페이지 접근 시 권한 체크는 어떤 식으로 하나 (세션 기준)

### 8.1 권한 체크는 컨트롤러가 아니라 “필터 단계”에서 먼저 끝난다
대표적으로 다음 흐름이 일어난다(개념):

```text
요청
 → JSESSIONID 쿠키 전송
 → 세션 조회
 → SecurityContext 복원
 → Authentication 꺼냄
 → authorities 검사(hasRole/hasAuthority)
 → 통과 시 Controller 진입
```

### 8.2 URL 기반 설정 예시
```java
http.authorizeHttpRequests(auth -> auth
    .requestMatchers("/admin/**").hasRole("ADMIN")
    .anyRequest().authenticated()
);
```

- `hasRole("ADMIN")` → 내부적으로 `ROLE_ADMIN` 존재 여부 검사
- 기준 데이터는 세션의 SecurityContext 안에 있는 Authentication.authorities

### 8.3 @PreAuthorize는 언제?
`@PreAuthorize("hasRole('ADMIN')")`은 보통
- 필터 통과 후
- **메서드 실행 직전(AOP)** 추가 체크로 동작한다.

---

## 9. JWT 로그아웃/접근은 어떻게 달라지나

### 9.1 JWT에서 로그아웃이 “세션처럼” 즉시 invalidate가 어려운 이유
JWT는 보통 **서버가 상태를 저장하지 않는(stateless)** 방식이다.
- 세션처럼 서버 저장소에 지울 “세션 객체”가 없다.
- 따라서 “로그아웃”은 정책적으로 구현한다.

### 9.2 JWT 접근 흐름(개념)
```text
요청
 → Authorization: Bearer <token> (또는 쿠키)
 → JWT 필터가 토큰 추출/검증(서명/만료)
 → claim에서 roles 추출
 → GrantedAuthority 생성
 → Authentication 생성
 → SecurityContextHolder에 저장
 → hasRole 검사
```

### 9.3 JWT 로그아웃의 실무 패턴
1) 단순(stateless) 로그아웃
- 프론트: access token 삭제
- 서버: 별도 처리 없음
- 토큰이 남아 있고 유효하면, 보내는 순간 다시 인증됨

2) Refresh Token 기반(권장)
- Refresh Token을 서버(DB/Redis)에 저장/폐기
- 로그아웃 시 Refresh Token 폐기 + 쿠키 삭제 지시
- Access Token은 짧게 운영

3) 블랙리스트(즉시 차단 필요 시)
- 로그아웃 토큰을 블랙리스트 저장
- 매 요청마다 조회 (운영 비용 증가)

---

## 10. Set-Cookie는 Body로 보내는가?

아니다. **Set-Cookie는 HTTP 응답 헤더**다.

```http
HTTP/1.1 200 OK
Set-Cookie: refreshToken=abc123; HttpOnly; Path=/; Secure; SameSite=None
Content-Type: application/json

{ "message": "ok" }
```

- `Set-Cookie`는 Response Header
- JSON은 Response Body

Body에 `"setCookie": "..."`를 넣어도 브라우저가 쿠키로 저장하지 않는다.

---

## 11. 프론트는 Set-Cookie를 “어떻게 받는가”

핵심:
- 프론트(JS)가 Set-Cookie를 파싱해서 저장하지 않는다.
- **브라우저가 자동으로 쿠키 저장/삭제**한다.

### 11.1 HttpOnly 쿠키는 JS로 확인 불가
- `document.cookie`에 안 보이는 것이 정상이다.
- 확인은 개발자도구(Application/Storage 탭)에서 하거나,
- 다음 요청에 쿠키가 자동 첨부되는지로 판단한다.

### 11.2 CORS 환경에서 꼭 필요한 옵션(fetch/axios)
다른 도메인 API 호출에서 쿠키를 주고받으려면:

fetch:
```js
fetch("https://api.example.com/logout", {
  method: "POST",
  credentials: "include"
});
```

axios:
```js
axios.post("https://api.example.com/logout", {}, {
  withCredentials: true
});
```

서버도 다음을 맞춰야 한다:
- `Access-Control-Allow-Credentials: true`
- `Access-Control-Allow-Origin: https://frontend.example.com` (별표 * 금지)

---

## 12. 핵심 결론 요약

- Tomcat: 자바 웹 실행(WAS), Filter/Session/Servlet 실행 주체
- Reverse Proxy: Tomcat 앞단에서 보안/SSL/정적/로드밸런싱 담당
- 권한은 `GrantedAuthority`로 관리되며 보통 `SimpleGrantedAuthority` 사용
- UserDetailsService: 로그인 시 사용자 조회(인증 판단은 Provider)
- 로그인 흐름: Filter → Manager → Provider → UserDetailsService → PasswordEncoder → Authentication 생성
- 세션 로그아웃: 서버 세션 invalidate + 브라우저에 Set-Cookie로 쿠키 삭제 지시
- 세션 권한 체크: 필터에서 SecurityContext(Authentication.authorities)로 URL/메서드 권한 검사
- JWT 로그아웃: 기본은 토큰 삭제(서버는 모름), 실무는 refresh 토큰 통제/회전
- Set-Cookie: Body가 아니라 Response Header, 브라우저가 자동 저장/삭제
