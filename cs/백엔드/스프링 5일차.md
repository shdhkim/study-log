# JPA, Spring Data JPA, 트랜잭션, 영속성 컨텍스트 CRUD 동작 흐름 정리

## 전체 흐름 개요

```
Controller → Service (@Transactional)
        ↓
Repository (Spring Data JPA)
        ↓
SimpleJpaRepository (구현체)
        ↓
EntityManager(JPA)
        ↓
영속성 컨텍스트 (1차 캐시, 변경 감지, 쓰기 지연)
        ↓
DB (SQL 실행)
```

- Service 단에서 CRUD 호출
- Repository가 EntityManager 사용
- EntityManager가 영속성 컨텍스트 관리
- 트랜잭션 종료 시 flush(쓰기 지연) 후 commit

---

## 예제 도메인

### Entity

```java
@Entity
public class Comment {

    @Id
    @GeneratedValue
    private Long id;

    private String username;
    private String content;

}
```

### Repository

```java
public interface CommentRepository extends JpaRepository<Comment, Long> {
    List<Comment> findByUsername(String username);
}
```

---

## Service 계층 코드

```java
@Service
public class CommentService {

    private final CommentRepository commentRepository;

    public CommentService(CommentRepository commentRepository) {
        this.commentRepository = commentRepository;
    }

    @Transactional
    public Comment create(String username, String content) {
        Comment comment = new Comment();
        comment.setUsername(username);
        comment.setContent(content);

        return commentRepository.save(comment);
    }

    @Transactional(readOnly = true)
    public Comment get(Long id) {
        return commentRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("not found"));
    }

    @Transactional
    public Comment update(Long id, String newContent) {
        Comment comment = commentRepository.findById(id)
                .orElseThrow(() -> new RuntimeException("not found"));

        comment.setContent(newContent);

        return comment;
    }

    @Transactional
    public void delete(Long id) {
        commentRepository.deleteById(id);
    }
}
```

---

## CRUD별 내부 동작 상세

### 1. Create: save() → persist()

```java
commentRepository.save(comment);
```

내부 절차:

1. @Transactional 시작  
2. EntityManager 생성 및 영속성 컨텍스트 바인딩  
3. save() → SimpleJpaRepository.save()
4. id 없음 → persist() 호출
5. INSERT SQL은 flush 시점에 실행
6. commit 시 DB 저장 완료

상태 변화:

```
비영속 → persist() → 영속
```

---

### 2. Read: findById() → 1차 캐시 또는 DB 조회

절차:

1. 영속성 컨텍스트의 1차 캐시 조회
2. 없으면 DB 조회
3. 조회된 엔티티를 영속 상태로 저장
4. 동일 트랜잭션 내에서 동일 ID는 동일 객체 반환

---

### 3. Update: 변경 감지(Dirty Checking)

```java
comment.setContent(newContent);
```

절차:

1. 영속 상태 엔티티 값 변경
2. flush 시점에 스냅샷과 비교
3. UPDATE SQL 자동 실행

save() 호출 불필요

---

### 4. Delete: deleteById() → remove()

절차:

1. findById()로 영속 상태 조회
2. remove() 호출
3. flush 시점에 DELETE SQL 실행
4. commit

---

## 영속성 컨텍스트 개념

JPA가 관리하는 엔티티 저장소(1차 캐시)

기능 요약:

| 기능 | 설명 |
|------|------|
| 1차 캐시 | 메모리에서 엔티티 우선 조회 |
| 동일성 보장 | 같은 트랜잭션에서 같은 엔티티는 동일 객체 |
| 변경 감지 | Setter로 값만 바꿔도 UPDATE 자동 수행 |
| 쓰기 지연 | SQL은 트랜잭션 종료 시점에 실행 |

---

## 트랜잭션과 영속성 컨텍스트 관계

### 기본 전략

```
트랜잭션 1개 = 영속성 컨텍스트 1개
```

수명:

```
트랜잭션 시작
 ↓
영속성 컨텍스트 활성
 ↓
비즈니스 로직 수행
 ↓
flush → commit
 ↓
영속성 컨텍스트 종료
```

---

## 핵심 정리

```
Service 계층에서 CRUD 수행
  ↓
Repository는 SimpleJpaRepository 구현체 사용
  ↓
SimpleJpaRepository는 EntityManager를 호출
  ↓
EntityManager는 영속성 컨텍스트 관리
  ↓
트랜잭션 종료 시 flush → SQL 실행 → commit
```

---

## 참고 요약

| 동작 | EntityManager 메서드 | Spring Data JPA 메서드 |
|------|-------------------|---------------------|
| 생성 | persist() | save() |
| 수정 | 변경 감지 또는 merge() | save() 또는 변경 감지 |
| 삭제 | remove() | delete(), deleteById() |
| 조회 | find() / JPQL | findById(), findBy...() |
```
