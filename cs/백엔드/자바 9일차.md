# Java 함수형 인터페이스 / Comparator 정리

## 1. 함수형 인터페이스(Functional Interface)란?

### 1) 정의
- **추상 메서드가 정확히 1개**인 인터페이스
- 그 “1개 추상 메서드”를 **SAM(Single Abstract Method)** 이라고 부른다.
- 람다식/메서드참조는 결국 **SAM을 구현한 객체**로 변환된다.

```java
@FunctionalInterface
interface MyFunc {
    int apply(int x); // 추상 메서드 1개(SAM)
}
```

### 2) default/static 메서드는 있어도 된다
- **추상 메서드 개수만** 센다.
- default/static은 “추상 메서드”가 아니다.

```java
@FunctionalInterface
interface Calc {
    int calc(int a, int b); // 추상 메서드 1개

    default void log() { System.out.println("log"); } // OK
    static void help() { System.out.println("help"); } // OK
}
```

---

## 2. Comparator는 함수형 인터페이스인가?

### 결론: 맞다
`Comparator<T>`는 **추상 메서드가 `compare` 하나뿐**이라서 함수형 인터페이스다.

```java
@FunctionalInterface
public interface Comparator<T> {
    int compare(T o1, T o2);   // 추상 메서드 1개(SAM)

    // default/static 메서드들 (추상 메서드 아님)
    default Comparator<T> reversed() { ... }
    default Comparator<T> thenComparing(...) { ... }
    static <T, U extends Comparable<? super U>>
    Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor) { ... }
}
```

### 그래서 sort에 람다를 바로 넣을 수 있다
`List.sort`는 `Comparator`를 받는다.

```java
// List<E>#sort
void sort(Comparator<? super E> c)
```

람다를 넣으면, 그 람다는 `Comparator#compare`로 매칭된다.

```java
users.sort((a, b) -> Integer.compare(a.getAge(), b.getAge()));
```

위 코드는 내부적으로 이런 익명클래스 형태로 바뀌는 것과 같다.

```java
users.sort(new Comparator<User>() {
    @Override
    public int compare(User a, User b) {
        return Integer.compare(a.getAge(), b.getAge());
    }
});
```

---

## 3. Comparator.comparing(User::getAge)가 왜 되는가?

### 1) comparing의 시그니처(핵심)
`Comparator.comparing(...)`은 “정렬 키를 뽑는 함수”를 받는다.

```java
static <T, U extends Comparable<? super U>>
Comparator<T> comparing(Function<? super T, ? extends U> keyExtractor)
```

즉,
- `T` = 정렬 대상 타입 (예: User)
- `U` = 키 타입 (예: Integer)
- 인자 = `Function<T, U>` (예: Function<User, Integer>)

### 2) User::getAge가 Function<User, Integer>로 맞는 이유
`User::getAge`는 “인스턴스 메서드 참조”다.

- 목표 타입이 `Function<User, Integer>`라면 SAM은 `apply(User u)`다.

```java
@FunctionalInterface
interface Function<T, R> {
    R apply(T t);
}
```

따라서 `User::getAge`는 아래와 같은 의미로 해석된다.

```java
Function<User, Integer> f = (User u) -> u.getAge();
```

즉, **입력(User)이 “호출 주체(리시버)” 역할**을 해준다.

---

## 4. “반환값이 있으면 변수가 있어야 한다”의 정확한 의미

사용자가 말한 “함수에 반환값이 존재하면 변수가 있어야 한다”를
자바 람다/메서드참조 문맥에서 정확히 풀면 아래가 핵심이다.

### 핵심 문장
- **인스턴스 메서드**를 호출하려면, 반드시 **호출 주체(객체)** 가 필요하다.
- 메서드 참조 `User::getAge`에서 그 “호출 주체(객체)”는
  **람다/함수형 인터페이스의 입력 파라미터가 대신 제공**한다.

즉,
- `u.getAge()`는 `u`라는 객체 변수가 있어야 실행 가능
- `User::getAge`는 “나중에 입력으로 들어올 User(u)를 받아서 u.getAge() 하겠다”라는 뜻

### 비교로 이해하기

#### (A) 인스턴스 메서드 호출 (지금 당장 실행)
```java
User u = new User(...);
int age = u.getAge(); // 호출 주체 u가 필요
```

#### (B) 인스턴스 메서드 참조 (나중에 실행될 “함수”로 표현)
```java
Function<User, Integer> f = User::getAge;
// f.apply(u) 호출 시점에 u.getAge()가 실행됨
```

여기서 “변수가 있어야 한다”는 말은,
- `getAge()`는 인스턴스 메서드라서 **u(호출 주체)가 없으면 실행 자체가 불가**
- 메서드 참조에서는 그 u를 **입력 파라미터**가 맡아준다

---

## 5. static 메서드 참조 vs 인스턴스 메서드 참조

### 1) static 메서드: 호출 주체가 필요 없다
`Integer.parseInt(String)`은 static이다.
따라서 “어떤 객체 변수”가 없어도 된다.

```java
Function<String, Integer> f = Integer::parseInt;
```

이는 아래와 동일하다.

```java
Function<String, Integer> f = (String s) -> Integer.parseInt(s);
```

### 2) 인스턴스 메서드: 호출 주체가 필요하다
`User.getAge()`는 인스턴스 메서드다.

```java
Function<User, Integer> f = User::getAge;
```

이는 아래와 동일하다.

```java
Function<User, Integer> f = (User u) -> u.getAge();
```

---

## 6. “함수 호출 결과”와 “함수 자체”를 구분해야 한다

### 1) 함수 자체 (메서드 참조 / 람다)
- 아직 실행하지 않고, “나중에 실행할 동작”을 값처럼 넘기는 것
- 함수형 인터페이스 자리에 들어갈 수 있다

```java
Function<User, Integer> f = User::getAge; // 함수 자체
```

### 2) 함수 호출 결과 (값)
- 지금 실행해서 결과값이 나오는 것
- 함수형 인터페이스 자리에 들어갈 수 없다

```java
User u = new User(...);
// Comparator.comparing은 Function을 요구하는데,
// u.getAge()는 이미 실행된 int(값)이다.
users.sort(Comparator.comparing(u.getAge())); // 컴파일 불가
```

---

## 7. Comparator.comparing이 “Function을 받는다”는 게 무슨 뜻인가?

### 키 추출 함수가 필요하다는 뜻
정렬은 결국 이런 형태다.

- “각 원소에서 키를 뽑는다”
- “키를 비교해서 순서를 정한다”

```java
Comparator<User> c =
    Comparator.comparing(User::getAge); // 키 뽑기: User -> Integer

users.sort(c);
```

즉 `comparing`은 내부적으로 이런 작업을 한다고 보면 된다.

```java
Comparator<User> c = (a, b) -> {
    Integer ka = a.getAge();
    Integer kb = b.getAge();
    return ka.compareTo(kb);
};
```

---

## 8. 실전 예시 3종 세트

### 1) 나이 오름차순
```java
users.sort(Comparator.comparing(User::getAge));
```

### 2) 나이 내림차순
```java
users.sort(Comparator.comparing(User::getAge).reversed());
```

### 3) 나이 → 이름 순으로 정렬(2차 정렬)
```java
users.sort(
    Comparator.comparing(User::getAge)
              .thenComparing(User::getName)
);
```

---

## 9. 최종 요약

1. `Comparator<T>`는 추상 메서드가 `compare` 하나라서 **함수형 인터페이스**다.
2. `List.sort(Comparator)`는 Comparator를 받으므로 **람다/메서드 참조**를 직접 넣을 수 있다.
3. `Comparator.comparing(...)`은 내부적으로 **Function<T, U> (키 추출 함수)** 를 요구한다.
4. `User::getAge`는 인스턴스 메서드 참조이며,
   입력(User)이 곧 호출 주체가 되어 `u.getAge()`로 실행된다.
5. “반환값이 있으면 변수가 있어야 한다”의 본질은
   **인스턴스 메서드는 호출 주체(객체)가 반드시 필요**하다는 의미다.
6. `User::getAge`는 “함수 자체”, `u.getAge()`는 “함수 호출 결과(값)”이므로
   함수형 인터페이스 자리에 들어갈 수 있는 건 전자다.
