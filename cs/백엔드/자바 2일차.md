# Java Collection / Wrapper / Boxing / Copy 정리 

## 0. 핵심 요약
- 얕은 복사: 컨테이너만 복사, 내부 객체 참조 공유
- 깊은 복사: 컨테이너 + 내부 객체까지 모두 복사
- ArrayList 생성자 복사는 얕은 복사
- Integer, String은 불변 객체라 얕은 복사여도 안전해 보일 뿐 원리는 동일

---

## 1. 얕은 복사 (Shallow Copy)

### 1.1 참조 복사 (가장 위험)

```java
ArrayList<Box> a = new ArrayList<>();
ArrayList<Box> b = a;
```

- a와 b는 완전히 같은 리스트
- 내부 요소, 구조 전부 공유

```java
b.get(0).value = 10;
```

→ a도 함께 변경됨

---

### 1.2 ArrayList 생성자 복사

```java
ArrayList<Box> a = new ArrayList<>();
a.add(new Box());

ArrayList<Box> b = new ArrayList<>(a);
```

- 리스트 객체는 새로 생성
- 내부 Box 객체는 동일 참조

```java
b.get(0).value = 10;
```

→ a.get(0).value 역시 10

---

### 1.3 얕은 복사 메모리 구조

```
a ──▶ [ Box(value=0) ]
b ──▶ [ ───────────▲ ]
```

---

## 2. 깊은 복사 (Deep Copy)

### 2.1 수동 깊은 복사 (가장 명확)

```java
ArrayList<Box> deep = new ArrayList<>();

for (Box box : a) {
    Box copy = new Box();
    copy.value = box.value;
    deep.add(copy);
}
```

- 내부 객체까지 완전히 새로 생성
- 서로 영향 없음

---

### 2.2 clone() 기반 깊은 복사

```java
class Box implements Cloneable {
    int value;

    @Override
    protected Box clone() {
        try {
            return (Box) super.clone();
        } catch (CloneNotSupportedException e) {
            throw new RuntimeException(e);
        }
    }
}

ArrayList<Box> deep = new ArrayList<>();
for (Box box : a) {
    deep.add(box.clone());
}
```

---

### 2.3 깊은 복사 메모리 구조

```
a    ──▶ [ Box(value=0) ]
deep ──▶ [ Box(value=0) ]
```

---

## 3. Integer / String은 왜 예외처럼 보이는가?

```java
ArrayList<Integer> a = new ArrayList<>();
a.add(10);

ArrayList<Integer> b = new ArrayList<>(a);
b.set(0, 20);
```

- a는 여전히 10
- 이유: Integer는 불변 객체 (immutable)

참조는 공유되지만 내부 값 변경 불가

---

## 4. get()으로 값 변경 가능 여부

### 4.1 불가능 (Integer)

```java
Integer x = list.get(0);
x = 20;
```

- x만 새 객체를 가리킴
- 리스트 내부는 변화 없음

```java
list.get(0) = 20; // 컴파일 에러
```

---

### 4.2 가능 (mutable 객체)

```java
class Box {
    int value;
}

list.get(0).value = 10;
```

- get() → 참조 반환
- 필드 수정 → 객체 상태 변경

---

## 5. ArrayList.get() 내부 구조

```java
class ArrayList<E> {
    Object[] elementData;

    public E get(int index) {
        return (E) elementData[index];
    }
}
```

- 참조 그대로 반환
- 보호 로직 없음
- 복사 없음

---

## 6. String / Integer / new 차이

### 6.1 String Pool

```java
String a = "hello";
String b = "hello";
a == b // true
```

```java
String a = new String("hello");
String b = new String("hello");
a == b // false
```

---

### 6.2 Integer Cache

```java
Integer a = 100;
Integer b = 100;
a == b // true
```

```java
Integer a = new Integer(100);
Integer b = new Integer(100);
a == b // false
```

---

## 7. Boxing / Auto Boxing

### 7.1 박싱
```java
int a = 10;
Integer b = Integer.valueOf(a);
```

### 7.2 오토박싱
```java
Integer b = 10;
```

컴파일러 변환:
```java
Integer b = Integer.valueOf(10);
```

---

### 7.3 언박싱
```java
Integer b = 10;
int a = b;
```

---

## 8. 얕은 복사 vs 깊은 복사 비교표

| 구분 | 얕은 복사 | 깊은 복사 |
|---|---|---|
| 컨테이너 | 새 객체 | 새 객체 |
| 내부 객체 | 참조 공유 | 새 객체 |
| 부작용 위험 | 높음 | 없음 |
| 성능 | 빠름 | 느릴 수 있음 |
| 사용 예 | Integer, String | Entity, DTO |

---

## 9. 실무 기준 정리

- Integer, String → 얕은 복사 OK
- DTO, Entity → 깊은 복사 필요
- get()은 항상 참조 반환
- 값 교체는 set(), 상태 변경은 필드 접근

---

## 10. 결론

얕은 복사는 참조를 공유하는 복사이고  
깊은 복사는 객체 자체를 새로 만드는 복사다.
