# Java Collection / Wrapper / Boxing / Copy 정리 

## 0. 핵심 요약
- 얕은 복사: 컨테이너만 복사, 내부 요소(객체)는 참조 공유
- 깊은 복사: 컨테이너 + 내부 객체까지 모두 새로 생성
- `new ArrayList<>(list)`는 "컨테이너만" 복사하므로 기본적으로 얕은 복사
- `get(index)`는 **항상 읽기(참조 반환)만 가능**하며, `get(index) = ...` 형태의 대입은 **타입이 무엇이든 불가능**
- `Integer`는 불변 객체라 얕은 복사여도 안전해 보일 뿐 원리는 동일
- `Integer Cache`(정수 캐시)와 `String Pool`(문자열 풀) 때문에 `==` 결과가 헷갈릴 수 있음 → 값 비교는 `equals()`가 정답

---

## 1. 얕은 복사 (Shallow Copy)

### 1.1 참조 복사 (가장 위험)
```java
ArrayList<Box> a = new ArrayList<>();
ArrayList<Box> b = a;
```
- a와 b는 완전히 같은 리스트(같은 주소)
- 구조/요소/수정 전부 공유

---

### 1.2 ArrayList 생성자 복사 (컨테이너만 복사)
```java
ArrayList<Box> a = new ArrayList<>();
a.add(new Box());

ArrayList<Box> b = new ArrayList<>(a);
```
- 리스트 객체는 새로 생성
- 내부 Box 객체는 동일 참조(공유)

#### 얕은 복사 메모리 구조
```
a ──▶ [ Box(value=0) ]
b ──▶ [ ───────────▲ ]  (같은 Box)
```

---

## 2. 깊은 복사 (Deep Copy)

### 2.1 수동 깊은 복사 (가장 명확)
```java
ArrayList<Box> deep = new ArrayList<>();

for (Box box : a) {
    Box copy = new Box();
    copy.value = box.value;   // 내부 값까지 복사
    deep.add(copy);
}
```

#### 깊은 복사 메모리 구조
```
a    ──▶ [ Box(value=0) ]
deep ──▶ [ Box(value=0) ]  (다른 Box)
```

---

## 3. `get(index)`는 왜 "대입"이 안 되는가? (Integer뿐 아니라 객체도 동일)

### 3.1 `get(0) = ...`는 어떤 타입이어도 불가능
다음 코드는 **Box여도, Integer여도, String이어도 모두 컴파일 에러**다.

```java
list.get(0) = new Box();  // 불가능
list.get(0) = 4;          // 불가능
```

#### 이유(핵심)
- `list.get(0)`는 **메서드 호출의 반환값(return value)** 이다.
- 자바에서 대입 연산자 `=`의 왼쪽(좌변)은 **변수/필드/배열 원소처럼 "저장 위치"를 가리켜야** 한다.
- 메서드 호출 결과는 저장 위치가 아니라 "값"이므로 좌변이 될 수 없다.

즉,
- 배열은 `arr[0] = 4;` 가능 (저장 위치)
- 리스트는 `list.set(0, 4);`만 가능 (메서드로 교체)

---

### 3.2 그럼 왜 `list.get(0).value = 10`은 가능한가?
```java
class Box { int value; }

ArrayList<Box> list = new ArrayList<>();
list.add(new Box());

list.get(0).value = 10; // 가능
```

#### 이유
- `list.get(0)`은 Box **참조**를 반환 (읽기)
- 그 다음 `.value`는 Box 객체 내부의 **필드(저장 위치)** 를 가리킨다
- 즉, 대입의 좌변이 되는 것은 `get(0)`이 아니라 **`value` 필드**다

정리하면:
- `get(0)` 자체는 읽기만 한다 (참조 반환)
- 바뀌는 것은 "그 참조가 가리키는 객체의 상태" (mutable일 때만)

---

### 3.3 Integer에서는 왜 `.value`가 안 보이고 수정이 불가능한가?
Integer는 개념적으로 이런 구조다.

```java
public final class Integer {
    private final int value;
}
```

- `value` 필드는 `private` + `final` → 외부 접근/수정 불가
- setter도 없음
- 그래서 `list.get(0).value = ...` 같은 문법 자체가 성립하지 않는다

---

## 4. ArrayList.get() 내부 구조 (핵심만)
```java
class ArrayList<E> {
    Object[] elementData;

    public E get(int index) {
        return (E) elementData[index];
    }
}
```
- `get()`은 elementData 배열에서 **참조를 꺼내서 그대로 반환**한다
- 보호/복사/래핑 없음
- 반환된 객체가 mutable이면 그 내부 상태는 바뀔 수 있다

---

## 5. Integer Cache(정수 캐시) 상세 설명

### 5.1 왜 Integer Cache가 존재하나?
- 작은 정수는 프로그램에서 매우 자주 등장(루프 인덱스, 카운터 등)
- 매번 객체를 새로 만들면 비용이 크므로, **자주 쓰는 범위를 미리 만들어 재사용**한다

---

### 5.2 어떤 코드가 캐시를 타는가?
#### 오토박싱(또는 `Integer.valueOf`)은 캐시를 고려한다
```java
Integer a = 100;              // 오토박싱 → Integer.valueOf(100)
Integer b = Integer.valueOf(100);
```

- 이 경우 캐시 범위라면 같은 객체를 재사용할 수 있다

#### `new Integer(...)`는 캐시를 무조건 무시한다
```java
Integer a = new Integer(100);
Integer b = new Integer(100);
```

- 항상 새 객체 생성
- 그래서 `new Integer()`는 현대 자바에서 권장되지 않으며(deprecated), 보통 `valueOf()`를 사용한다

---

### 5.3 캐시 범위는?
- 일반적으로 **-128 ~ 127** 범위가 기본 캐시로 자주 언급된다
- 다만 JVM 옵션에 따라 상한이 확장될 수 있다 (환경/설정에 따라 달라질 수 있음)
- 따라서 `==` 결과를 캐시 범위로만 추론하면 실무에서 사고가 난다

---

### 5.4 `==` 비교가 왜 위험한가? (캐시 때문에 헷갈림)

#### (1) 캐시 범위일 때
```java
Integer a = 100;
Integer b = 100;
System.out.println(a == b);        // true가 나올 수 있음 (캐시 재사용)
System.out.println(a.equals(b));   // true (값 비교)
```

#### (2) 캐시 범위를 벗어날 때
```java
Integer a = 1000;
Integer b = 1000;
System.out.println(a == b);        // false가 나올 수 있음 (서로 다른 객체)
System.out.println(a.equals(b));   // true (값 비교)
```

#### 결론
- wrapper 비교는 무조건 `equals()`로 한다
- `==`는 "같은 객체(참조)인가?"를 묻는 연산이다

---

### 5.5 컬렉션 복사와 캐시는 별개지만, 함께 헷갈리기 쉬움
```java
ArrayList<Integer> a = new ArrayList<>();
a.add(100);

ArrayList<Integer> b = new ArrayList<>(a);
```

- b의 0번 요소는 a의 0번 요소와 같은 Integer 객체 참조일 수 있다
- 하지만 Integer는 immutable이므로 "그 객체의 내부 값"을 바꿀 수가 없다
- 바꾸려면 `set()`으로 **참조 교체**만 가능

```java
b.set(0, 200); // b[0]이 가리키는 참조를 새 Integer로 교체
```

---

## 6. String Pool vs Integer Cache 차이(짧게 정리)

### 6.1 String Pool
- 문자열 리터럴 `"hello"`는 풀에 저장되어 재사용될 수 있다
- `new String("hello")`는 항상 새 객체

### 6.2 Integer Cache
- `Integer.valueOf(x)`(오토박싱 포함)는 캐시를 사용할 수 있다
- `new Integer(x)`는 항상 새 객체

---

## 7. Boxing / Auto Boxing (필수 개념)

### 7.1 오토박싱
```java
Integer x = 10;  // 컴파일러가 Integer.valueOf(10)로 변환
```

### 7.2 오토언박싱
```java
Integer x = 10;
int y = x;       // 컴파일러가 x.intValue()로 변환
```

---

## 8. 오토박싱 주의사항

### 8.1 Null 언박싱 NPE
```java
Integer x = null;
int y = x; // NPE (x.intValue() 호출)
```

### 8.2 성능: 반복문에서 wrapper 누적 금지
```java
Integer sum = 0;
for (int i = 0; i < 1_000_000; i++) {
    sum += i; // 매번 언박싱 + 새 Integer 생성(개념상)
}
```
- 누적/연산은 primitive로

---

## 9. 얕은 복사 vs 깊은 복사 비교표

| 구분 | 얕은 복사 | 깊은 복사 |
|---|---|---|
| 컨테이너 | 새 객체 | 새 객체 |
| 내부 요소(객체) | 참조 공유 | 새 객체 생성 |
| 부작용 위험 | mutable이면 높음 | 낮음 |
| 성능 | 빠름 | 느릴 수 있음 |
| 실무 예 | 불변 값 객체는 얕은 복사 OK | Entity/DTO는 목적에 따라 깊은 복사 고려 |

---

## 10. 최종 결론
- `get()`은 항상 읽기(참조 반환)만 하고, `get() = ...`는 타입과 무관하게 불가능
- 객체 상태 변경은 `get()` 이후 "필드"를 바꾸는 형태로만 가능(mutable일 때만)
- Integer Cache 때문에 `==` 결과가 헷갈릴 수 있으므로 wrapper 비교는 `equals()`로 한다
