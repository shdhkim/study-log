# Java Set 예시, StringBuilder vs String 차이, Stream 예시 정리

## 1) Java `Set` 기본 개념
`Set`은 **중복을 허용하지 않고**, (대부분의 구현에서) **순서를 보장하지 않는** 컬렉션입니다.

- 중복 제거가 핵심
- 포함 여부 검사(`contains`)가 빈번할 때 유용
- 대표 구현체: `HashSet`, `LinkedHashSet`, `TreeSet`

---

## 2) `Set` 예시 모음

### 2.1 HashSet: 가장 흔한 기본 선택
- 평균적으로 `add/contains/remove`가 **O(1)** (해시 기반)
- 순서 보장 없음

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Set<String> set = new HashSet<>();

        set.add("apple");
        set.add("banana");
        set.add("apple"); // 중복: 무시됨

        System.out.println(set.size());           // 2
        System.out.println(set.contains("apple")); // true

        for (String s : set) { // 순서는 랜덤일 수 있음
            System.out.println(s);
        }
    }
}
```

#### 자주 헷갈리는 포인트
- `add()`는 **새로 추가되면 true**, 이미 있으면 false
```java
boolean a = set.add("a"); // true
boolean b = set.add("a"); // false (중복)
```

---

### 2.2 LinkedHashSet: 입력 순서를 유지하고 싶을 때
- 중복 제거 + **삽입 순서 유지**
- 해시 기반이라 평균 성능은 `HashSet`과 유사

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Set<Integer> set = new LinkedHashSet<>();

        set.add(3);
        set.add(1);
        set.add(2);
        set.add(1); // 중복 제거

        System.out.println(set); // [3, 1, 2] (삽입 순서 유지)
    }
}
```

---

### 2.3 TreeSet: 정렬된 Set
- 요소가 **정렬된 상태로 유지**
- 내부적으로 균형 이진 트리 기반이라 `add/contains/remove`는 **O(log N)**

```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Set<Integer> set = new TreeSet<>();

        set.add(5);
        set.add(1);
        set.add(3);

        System.out.println(set); // [1, 3, 5]
    }
}
```

#### TreeSet + 커스텀 정렬(Comparator)
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        Set<String> set = new TreeSet<>(
            Comparator.comparingInt(String::length)
                      .thenComparing(Comparator.naturalOrder())
        );

        set.add("bbb");
        set.add("a");
        set.add("cc");
        set.add("dd");
        set.add("a"); // 중복 제거

        System.out.println(set); // [a, cc, dd, bbb]
    }
}
```

---

### 2.4 `Set`의 핵심: `equals()` / `hashCode()` 오버라이딩
`HashSet`/`LinkedHashSet`은 **hashCode → equals** 순으로 중복 여부를 판단합니다.

#### 올바른 예시 (불변 키 권장)
```java
import java.util.*;

class User {
    private final String id; // 불변

    public User(String id) {
        this.id = id;
    }

    public String getId() { return id; }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof User)) return false;
        User user = (User) o;
        return Objects.equals(id, user.id);
    }

    @Override
    public int hashCode() {
        return Objects.hash(id);
    }
}

public class Main {
    public static void main(String[] args) {
        Set<User> set = new HashSet<>();
        set.add(new User("A"));
        set.add(new User("A")); // 같은 id → 중복 취급

        System.out.println(set.size()); // 1
    }
}
```

#### 위험한 예시 (가변 필드를 키로 쓰면 문제)
```java
import java.util.*;

class BadUser {
    String name; // 가변
    BadUser(String name) { this.name = name; }

    @Override
    public boolean equals(Object o) {
        if (this == o) return true;
        if (!(o instanceof BadUser)) return false;
        BadUser other = (BadUser) o;
        return Objects.equals(name, other.name);
    }

    @Override
    public int hashCode() {
        return Objects.hash(name);
    }
}

public class Main {
    public static void main(String[] args) {
        Set<BadUser> set = new HashSet<>();
        BadUser u = new BadUser("kim");
        set.add(u);

        // 해시 버킷 결정에 쓰인 name을 바꾸면, set 내부에서 u를 다시 못 찾는 상태가 될 수 있음
        u.name = "lee";

        System.out.println(set.contains(u)); // false가 될 수 있음 (논리적 버그)
    }
}
```

---

## 3) `StringBuilder` vs `String` 차이 (그리고 String 관련 라이브러리/메서드)

### 3.1 `String`은 불변(immutable)
`String` 객체는 한 번 생성되면 내부 값이 바뀌지 않습니다.

```java
String s = "a";
s += "b";  // 기존 문자열을 수정하는 게 아니라, "ab" 새 객체를 만들어 s가 가리키게 됨
```

#### 결과
- 반복적인 `+` 연산이 많으면 **새 객체가 계속 생성**되어 비효율적
- 특히 루프에서 누적 문자열 만들 때 성능/메모리 부담 증가

---

### 3.2 `StringBuilder`는 가변(mutable)
내부 버퍼에 문자를 붙이고 수정할 수 있어서 **반복 누적에 유리**합니다.

```java
StringBuilder sb = new StringBuilder();
sb.append("a");
sb.append("b");
sb.append(123);

String result = sb.toString(); // 최종 String 변환
```

#### 언제 쓰나
- 문자열을 많이 이어붙이는 경우
- `append`, `insert`, `delete`, `reverse` 같은 편집이 필요한 경우

---

### 3.3 성능 비교 예시 (개념)
```java
// 느릴 수 있음: 반복마다 새 String 생성 가능성
String s = "";
for (int i = 0; i < 10000; i++) {
    s += i;
}

// 일반적으로 빠름: 내부 버퍼에 누적
StringBuilder sb = new StringBuilder();
for (int i = 0; i < 10000; i++) {
    sb.append(i);
}
String out = sb.toString();
```

---

### 3.4 `StringBuffer`는 뭐가 다른가
- `StringBuffer`: 메서드가 동기화(synchronized)되어 **멀티스레드 환경에서 안전**한 편
- 단일 스레드에서는 보통 `StringBuilder`가 더 빠름

---

### 3.5 String 관련 “라이브러리/메서드” 차이 (실무에서 많이 쓰는 것들)

#### 3.5.1 문자열 비교
- `==` 는 **참조(주소) 비교**
- `equals()` 는 **내용 비교**

```java
String a = new String("hi");
String b = new String("hi");

System.out.println(a == b);      // false
System.out.println(a.equals(b)); // true
```

#### 3.5.2 자주 쓰는 메서드
```java
String s = "  Hello Java  ";

System.out.println(s.length());               // 길이
System.out.println(s.trim());                 // 양끝 공백 제거(구버전 방식)
System.out.println(s.strip());                // Java 11+: 유니코드 공백까지 제거
System.out.println(s.toLowerCase());          // 소문자
System.out.println(s.toUpperCase());          // 대문자
System.out.println(s.substring(2, 7));        // 부분 문자열 (2~6)
System.out.println(s.replace("Java", "JVM")); // 치환
System.out.println(s.contains("Hello"));      // 포함 여부
```

#### 3.5.3 split/join
```java
String csv = "a,b,c";
String[] parts = csv.split(",");

String joined = String.join("-", parts); // "a-b-c"
```

#### 3.5.4 문자열 포맷
- `String.format`은 편하지만 빈번한 호출엔 비용이 있음
```java
String msg = String.format("name=%s age=%d", "kim", 27);
```

- Java 15+ 텍스트 블록(멀티라인 문자열)
```java
String json = """
{
  "name": "kim",
  "age": 27
}
""";
```

---

## 4) Stream 예시 (기초부터 실전 패턴까지)

### 4.1 Stream이 뭔가
컬렉션을 **선언형(무엇을 할지)** 으로 처리하는 API입니다.

- 중간 연산: `filter`, `map`, `sorted`, `distinct`, `limit` …
- 최종 연산: `collect`, `forEach`, `count`, `reduce`, `findFirst`, `anyMatch` …

---

### 4.2 기본 예시: filter + map + collect
```java
import java.util.*;
import java.util.stream.*;

public class Main {
    public static void main(String[] args) {
        List<Integer> nums = Arrays.asList(1, 2, 3, 4, 5, 6);

        List<Integer> evenSquares = nums.stream()
            .filter(n -> n % 2 == 0)   // 짝수만
            .map(n -> n * n)           // 제곱
            .collect(Collectors.toList());

        System.out.println(evenSquares); // [4, 16, 36]
    }
}
```

---

### 4.3 distinct (중복 제거) vs Set 사용
- `distinct()`는 **equals() 기준 중복 제거**
- 결과를 Set으로 받고 싶으면 `Collectors.toSet()`

```java
import java.util.*;
import java.util.stream.*;

public class Main {
    public static void main(String[] args) {
        List<String> list = Arrays.asList("a", "b", "a", "c", "b");

        List<String> distinctList = list.stream()
            .distinct()
            .collect(Collectors.toList());
        System.out.println(distinctList); // [a, b, c] (원소 순서는 stream의 encounter order 영향)

        Set<String> distinctSet = list.stream()
            .collect(Collectors.toSet()); // 보통 HashSet
        System.out.println(distinctSet); // 순서 보장 없음
    }
}
```

---

### 4.4 정렬 sorted: 자연 정렬, 커스텀 정렬
```java
import java.util.*;
import java.util.stream.*;

class User {
    String name;
    int age;
    User(String name, int age) { this.name = name; this.age = age; }
    public String getName() { return name; }
    public int getAge() { return age; }
    @Override public String toString() { return name + "(" + age + ")"; }
}

public class Main {
    public static void main(String[] args) {
        List<User> users = Arrays.asList(
            new User("kim", 27),
            new User("lee", 25),
            new User("park", 27)
        );

        List<User> sorted = users.stream()
            .sorted(Comparator.comparingInt(User::getAge)
                              .thenComparing(User::getName))
            .collect(Collectors.toList());

        System.out.println(sorted); // [lee(25), kim(27), park(27)]
    }
}
```

---

### 4.5 reduce: 누적(합계 등) 만들기
```java
import java.util.*;

public class Main {
    public static void main(String[] args) {
        List<Integer> nums = Arrays.asList(1, 2, 3, 4);

        int sum = nums.stream()
            .reduce(0, (acc, x) -> acc + x);

        System.out.println(sum); // 10
    }
}
```

---

### 4.6 집계: `IntSummaryStatistics`
한 번의 스트림 처리로 **합/평균/최대/최소/개수**를 얻을 수 있습니다.

```java
import java.util.*;
import java.util.stream.*;

public class Main {
    public static void main(String[] args) {
        List<Integer> nums = Arrays.asList(10, 20, 30, 40);

        IntSummaryStatistics st = nums.stream()
            .mapToInt(Integer::intValue)   // IntStream으로 변환
            .summaryStatistics();          // 통계 객체 생성

        System.out.println(st.getCount());   // 4
        System.out.println(st.getSum());     // 100
        System.out.println(st.getAverage()); // 25.0
        System.out.println(st.getMax());     // 40
        System.out.println(st.getMin());     // 10
    }
}
```

---

### 4.7 groupingBy: 그룹핑 (실무에서 매우 자주 씀)
```java
import java.util.*;
import java.util.stream.*;

class User {
    String name;
    String team;
    int age;
    User(String name, String team, int age) { this.name = name; this.team = team; this.age = age; }
    public String getName() { return name; }
    public String getTeam() { return team; }
    public int getAge() { return age; }
}

public class Main {
    public static void main(String[] args) {
        List<User> users = Arrays.asList(
            new User("kim", "A", 27),
            new User("lee", "A", 25),
            new User("park", "B", 31)
        );

        Map<String, List<User>> byTeam = users.stream()
            .collect(Collectors.groupingBy(User::getTeam));

        System.out.println(byTeam.get("A").size()); // 2
    }
}
```

#### 그룹별 집계까지 한 번에
```java
import java.util.*;
import java.util.stream.*;

class User {
    String team; int age;
    User(String team, int age) { this.team = team; this.age = age; }
    public String getTeam() { return team; }
    public int getAge() { return age; }
}

public class Main {
    public static void main(String[] args) {
        List<User> users = Arrays.asList(
            new User("A", 27),
            new User("A", 25),
            new User("B", 31)
        );

        Map<String, Double> avgAgeByTeam = users.stream()
            .collect(Collectors.groupingBy(
                User::getTeam,
                Collectors.averagingInt(User::getAge)
            ));

        System.out.println(avgAgeByTeam); // {A=26.0, B=31.0}
    }
}
```

---

### 4.8 flatMap: 중첩 컬렉션 펼치기
```java
import java.util.*;
import java.util.stream.*;

public class Main {
    public static void main(String[] args) {
        List<List<String>> nested = Arrays.asList(
            Arrays.asList("a", "b"),
            Arrays.asList("b", "c")
        );

        List<String> flatDistinct = nested.stream()
            .flatMap(List::stream)   // List<String> 스트림으로 펼침
            .distinct()
            .collect(Collectors.toList());

        System.out.println(flatDistinct); // [a, b, c]
    }
}
```

---

### 4.9 스트림 사용할 때 주의점
1. **스트림은 1회용**: 최종 연산 후 재사용 불가  
2. `forEach`로 상태 변경(사이드 이펙트) 남발하면 디버깅이 어려워짐  
3. 성능이 중요하면:
   - 불필요한 `boxed()/unboxed()` 피하기 (`mapToInt` 등 primitive stream 활용)
   - `sorted()`는 비용이 큼 (정렬이 꼭 필요할 때만)
4. 병렬 스트림(`parallelStream`)은 데이터 크기/연산 비용/스레드 경쟁에 따라 오히려 느려질 수 있음

---

## 5) 한 번에 감 잡는 선택 가이드
- 중복 제거 + 빠른 포함 검사: `HashSet`
- 중복 제거 + 삽입 순서 유지: `LinkedHashSet`
- 중복 제거 + 항상 정렬된 상태 유지: `TreeSet`
- 문자열 누적/편집: `StringBuilder` (멀티스레드는 `StringBuffer` 고려)
- 컬렉션을 선언적으로 변환/필터/집계: `Stream`

---


