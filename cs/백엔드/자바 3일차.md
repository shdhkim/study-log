# Java Collection / Copy / get & set 완전 정리 

## 0. 핵심 요약
- `get(index)`는 참조 반환만 한다 (읽기 전용)
- `get(index) = ...`는 타입과 무관하게 불가능
- `set(index, obj)`는 해당 위치의 참조를 새 객체로 교체
- `set()`은 추가(add)가 아니라 교체(replace)
- `set()`은 얕은 복사 개념이며 객체 자체를 복사하지 않는다

---

## 1. add / set / get 차이

| 메서드 | 의미 | size 변화 |
|---|---|---|
| add(obj) | 맨 뒤에 추가 | 증가 |
| add(idx, obj) | 중간 삽입 | 증가 |
| get(idx) | 요소 참조 반환 | 없음 |
| set(idx, obj) | 기존 요소 교체 | 없음 |

---

## 2. set()의 내부 동작

```java
list.set(0, new Box());
```

개념적 동작:
```java
elementData[0] = new Box();
```

- 기존 참조 제거
- 새 객체 참조 저장
- 객체 복사 없음
- 참조 교체만 수행

---

## 3. set()과 복사 개념

### 3.1 set()은 깊은 복사인가?
아니다.

- set()은 전달된 객체의 참조만 저장
- 객체 생성/복사는 외부에서 이미 완료됨

```java
Box b = new Box();
list.set(0, b);
```

```
b ──▶ Box@A
list[0] ─▶ Box@A
```

---

### 3.2 set() 이후 참조 공유

```java
b.value = 10;
```

- list.get(0).value == 10
- 동일 객체 참조

---

## 4. Integer에서 set()

```java
ArrayList<Integer> list = new ArrayList<>();
list.add(10);

list.set(0, 20);
```

```
before: [ Integer(10) ]
after : [ Integer(20) ]
```

- 내부 값 변경 아님
- 참조 교체

---

## 5. 객체(Box)에서 set()

```java
class Box { int value; }

ArrayList<Box> list = new ArrayList<>();
list.add(new Box());

list.set(0, new Box());
```

```
before: [ Box@A ]
after : [ Box@B ]
```

---

## 6. get().field vs set()

### 6.1 get().field (상태 변경)

```java
list.get(0).value = 10;
```

- 동일 객체 유지
- 내부 상태 변경
- mutable 객체만 가능

---

### 6.2 set() (객체 교체)

```java
list.set(0, new Box());
```

- 객체 자체 교체
- immutable / mutable 무관

---

## 7. set()과 얕은 복사 관계

```java
Box b = new Box();
list.set(0, b);
```

- 얕은 복사
- 참조 공유

---

## 8. 깊은 복사가 필요한 경우

```java
Box origin = list.get(0);

Box copy = new Box();
copy.value = origin.value;

list.set(0, copy);
```

- 이 경우만 깊은 복사 효과

---

## 9. 흔한 오해 정리

- set은 객체를 복사해주지 않는다
- set은 모든 객체 타입에서 동일하게 동작한다

---

## 10. 결론

get은 읽기, set은 교체, 복사는 직접 구현
