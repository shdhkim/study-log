# Spring Cloud 정리 (Kubernetes 비교)

## 1. Spring Cloud란 무엇인가

Spring Cloud는 여러 개의 Spring Boot 서비스가 서로를 **서비스 이름으로
발견하고 호출하며, 장애 상황에서도 안정적으로 동작하도록** 만드는
애플리케이션 레벨 프레임워크이다.

핵심 목표: - 서비스 위치 자동 발견(Service Discovery) - 내부
로드밸런싱 - 재시도/타임아웃/서킷브레이커 - 공통 설정 관리 - 게이트웨이
라우팅

즉, 서버(인프라)를 관리하는 기술이 아니라 **서비스 간 통신과 호출 정책을
관리하는 기술**이다.

------------------------------------------------------------------------

## 2. 주요 구성요소

### 2.1 Spring Cloud Gateway

외부 요청을 내부 서비스로 라우팅하는 API Gateway

역할: - URL 경로 기반 라우팅 - 인증/인가 전처리 - 공통 필터 처리 - 토큰
전달

예시:

    /api/users → USER-SERVICE
    /api/orders → ORDER-SERVICE
    /api/reco → RECO-SERVICE

------------------------------------------------------------------------

### 2.2 Service Discovery (Eureka)

각 서비스가 자신의 위치(IP, 포트)를 등록하고 다른 서비스가 조회하는
등록소.

동작: 1. 서비스가 기동되면 Eureka에 자신 등록 2. 다른 서비스가 서비스
이름으로 조회 3. 살아있는 서버 목록 반환

호출 방식:

    http://USER-SERVICE/users/1

IP를 몰라도 호출 가능.

------------------------------------------------------------------------

### 2.3 LoadBalancer

서비스가 여러 대일 때 자동 분산 호출.

예:

    USER-SERVICE
     ├─ 10.0.1.11
     ├─ 10.0.1.12
     └─ 10.0.1.13

호출 시 자동으로 하나 선택하여 요청 전달.

------------------------------------------------------------------------

### 2.4 OpenFeign

서비스 간 HTTP 호출을 인터페이스 형태로 선언.

예:

``` java
@FeignClient(name="USER-SERVICE")
public interface UserClient {
    @GetMapping("/users/{id}")
    User getUser(@PathVariable Long id);
}
```

개발자가 직접 URL을 만들 필요가 없다.

------------------------------------------------------------------------

### 2.5 Resilience4j (서킷브레이커)

서비스 장애 상황에서 연쇄 장애를 막는다.

기능: - 재시도(Retry) - 타임아웃(Timeout) - 서킷브레이커(Circuit
Breaker) - Fallback 응답

예: USER 서비스가 느릴 때 → 바로 실패 대신 기본 응답 반환

------------------------------------------------------------------------

### 2.6 Spring Cloud Config

모든 서비스의 설정파일을 중앙에서 관리.

문제: 서비스 10개면 application.yml 10개 관리 필요

해결: Config Server가 공통 설정 제공

------------------------------------------------------------------------

## 3. Kubernetes가 없을 때 (Spring Cloud 단독)

### 구조

    사용자
      ↓
    Nginx/ALB
      ↓
    Spring Cloud Gateway
      ↓
    Eureka
      ↓
    서비스들(EC2 여러대)

### 서비스 호출 흐름

    ORDER-SERVICE → Eureka 조회 → USER-SERVICE 실제 IP 획득 → 호출

Eureka가 다음 역할을 수행: - 서비스 위치 조회 - 헬스체크 - 내부
로드밸런싱

즉 Kubernetes의 Service DNS 역할을 Spring Cloud가 대신한다.

------------------------------------------------------------------------

### 특징

-   IP 변경에 자동 대응
-   오토스케일링 대응 가능
-   내부 서비스 간 안정적 호출 가능
-   MSA 구현 가능

------------------------------------------------------------------------

## 4. Kubernetes가 있을 때

Kubernetes는 이미 다음을 제공한다:

-   Pod IP 관리
-   내부 DNS
-   서비스 로드밸런싱
-   헬스체크

예:

    http://user-service

→ Kubernetes DNS가 실제 Pod로 연결

따라서 변화:

  구성요소       상태
  -------------- --------------------
  Eureka         제거되는 경우 많음
  Gateway        계속 사용
  Feign          계속 사용
  Resilience4j   계속 사용
  Config         계속 사용

------------------------------------------------------------------------

### 구조

    사용자
      ↓
    Ingress
      ↓
    Spring Cloud Gateway
      ↓
    Kubernetes Service
      ↓
    Pods

### 호출 흐름

    ORDER → user-service(K8s DNS) → USER Pod

여기서: - 연결 자체: Kubernetes - 호출 제어/재시도/서킷브레이커: Spring
Cloud

------------------------------------------------------------------------

## 5. 역할 분리

  영역               담당
  ------------------ --------------
  네트워크 연결      Kubernetes
  서비스 호출 정책   Spring Cloud
  장애 대응          Spring Cloud
  컨테이너 운영      Kubernetes
  API 라우팅         Gateway

------------------------------------------------------------------------

## 6. 핵심 이해

Spring Cloud는 네트워크를 만드는 기술이 아니라 **서비스 간 통신을
안정적으로 만드는 애플리케이션 레벨 제어 시스템**이다.

Kubernetes가 없으면: - Eureka가 서비스 위치를 관리

Kubernetes가 있으면: - K8s DNS가 위치를 관리 - Spring Cloud는 호출
제어에 집중

------------------------------------------------------------------------

## 최종 요약

1.  Spring Cloud는 서비스 간 호출을 관리한다.
2.  Kubernetes가 없을 때는 Eureka가 서비스 위치를 제공한다.
3.  Kubernetes가 있으면 DNS가 위치를 제공하고 Eureka는 필요 없어질 수
    있다.
4.  Gateway, Feign, Resilience4j, Config는 계속 사용된다.
5.  Spring Cloud는 인프라 기술이 아니라 애플리케이션 통신 제어 기술이다.
