# React 상태 스냅샷 & 렌더링 정리

## 핵심 정리
React의 state 값은 **실시간 변수**가 아니라, **각 렌더(render) 시점에 고정된 스냅샷(snapshot)** 이다.

---

## 1. count의 정체
```jsx
const [count, setCount] = useState(0);
```

- count는 현재 렌더에서 확정된 값
- setCount는 값을 즉시 바꾸지 않고 **다음 렌더를 예약**

---

## 2. 렌더 스냅샷 개념
- 렌더가 시작되면 상태가 하나로 확정됨
- 해당 렌더 동안 count는 절대 변하지 않음
- setState는 현재 렌더의 count를 변경하지 못함

---

## 3. 왜 setCount 직후 값이 안 바뀌는가
```js
setCount(1);
console.log(count); // 이전 값
```

이유:
- 아직 다음 렌더가 실행되지 않았기 때문

---

## 4. 같은 스냅샷 문제 (stale closure)
```js
setCount(count + 1);
setCount(count + 1);
```

- 두 줄 모두 같은 렌더의 count 사용
- 결과: 1번만 증가

---

## 5. 함수형 업데이트가 필요한 이유
```js
setCount(c => c + 1);
```

- c는 React가 계산 시점에 주입하는 최신 상태
- 배칭, concurrent rendering에서도 안전

---

## 6. render / commit 단계
- render phase: 계산 (중단/재시작 가능)
- commit phase: DOM 반영 (1번만 실행)

---

## 7. 이벤트 핸들러의 count
```js
onClick={() => console.log(count)}
```

- 클릭 시점이 아니라
- 핸들러가 생성된 렌더의 count를 참조

---

## 8. useEffect의 count
```js
useEffect(() => {
  console.log(count);
}, [count]);
```

- commit 이후 실행
- 항상 최신 렌더의 count

---

## 9. console.log vs useState (결정적 차이)

### console.log
```js
console.log(count);
```

- 일반 JS 함수 호출
- 콜스택에서 **즉시 실행**
- 호출 즉시 부작용(로그 출력) 발생
- React 렌더링과 무관

### useState / setState
```js
setCount(1);
```

- 일반 함수처럼 콜스택에서 실행되지만
- **상태 변경을 즉시 수행하지 않음**
- React 내부 업데이트 큐에 저장
- 렌더를 **예약(schedule)** 하는 역할

### 차이 요약

| 구분 | console.log | setState |
|---|---|---|
| 콜스택 실행 | 즉시 | 즉시 |
| 효과 발생 시점 | 즉시 | 나중(commit 이후) |
| 렌더 트리거 | ❌ | ✅ |
| 배칭 대상 | ❌ | ✅ |
| 취소 가능 | ❌ | ✅ (React 18) |

---

## 10. 요약 규칙
- state는 렌더 단위 스냅샷
- 이전 상태 의존 → 함수형 업데이트
- setState는 예약, 렌더는 나중
- console.log는 즉시 실행, setState는 지연 반영

---

## 11. 요약 정리
React의 상태 값은 각 렌더마다 고정된 스냅샷이며,  
console.log는 즉시 실행되는 동기 함수인 반면,  
setState는 상태 변경을 예약하고 React가 적절한 시점에 렌더링을 수행하도록 하는 메커니즘이다.
