# CloudFront + Nginx + Route53 구조 비교 (A / B 패턴 정리 – 상세 버전)

이 문서는 다음 두 가지 인프라 구조를 비교하고, 실제 동작 방식과 Route53 역할까지 한 번에 정리한 것이다.

- A 구조: 프론트 도메인과 API 도메인이 분리된 패턴  
- B 구조: 프론트와 API를 하나의 도메인으로 통합한 패턴 (CloudFront → Nginx → 백엔드 분기)

---

## 0. 공통 구성 요소 개념 정리

### 0-1. Route53 (DNS 서비스)

Route53은 AWS에서 제공하는 DNS 서비스로, 가장 중요한 역할은 다음과 같다.

- 사람이 읽는 **도메인 이름**을 컴퓨터가 이해하는 **IP 또는 다른 호스트 이름**으로 바꿔주는 역할
  - 예: `myapp.com` → `3.12.34.56` (EC2 IP)
  - 예: `myapp.com` → `d1234abcd.cloudfront.net` (CloudFront 도메인)
- A, CNAME, ALIAS, TXT 등의 레코드를 통해 트래픽 흐름을 제어
- 특히 **ALIAS 레코드**를 사용하면 루트 도메인(`myapp.com`)을 CloudFront, ALB 등으로 직접 연결할 수 있음

### 0-2. CloudFront (CDN / Edge Gateway)

CloudFront는 전 세계에 분산된 엣지 노드에서 요청을 받아 처리하는 CDN 서비스이다.

- 정적 파일(HTML, JS, CSS, 이미지 등)을 **캐싱**해서 빠르게 제공
- HTTPS(SSL/TLS)를 쉽게 적용
- Origin(예: S3, EC2, Nginx, ALB 등)으로 요청을 전달
- 브라우저 → CloudFront → Origin 순서로 트래픽이 흐름

### 0-3. Nginx (Gateway / Reverse Proxy)

Nginx는 웹 서버이자 리버스 프록시 역할을 한다.

- 정적 파일을 직접 서빙할 수 있음 (React build 결과 등)
- 특정 경로에 따라 내부 서버(EC2, Docker, 다른 포트 등)로 요청을 전달
  - 예: `/api` → Spring Boot
  - 예: `/flask` → Flask 서버
- 보통 CloudFront의 Origin으로 두고, **게이트웨이**처럼 사용하면 깔끔한 구조가 됨

### 0-4. 백엔드 EC2 (Spring / Flask 등)

- 실질적인 비즈니스 로직이 돌아가는 서버
- Nginx 뒤에 두고, 외부에서는 직접 접근하지 못하게 막는 것이 일반적
- 예: `10.0.1.11:8080` (Spring Boot), `10.0.2.22:5000` (Flask)

---

## 1. A 구조 – 프론트 도메인과 API 도메인이 분리된 패턴

### 1-1. 구조 개념

- 프론트와 API가 다른 도메인을 가진다.
- 브라우저 기준으로 **Origin이 두 개**이므로 CORS 설정이 반드시 필요하다.

예시:

- 프론트(React + CloudFront):  
  `https://front.myapp.com`
- API(Nginx 또는 Spring 직접):  
  `https://api.myapp.com`

브라우저에서 볼 때:

- 프론트 페이지를 로딩할 때: `front.myapp.com`
- API 호출할 때: `api.myapp.com`

두 호스트가 다르므로 서로 다른 Origin이다.

---

### 1-2. Route53 레코드 구성

```text
# 프론트 도메인 → CloudFront로 연결
front.myapp.com    A (또는 ALIAS)  → d1234abcd.cloudfront.net

# API 도메인 → Nginx 또는 Spring EC2로 연결
api.myapp.com      A               → 3.12.34.56 (EC2 Public IP)
```

- Route53은 단순히 “이 도메인으로 들어온 요청은 어디로 가라”만 관리한다.
- CloudFront와 EC2는 각각 자신의 역할대로 응답할 뿐, 도메인이 다르다는 점이 CORS의 핵심 원인이다.

---

### 1-3. CloudFront 설정 (프론트 전용)

- Distribution #1:
  - Alternate domain (CNAME): `front.myapp.com`
  - Origin:
    - S3 Bucket (React build 파일)
    - 또는 Nginx 서버 (정적 파일 서빙)
  - Behavior:
    - Path pattern: `/*`
    - Origin: 프론트 정적 파일 서버

이 구조에서 CloudFront는 **프론트 정적 리소스만 담당**한다.

---

### 1-4. 프론트 요청 흐름

1. 브라우저가 주소창에 입력:  
   `https://front.myapp.com`
2. DNS(Route53)가 응답:  
   `front.myapp.com` → `d1234abcd.cloudfront.net` (CloudFront)
3. 브라우저가 CloudFront에 요청:
   `GET /`
4. CloudFront:
   - 캐시에 있으면 바로 HTML/JS/CSS 응답
   - 없으면 Origin(S3 또는 Nginx)으로 요청 전달
5. 브라우저는 React 앱을 받아서 렌더링

---

### 1-5. API 요청 흐름

프론트 코드 예시:

```ts
// 도메인이 다르기 때문에 풀 URL을 사용해야 함
fetch("https://api.myapp.com/api/users");
fetch("https://api.myapp.com/flask/analyze");
```

흐름:

1. 브라우저:
   - `GET https://api.myapp.com/api/users`
2. DNS(Route53):
   - `api.myapp.com` → `3.12.34.56` (Nginx 또는 Spring EC2)
3. Nginx가 있다면:
   - `/api/` 요청을 보고 내부 Spring 서버로 proxy_pass
   - `/flask/` 요청을 보고 내부 Flask 서버로 proxy_pass
4. 백엔드(Spring/Flask)에서 응답
5. Nginx → 브라우저로 응답 전달

---

### 1-6. CORS 관점 (A 구조)

- 프론트 Origin: `https://front.myapp.com`
- API Origin: `https://api.myapp.com`

프로토콜(https)은 같지만 호스트(front vs api)가 다르므로 **서로 다른 Origin**이다.

그러므로 API 서버(Spring 또는 Nginx)에서 다음과 같은 CORS 응답 헤더가 필요하다.

예: Spring Boot 전역 CORS 설정

```java
@Configuration
public class WebConfig implements WebMvcConfigurer {

    @Override
    public void addCorsMappings(CorsRegistry registry) {
        registry.addMapping("/**")
                .allowedOrigins("https://front.myapp.com")
                .allowedMethods("*")
                .allowedHeaders("*")
                .allowCredentials(true);
    }
}
```

또는 Nginx에서 직접 CORS 헤더 추가도 가능하다.

---

## 2. B 구조 – 프론트와 API를 하나의 도메인으로 통합한 패턴

### 2-1. 구조 개념

- 사용자 눈에는 항상 하나의 도메인만 보인다. 예: `https://myapp.com`
- CloudFront가 모든 요청을 받아 **Origin인 Nginx로 전달**한다.
- Nginx는 URL 경로(`/`, `/api`, `/flask` 등)를 기준으로 내부 서버에 라우팅한다.
- 브라우저 기준 Origin이 1개이므로 CORS가 필요하지 않다.

예시:

- 공용 도메인: `https://myapp.com`
- CloudFront Origin: `https://gateway.myapp.com`
- Nginx 내부 분기:
  - `/` → React 정적 파일(프론트)
  - `/api` → Spring Boot
  - `/flask` → Flask

---

### 2-2. Route53 레코드 구성

```text
# 1) myapp.com → CloudFront로 보냄 (루트 도메인은 ALIAS 사용)
myapp.com          A (또는 ALIAS)  → d5678efgh.cloudfront.net

# 2) gateway.myapp.com → Nginx EC2로 보냄
gateway.myapp.com  A               → 3.21.43.65 (Nginx EC2 Public IP)
```

여기서 중요한 점은:

- 브라우저는 오직 `myapp.com`만 알게 된다.
- `gateway.myapp.com`은 **CloudFront Origin 설정에만 사용되는 내부 주소**이다.

---

### 2-3. CloudFront 설정 (게이트웨이 역할)

- Distribution #1:
  - Alternate domain (CNAME): `myapp.com`
  - Origin:
    - Origin Domain Name: `gateway.myapp.com` (Nginx EC2)
  - Behavior:
    - Path pattern: `/*`
    - Origin: `gateway.myapp.com`

즉, 브라우저에서 들어오는 **모든 요청**은

1. 먼저 CloudFront로 들어오고
2. CloudFront가 Origin 설정에 따라 `gateway.myapp.com`으로 전달한다.

브라우저는 절대 `gateway.myapp.com`으로 직접 요청하지 않는다.

---

### 2-4. Nginx 설정 예시 (경로 기반 분기)

```nginx
server {
    listen 80;
    server_name gateway.myapp.com;

    # 1) 프론트 정적 파일 (React build 결과)
    location / {
        root /var/www/myapp-frontend;
        try_files $uri /index.html;
    }

    # 2) Spring Boot API
    location /api/ {
        proxy_pass http://10.0.1.11:8080/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }

    # 3) Flask API
    location /flask/ {
        proxy_pass http://10.0.2.22:5000/;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
    }
}
```

포인트:

- `/` 경로로 들어오면 프론트 정적 파일을 반환한다.
- `/api/` 경로로 들어오면 Spring Boot 서버로,
- `/flask/` 경로로 들어오면 Flask 서버로 proxy_pass 한다.

---

### 2-5. 요청 흐름 – 프론트 페이지

1. 브라우저 주소창:  
   `https://myapp.com`
2. DNS(Route53):  
   `myapp.com` → `d5678efgh.cloudfront.net` (CloudFront)
3. 브라우저 → CloudFront:
   - `GET /`
4. CloudFront:
   - Origin 설정에 따라 `gateway.myapp.com`으로 요청 전달
5. Nginx:
   - `/` 경로이므로 React 정적 파일(`/var/www/myapp-frontend/index.html`) 반환
6. 브라우저:
   - React 앱을 렌더링

---

### 2-6. 요청 흐름 – API 호출

프론트 코드 예시:

```ts
// 같은 도메인을 사용하므로 상대 경로만 사용해도 됨
fetch("/api/users");
fetch("/flask/analyze");

// 실제 요청 주소는:
// https://myapp.com/api/users
// https://myapp.com/flask/analyze
```

흐름:

1. 브라우저:
   - `GET https://myapp.com/api/users`
2. DNS(Route53):
   - `myapp.com` → CloudFront
3. CloudFront:
   - Origin: `gateway.myapp.com`으로 전달  
     → `https://gateway.myapp.com/api/users`
4. Nginx:
   - `/api/` 경로를 확인하고 `http://10.0.1.11:8080` (Spring Boot)로 proxy_pass
5. Spring Boot:
   - 응답 반환 → Nginx → CloudFront → 브라우저

Flask도 동일한 패턴:

1. `GET https://myapp.com/flask/analyze`
2. CloudFront → `https://gateway.myapp.com/flask/analyze`
3. Nginx → `http://10.0.2.22:5000` (Flask)
4. Flask 응답 → Nginx → CloudFront → 브라우저

---

### 2-7. CORS 관점 (B 구조)

브라우저가 실제로 보는 Origin은 항상 다음과 같다.

- `https://myapp.com` (프론트)
- `https://myapp.com/api/...` (API)
- `https://myapp.com/flask/...` (Flask)

즉, **프로토콜, 호스트, 포트가 모두 동일**하다.

- 프로토콜: https
- 호스트: myapp.com
- 포트: 443

브라우저 입장에서는 모두 Same-Origin이므로 CORS 검사를 하지 않는다.  
CloudFront → Nginx, Nginx → 백엔드는 서버 간 통신이라 원래부터 CORS 대상이 아니다.

---

## 3. A 구조 vs B 구조 비교 요약

| 항목              | A 구조 (도메인 분리)                         | B 구조 (단일 도메인)                                       |
|-------------------|----------------------------------------------|------------------------------------------------------------|
| 프론트 도메인     | front.myapp.com                              | myapp.com                                                  |
| API 도메인        | api.myapp.com                                | myapp.com/api, myapp.com/flask                            |
| CloudFront 역할   | 프론트 정적 파일 전용                        | 전체 트래픽(프론트 + API) 게이트웨이                      |
| Origin            | S3 또는 프론트용 Nginx                       | gateway.myapp.com (Nginx Gateway)                          |
| Nginx 역할        | API 전용 또는 프론트+API 둘 다               | CloudFront 뒤 게이트웨이, 내부 서버 분기                  |
| Route53 필요성    | 선택적 (외부 DNS도 가능)                     | 루트 도메인 + CloudFront 연동 시 사실상 Route53이 편리   |
| 브라우저 Origin   | 두 개 (front.myapp.com, api.myapp.com)      | 하나 (myapp.com)                                          |
| CORS 필요 여부    | 필요                                         | 불필요                                                     |
| 프론트 API 호출   | fetch("https://api.myapp.com/api/users")   | fetch("/api/users")                                      |
| 장점              | 프론트와 API를 완전히 분리된 서비스처럼 운영 | 도메인 통합, URL 깔끔, CORS 없음, CloudFront 게이트웨이화 |
| 단점              | CORS 설정 필요, 도메인 2개 관리              | 설계가 약간 더 복잡, Route53 + CloudFront 세팅 필요       |

---

## 4. 선택 기준 정리

### A 구조가 적합한 경우

- 프론트와 백엔드를 완전히 독립 서비스처럼 다루고 싶을 때
- 이미 `front.` / `api.` 형태의 도메인 구성이 익숙할 때
- CORS 설정에 익숙하고 크게 부담이 없을 때

### B 구조가 적합한 경우

- 사용자 입장에서 URL을 최대한 단순하게 만들고 싶을 때 (`https://myapp.com` 하나)
- 프론트와 API를 하나의 도메인에서 통합적으로 운영하고 싶을 때
- CORS 문제를 구조적으로 제거하고 싶을 때
- CloudFront + Nginx를 이용해 **Gateway 패턴**을 구현하고 싶을 때

---

## 5. 요약 한 줄

- A 구조: `프론트 도메인`과 `API 도메인`을 분리해서 CORS를 감수하지만 구조가 직관적인 방식  
- B 구조: CloudFront → Nginx → 백엔드로 이어지는 게이트웨이 구조로, **도메인 하나로 프론트와 API를 모두 처리하는 방식**

이 문서를 기반으로 실제 인프라(EC2, CloudFront, Route53, Nginx)를 설계하면 전체 흐름을 한 번에 이해할 수 있다.
