# Oracle Lock Deep Dive
(Deadlock 즉시 발생 이유 / TX–TM–TX 교차 구조 / 배치 UPDATE 락 줄이기 전략 / 읽기에서 공유락이 필요 없는 이유)

작성 기준: Oracle (일반적인 OLTP 설정, 기본 격리수준 READ COMMITTED)

---

## 0. 전제: 약어와 풀네임

| 약어 | 풀네임 | 의미(요약) |
|---|---|---|
| TX | Transaction Lock | 행(Row) DML을 보호하는 트랜잭션 락(주로 행 독점) |
| TM | Table Lock | 테이블 단위 규칙/DDL/DML 공존을 관리하는 락 |
| RS | Row Share | “이 테이블의 행(TX)을 잠글 수 있다”는 의사 표시(주로 `SELECT ... FOR UPDATE`, FK 체크 등에서 등장) |
| X | Exclusive | 독점(호환 불가가 많음) |
| RX | Row Exclusive | DML 공존(다른 DML은 가능) + DDL 차단 |
| S | Share | 공유(읽기 중심, 대개 DML 차단) |
| SRX | Share Row Exclusive | 강한 테이블 락(대개 DML/DDL 모두 강하게 차단) |

참고(실무 감각):
- DML(INSERT/UPDATE/DELETE)은 보통 동시에 `TX`(해당 행) + `TM(RX)`(해당 테이블)을 잡는다.
- SELECT는 보통 락을 잡지 않고 Undo 기반 일관읽기(MVCC)로 처리된다.
- `SELECT ... FOR UPDATE`는 “읽기”처럼 보여도 실제로 `TM(RS)` + `TX`(행 독점)를 잡는다. (일반 SELECT와 다름)

---

## 1. Oracle은 왜 “읽기(SELECT)”에 공유락(Shared Lock)이 거의 필요 없나

### 1.1 결론 한 줄
Oracle은 **읽기-쓰기 충돌을 ‘락’이 아니라 ‘버전(Undo)’로 해결**한다.  
즉, 읽기는 “잠금”이 아니라 **과거 버전(스냅샷)을 읽는 방식**이라서 공유락이 없어도 된다.

---

### 1.2 전통적 DB(공유락 기반) vs Oracle(MVCC 기반)
#### 전통적(공유락) 접근
- SELECT → Shared Lock(S)
- UPDATE/DELETE → Exclusive Lock(X)
- 문제: 읽기가 많으면 쓰기가 막힘(경합 심화)

#### Oracle(MVCC; Multi-Version Concurrency Control)
- SELECT → **락을 안 잡음**
- UPDATE/DELETE → 해당 행에 **TX(독점)** 을 잡음
- 읽기 일관성은 **Undo**로 보장

---

### 1.3 Oracle에서 SELECT가 동작하는 내부 흐름(그림 없이 텍스트로)
#### 세션 A가 UPDATE를 커밋하지 않은 상태
```sql
-- 세션 A
UPDATE emp SET sal = sal + 100 WHERE empno = 1;
-- COMMIT 안 함
```

#### 세션 B가 같은 행을 SELECT
```sql
-- 세션 B
SELECT sal FROM emp WHERE empno = 1;
```

B가 보는 값은:
- A가 만든 “미커밋 새 값”이 아니라
- **A의 변경 이전 버전(일관 읽기 시점의 버전)**

Oracle이 하는 일(개념):
1) 데이터 블록을 읽었는데, 행이 커밋되지 않았거나 B의 SCN(일관 읽기 시점)보다 “미래” 버전이면
2) Undo(Undo Segment)에 저장된 “과거 이미지(이전 값)”를 찾아서
3) 필요한 만큼 롤백 적용(consistent read)해서
4) B에게 “그 시점의 값”을 반환

따라서:
- B는 공유락을 잡을 필요가 없다(막을 필요가 없음)
- A도 SELECT 때문에 쓰기가 막히지 않는다

---

### 1.4 그래서 생기는 특징
1) **SELECT가 UPDATE를 막지 않는다**
2) “읽기는 되는데 수정은 안 된다”는 상황의 원인은
   - 읽기 공유락이 아니라
   - **TX(행 독점)** 충돌 때문이다
3) 읽기 경합 대신 중요한 건
   - Undo 공간/관리(Undo 부족, 긴 쿼리, ORA-01555 위험 등)

---

### 1.5 예외: 읽기처럼 보여도 락을 잡는 경우
#### `SELECT ... FOR UPDATE`
```sql
SELECT * FROM emp WHERE empno = 1 FOR UPDATE;
```
- 이건 읽기 전용이 아니라 “업데이트 예약”
- 해당 행에 `TX`(Transaction Exclusive Lock)를 잡는다
- 동시에 테이블에 `TM(RS)` 를 잡는다 (행 락을 걸기 위한 테이블 차원의 표시)
- 다른 세션의 UPDATE/DELETE/SELECT FOR UPDATE는 대기

---

## 2. 데드락이 왜 “순식간에” 터지나: 실제 예제

### 2.1 데드락과 단순 대기의 차이(핵심)
- 단순 대기: A가 가진 락을 B가 기다리고, A는 누구도 기다리지 않음. 시간이 지나면 해결(커밋/롤백) 가능.
- 데드락: A가 B를 기다리고, 동시에 B도 A를 기다림(순환). 절대 스스로 풀리지 않으므로 Oracle은 즉시 감지하여 한쪽을 실패(ORA-00060) 시킴.

Oracle이 “빨리” 터뜨리는 이유:
- 데드락은 기다려도 절대 풀리지 않는 구조(순환)라서 시간을 끌면 시스템 자원만 잡아먹는다.
- Oracle은 락 대기 그래프(Wait-For Graph)에서 순환을 감지하면 즉시 에러를 발생시켜 순환을 끊는다.
- 결과적으로 사용자는 “방금 쿼리 쳤는데 바로 ORA-00060”처럼 느낀다.

---

### 2.2 데드락 실전 재현(행 2개 교차 업데이트)

#### 준비 테이블/데이터
```sql
CREATE TABLE t_deadlock (
  id  NUMBER PRIMARY KEY,
  v   NUMBER
);

INSERT INTO t_deadlock VALUES (1, 10);
INSERT INTO t_deadlock VALUES (2, 20);
COMMIT;
```

#### 세션 A
```sql
-- A1: id=1 행을 먼저 잠금(TX)
UPDATE t_deadlock SET v = v + 1 WHERE id = 1;

-- A2: 이제 A는 id=2를 업데이트하려고 시도
UPDATE t_deadlock SET v = v + 1 WHERE id = 2;
-- 이 순간, B가 id=2를 잡고 있으면 A는 B를 기다리게 됨
```

#### 세션 B
```sql
-- B1: id=2 행을 먼저 잠금(TX)
UPDATE t_deadlock SET v = v + 1 WHERE id = 2;

-- B2: 이제 B는 id=1을 업데이트하려고 시도
UPDATE t_deadlock SET v = v + 1 WHERE id = 1;
-- 이 순간, A가 id=1을 잡고 있으므로 B는 A를 기다리게 됨
```

#### 발생 결과
- A는 B가 잡은 id=2의 TX를 기다림
- B는 A가 잡은 id=1의 TX를 기다림
- 순환(A → B → A)이므로 Oracle이 즉시 감지하여 둘 중 하나에 ORA-00060 발생

데드락이 “순식간에” 터지는 타이밍:
- 두 번째 UPDATE(A2 또는 B2)가 실행되는 순간에 순환이 완성되며 즉시 ORA-00060이 날 수 있다.

---

### 2.3 데드락을 더 잘 이해하는 관찰 포인트
1) 데드락은 “같은 테이블”에서만 생기지 않는다. 여러 테이블에서 교차로 락을 잡아도 생긴다.
2) 트랜잭션이 길어질수록(커밋 늦을수록) 데드락 확률이 올라간다.
3) 대부분의 데드락은 “락 획득 순서가 일관되지 않아서” 생긴다.
   - 해결의 1순위는 “항상 같은 순서로 잠그기(예: id 오름차순)”이다.

---

## 3. TX–TM–TX 교차 구조 분석

### 3.1 왜 “TX만”이 아니라 “TX–TM–TX”가 중요하나
실무에서 락 분석을 하면 종종 다음처럼 보인다:
- 누군가가 행(TX)을 잡고 있고
- 동시에 테이블(TM)이 걸려 DDL이나 특정 DML이 막히거나
- FK/제약조건 때문에 다른 테이블에 추가 락(TX/TM)이 연쇄된다.

즉 “행락(TX) 하나”로 끝나는 게 아니라,
- (내가 잡은 TX) + (내가 잡은 TM)
- (상대가 잡은 TX) + (상대가 잡은 TM)
- (FK/제약조건 검사로 다른 테이블에 추가 락)
이 교차되며 문제를 만든다.

---

### 3.1.1 RS가 교차 구조의 출발점이 되는 경우
`SELECT ... FOR UPDATE` 는 “조회”처럼 보이지만 다음을 동시에 만든다:
- 테이블에 `TM(RS)`
- 행에 `TX`

즉, RS는 약한 테이블 락이지만 **TX를 유발하는 관문**이라서
교차 구조(특히 데드락) 분석에서 빠지면 설명이 끊긴다.

---

### 3.2 가장 흔한 교차: DML로 인해 TM(RX)도 항상 존재
```sql
UPDATE emp SET sal = sal + 100 WHERE empno = 100;
```
- `TX`: empno=100 행
- `TM(RX)`: emp 테이블

따라서:
```sql
ALTER TABLE emp ADD col1 NUMBER;
```
가 대기하는 이유는, 행(TX) 때문이 아니라 `TM(RX)` 때문이다.

---

### 3.3 FK로 확장되는 교차: 한 DML이 다른 테이블에 락을 “추가로” 건다

#### 테이블
```sql
CREATE TABLE parent (
  id NUMBER PRIMARY KEY,
  v  NUMBER
);

CREATE TABLE child (
  id        NUMBER PRIMARY KEY,
  parent_id NUMBER NOT NULL,
  v         NUMBER,
  CONSTRAINT fk_child_parent FOREIGN KEY (parent_id) REFERENCES parent(id)
);

INSERT INTO parent VALUES (1, 100);
INSERT INTO parent VALUES (2, 200);
INSERT INTO child VALUES (10, 1, 10);
INSERT INTO child VALUES (20, 2, 20);
COMMIT;
```

#### 케이스 A: child INSERT/UPDATE 시 parent에도 락 접근(무결성 검사)
```sql
INSERT INTO child(id, parent_id, v) VALUES (30, 1, 30);
```
개념적으로:
- child: `TX` + `TM(RX)`
- parent: 참조 무결성(부모 키 존재) 확인 과정에서 **약한 TM 락(RS 계열)** 이 추가로 등장할 수 있음
  - 목적: 부모 테이블에 대한 DDL/구조 변경 등과의 충돌을 줄이기 위한 테이블 차원의 보호
  - 실제 충돌/대기는 “부모 행/자식 행”의 TX 및 “부모 삭제/수정” 경로에서 더 자주 문제화됨

---

### 3.4 교차 구조가 데드락으로 이어지는 대표 패턴: “부모/자식 반대 순서”
#### 세션 A(부모 → 자식)
```sql
UPDATE parent SET v = v + 1 WHERE id = 1;
UPDATE child  SET v = v + 1 WHERE parent_id = 1;
```

#### 세션 B(자식 → 부모)
```sql
UPDATE child  SET v = v + 1 WHERE parent_id = 1;
UPDATE parent SET v = v + 1 WHERE id = 1;
```

- A는 parent의 `TX`를 보유한 채 child의 `TX`를 요청
- B는 child의 `TX`를 보유한 채 parent의 `TX`를 요청
- 순환이 되면 ORA-00060 가능

---

### 3.5 TX–TM–TX를 분석할 때 체크리스트
1) TX(행) 충돌인가? 같은 행을 동시에 바꾸려는가?
2) TM(테이블) 충돌인가? 누가 DDL을 시도하는가?
3) FK/제약조건 때문에 다른 테이블을 함께 건드리는가?
4) 락 획득 순서가 코드 경로마다 달라지는가?
5) 트랜잭션이 너무 길어 락 유지 시간이 과도한가?

---

## 4. 배치 UPDATE에서 락 줄이는 실전 분할 전략(상세 예시)

배치에서 락 문제가 커지는 이유:
- 한번에 많은 행을 오래 잡고 있으면, 그 기간 동안 OLTP 트래픽이 같은 행/범위를 건드리며 대기 증가
- Undo/Redo 증가 + 인덱스 갱신 + 블록 경합까지 겹치면 시스템 전체가 느려짐

목표:
- 한 번에 잡는 락 범위를 줄이고
- 락 유지 시간을 줄이며
- 충돌 가능성을 낮춘다

---

### 4.1 전략 1: “짧은 트랜잭션”으로 잘게 커밋(Chunk Commit)

#### 나쁜 예(한 방에 대량)
```sql
UPDATE orders
SET status = 'EXPIRED'
WHERE status = 'PENDING'
  AND created_at < SYSDATE - 30;

COMMIT;
```

#### 좋은 예(ROWID로 10,000개씩)
```sql
UPDATE orders o
SET status = 'EXPIRED'
WHERE o.ROWID IN (
  SELECT rid
  FROM (
    SELECT ROWID AS rid
    FROM orders
    WHERE status = 'PENDING'
      AND created_at < SYSDATE - 30
    FETCH FIRST 10000 ROWS ONLY
  )
);

COMMIT;
```

주의:
- chunk 크기(예: 5,000~50,000)는 시스템 상황에 맞춰 조절
- 너무 작으면 커밋 오버헤드 증가, 너무 크면 락 시간 증가

---

### 4.2 전략 2: “SKIP LOCKED”로 경쟁 회피(병렬 배치에 유리)
```sql
SELECT ROWID
FROM orders
WHERE status = 'PENDING'
  AND created_at < SYSDATE - 30
FOR UPDATE SKIP LOCKED
FETCH FIRST 10000 ROWS ONLY;

UPDATE orders
SET status = 'EXPIRED'
WHERE ROWID IN (...);

COMMIT;
```

장점:
- 워커 간 데드락/대기 감소
- 처리량 안정

주의:
- “대기 대신 건너뛰기”라서 루프/재시도 설계 필요

---

### 4.3 전략 3: 처리 대상 분리(해시/범위/파티션)
```sql
UPDATE orders
SET status = 'EXPIRED'
WHERE status = 'PENDING'
  AND created_at < SYSDATE - 30
  AND MOD(id, :N) = :worker_no;

COMMIT;
```

---

### 4.4 전략 4: 인덱스/조건 최적화로 “잠그는 행 수” 자체를 줄이기
- WHERE 조건 컬럼 인덱스 고려(복합 인덱스 등)
- 단, 인덱스는 DML 비용을 늘릴 수 있으므로 배치/OLTP 특성에 맞게 조절

---

### 4.5 전략 5: FK 컬럼 인덱스로 전파 락/경합 방지
```sql
CREATE INDEX idx_child_parent_id ON child(parent_id);
```

효과:
- 부모 변경 시 자식에서 필요한 행만 빠르게 검사
- 자식 테이블 전체 스캔/락 확률 감소

---

## 5. 결론

1) Oracle은 읽기(SELECT)에 공유락을 거의 쓰지 않는다. MVCC + Undo로 “과거 버전”을 읽어 일관성을 보장한다.
2) 데드락은 순환 대기라서 기다려도 안 풀린다. 그래서 Oracle이 감지하면 즉시 ORA-00060으로 끊는다.
3) 실전 락 문제는 TX(행)만이 아니라, DML이 함께 잡는 TM(테이블) 및 FK/제약조건으로 확장되는 교차 구조(TX–TM–TX)에서 터진다.
4) 추가로, `SELECT ... FOR UPDATE` 는 **TM(RS) + TX** 를 획득하므로 “읽기처럼 보이는 락 시작점”이 된다.
5) 배치 UPDATE 락 줄이기의 핵심은:
   - 트랜잭션을 짧게(Chunk Commit)
   - 대상 분리(범위/해시/파티션)
   - 경쟁 회피(SKIP LOCKED)
   - 잠그는 행 수 자체 감소(인덱스/조건)
   - FK 컬럼 인덱스로 전파 락 최소화

---
