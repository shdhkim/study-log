# Oracle Lock · 격리수준 · Spring 기본값 총정리
(테이블 락(TM) / 행 락(TX), RS/RX/S/SRX/X, “락은 권한이 아니라 제한”, READ COMMITTED vs SERIALIZABLE, DB별 차이, Spring 기본 동작)

작성 기준: Oracle Database, 기본 격리수준 READ COMMITTED, 일반적인 OLTP 환경  
추가 비교: MySQL(InnoDB), PostgreSQL(개념 비교) / Spring(@Transactional) 기본값

---

## 0. 이 문서의 목표

1) **테이블 락(TM)** 과 **행 락(TX)** 를 “접근 차단” 관점이 아니라, **무엇을 제한하는지** 관점에서 정확히 이해  
2) **RS/RX/S/SRX/X** 가 **언제 생기고 무엇과 충돌**하는지 “규칙”으로 정리  
3) “수정 중인데 다른 트랜잭션에서 테이블 봉인” 같은 상황이 왜 문제가 되는지(강한 TM 락과 TX의 관계)  
4) **격리수준은 락을 바꾸는가?** → Oracle에서의 정확한 답과 이유  
5) DB마다 격리수준이 왜 다르게 체감되는지: **읽기 기준(스냅샷)** + **충돌 처리(wait vs error)**  
6) Spring에서 설정 안 하면 어떤 기본값이 적용되는지(격리수준/락)

---

## 1. 용어/약어

### 1.1 v$lock에서 자주 보는 락 타입

| 약어 | 풀네임 | 의미(감각) |
|---|---|---|
| TX | Transaction Enqueue Lock | 보통 “행 변경(DML) 충돌”과 연결되는 트랜잭션 락 |
| TM | DML Table Enqueue Lock | 테이블 수준의 “작업 규칙(주로 DDL/DML 공존)”을 관리하는 락 |

주의:
- “TX = 행락”이라고 부르지만, 정확히는 **트랜잭션 엔큐**이며 행 변경과 연동되어 충돌/대기를 만든다.
- “TM = 테이블 전체 배타”는 오해다. **TM은 모드에 따라 공존 가능**하며 목적이 다르다.

### 1.2 TM 모드(Oracle에서 흔히 쓰는 표기)

| 약어 | 풀네임 | 핵심 감각 |
|---|---|---|
| RS | Row Share (for TM) | “행 락이(또는 날 수) 있다”는 선언/표식 성격 |
| RX | Row Exclusive (for TM) | 일반 DML이 잡는 기본 모드(다른 DML 공존, DDL은 차단) |
| S | Share (for TM) | “읽기 전용”에 가깝게 DML을 차단하는 테이블 락 |
| SRX | Share Row Exclusive (for TM) | 매우 강한 테이블 락(드묾) |
| X | Exclusive (for TM) | 테이블 봉인(거의 모든 작업 차단) |

---

## 2. 락은 “권한 부여”가 아니라 “제약(제한)”이다

### 2.1 핵심 문장
- 락은 “이 트랜잭션에게 특별한 권한을 준다”가 아니라  
  **다른 트랜잭션이 같은 자원에 대해 할 수 있는 행동을 제한**한다.

### 2.2 왜 “권한처럼 보이는가”
- 락을 잡은 트랜잭션은 작업을 진행할 수 있고  
- 충돌하는 작업을 하려는 다른 트랜잭션은 대기/실패를 경험한다  
→ 체감상 “락 소유자가 우선권을 가진 것처럼” 보일 뿐, 본질은 **타인 제약**이다.

---

## 3. 테이블 락(TM)은 “테이블 접근 차단”이 아니다

### 3.1 흔한 오해
- “테이블 락이 걸리면 테이블에 접근을 못 한다” → Oracle 기준으로 보통 오해다.

### 3.2 정확한 정의(외워도 되는 문장)
- **TM은 테이블 접근 자체를 막는 락이 아니라**,  
  **이 테이블에서 어떤 종류의 작업이 허용되는지/충돌하는지**를 관리하는 **규칙 락**이다.

### 3.3 TM이 주로 관리하는 것(핵심 2가지)

#### (1) DDL vs DML 충돌 관리(가장 중요)
세션 A:
```sql
UPDATE emp SET sal = sal + 100 WHERE empno = 1;
-- COMMIT 안 함
```

이때 emp 테이블에는 일반적으로:
- TM(RX) (DML 진행 중 표시)
- TX (행 변경에 따른 트랜잭션 락)

세션 B:
```sql
ALTER TABLE emp ADD col1 NUMBER;
```

결과:
- 보통 **대기** (DML 진행 중인데 구조 변경은 위험)

TM의 핵심 역할은:
- “이 테이블에서 DML이 진행 중이니, 구조 변경(DDL)은 지금 하지 마라”라는 신호를 주는 것

#### (2) “행 락(TX)이 발생 가능한 상태”를 테이블 수준에서 표시(특히 RS)
`SELECT ... FOR UPDATE` 같은 잠금 읽기에서 TM(RS) 같은 모드가 관여한다(아래 RS 절 참고).

### 3.4 TM이 “항상” 막는 것 / “항상” 막지 않는 것

- 일반적으로 TM(RX)는:
  - DDL을 막는다(대기 유발)
  - 다른 DML은 공존 가능(행 충돌은 TX에서)
- 일반 SELECT는:
  - TM/TX 때문에 보통 막히지 않는다 (Oracle은 MVCC로 읽음)

---

## 4. 행 락(TX)은 “접근 차단”이 아니라 “수정 충돌 제어”다

### 4.1 핵심 문장(정확한 표현)
- “행 락은 접근을 막는다”는 표현은 부정확하다.
- 정확히는: **행 락(TX)은 같은 행에 대한 ‘수정(UPDATE/DELETE/잠금 읽기)’을 막는다.**

### 4.2 예시
세션 A:
```sql
UPDATE emp SET sal = sal + 100 WHERE empno = 1;
-- COMMIT 안 함
```

세션 B:
```sql
SELECT * FROM emp WHERE empno = 1;                 -- 가능(Undo/MVCC)
UPDATE emp SET sal = 0 WHERE empno = 1;            -- 대기(TX 충돌)
DELETE FROM emp WHERE empno = 1;                   -- 대기(TX 충돌)
UPDATE emp SET sal = 0 WHERE empno = 2;            -- 가능(다른 행)
```

---

## 5. “테이블 단위 DDL은 TM, 행 충돌은 TX”가 기본 뼈대다
---

## 3.5 행 락(TX)과 테이블 락(TM)의 “용도”를 한 문장으로 못 박기

실무에서 가장 헷갈리는 지점을 사용 목적(용도) 기준으로 한 번에 정리하면 다음 2문장으로 끝난다.

- **행 락(TX)의 용도:** *같은 행(row)에 대한 동시 수정(UPDATE/DELETE/잠금 읽기)을 막기 위한 것*  
  - 즉, “읽기(SELECT)를 막는 락”이 아니라 **수정 경쟁을 제어하는 락**이다.
- **테이블 락(TM)의 용도:** *테이블 수준에서 DDL(ALTER/DROP/TRUNCATE 등)과 DML이 안전하게 공존하도록, 특히 DML 수행 중 테이블 구조 변경(DDL)을 막기 위한 것*  
  - 즉, “테이블 접근 자체를 막는 락”이 아니라 **DDL/DML 충돌 규칙을 관리하는 락**이다.

짧은 비교 표(용도 중심):

| 구분 | 행 락(TX) | 테이블 락(TM) |
|---|---|---|
| 1차 목적(용도) | 같은 행의 **수정 충돌 방지** | 테이블 수준 **DDL 차단/규칙 관리** |
| 무엇을 주로 막나 | 같은 행의 UPDATE/DELETE/SELECT FOR UPDATE | ALTER/DROP/TRUNCATE 등 DDL (모드에 따라 DML도) |
| 읽기(일반 SELECT) 차단 | 기본적으로 없음(MVCC) | 기본적으로 없음(MVCC) |

이 관점으로 보면 다음이 자연스럽게 정리된다.

- “수정 중인데 다른 트랜잭션이 DDL을 하려 한다” → **TM이 DDL을 대기시킨다**  
- “같은 행을 동시에 UPDATE하려 한다” → **TX 충돌로 대기한다**



### 5.1 정제된 정답 문장
- **테이블 구조 변경(DDL) 충돌은 TM이**,  
- **같은 행에 대한 데이터 변경 충돌은 TX가** 담당한다.

### 5.2 예외(의도적으로 강한 테이블 봉인을 거는 경우)
- `LOCK TABLE ... IN SHARE MODE` (TM(S))
- `LOCK TABLE ... IN EXCLUSIVE MODE` (TM(X))
- `LOCK TABLE ... IN SHARE ROW EXCLUSIVE MODE` (TM(SRX))

이 경우에는 TM 자체가 DML을 강하게 제한할 수 있다(읽기 보호/봉인 목적).

---

## 6. RS(Row Share)는 무엇인가

### 6.1 한 문장 정의
- **RS는 “이 테이블에서 행 락(TX)이 (이미 있거나) 발생할 수 있다”는 것을 알리는 선언/표식 성격의 TM 락**이다.

### 6.2 언제 생기나(대표)
```sql
SELECT * FROM emp WHERE empno = 1 FOR UPDATE;
```

개념적으로:
- TM(RS): 테이블 수준에서 “잠금 읽기/행 선점이 발생한다” 표시
- TX(행 관련): 실제로 해당 행에 대한 수정/삭제/다른 잠금 읽기를 막는 충돌의 주역

### 6.3 RS가 하는 일(왜 존재하나)
- RS 자체는 “테이블 전체 접근 차단”이 목적이 아니다.
- RS는 “강한 테이블 봉인(X/SRX 등) 요청”과 **충돌 판단**을 가능하게 해준다.

---

## 7. 왜 X/SRX 같은 강한 테이블 락은 행 락과 충돌하는가

### 7.1 핵심 논리(한 문장)
- **강한 테이블 락(X/SRX)은 ‘테이블이 안정적(봉인) 상태’라는 전제를 필요로 하는데, 행 락(TX)이 존재하면 행 상태가 미확정(커밋/롤백 가능)이라 그 전제가 깨진다.**

### 7.2 “수정 중인데 다른 트랜잭션이 테이블 봉인”이 왜 문제인가
세션 A(수정 중):
```sql
UPDATE emp SET sal = sal + 100 WHERE empno = 1;
-- 아직 COMMIT/ROLLBACK 전
```

세션 B(테이블 봉인 시도):
```sql
LOCK TABLE emp IN EXCLUSIVE MODE;   -- TM(X) 요청
```

여기서 공존을 허용하면:
- 테이블은 “봉인”됐다고 하는데
- 내부에는 “미확정 변경(롤백 가능)”이 존재한다  
→ 봉인의 의미가 무너진다.

그래서 Oracle은 보통:
- TX(행 변경) / RS(행 락 가능성 표식)가 존재하면
- 강한 TM(X/SRX) 같은 봉인 락은 **대기**시키는 방향으로 설계된다.

---

## 8. “락 건 트랜잭션도 접근 못 하는 락”이 있나?

### 8.1 결론
- “락을 건 트랜잭션조차 접근 못 하게 만드는 락”은 일반적으로 없다.
- 다만 “자기 자신이 추가 락을 얻으려다” **락 변환/업그레이드 때문에 스스로 대기**하는 상황은 있다.

### 8.2 대표 패턴: 락 변환(lock conversion) 대기
세션 A:
```sql
LOCK TABLE emp IN SHARE MODE;  -- TM(S)
```

세션 A가 같은 트랜잭션에서:
```sql
UPDATE emp SET sal = sal + 1 WHERE empno = 1;
```

설명:
- UPDATE는 보통 TM(RX)가 필요
- 현재는 TM(S) 보유
- Oracle은 S → RX로 **락 업그레이드(변환)** 를 시도
- 그런데 다른 세션이 이미 TM(S)를 잡고 있으면 업그레이드가 호환되지 않아 **본인도 대기**할 수 있다

이건 “내 락이 나를 막는 락”이 아니라:
- **추가 락 요청(request)을 만족시키지 못해서** 생기는 자기 대기다.

---

## 9. 격리수준은 Oracle에서 락을 바꾸는가?

### 9.1 결론(정확히)
- Oracle에서 격리수준을 바꿔도 **CRUD가 사용하는 기본 TX/TM 구조는 거의 변하지 않는다.**
- 달라지는 것은 주로:
  1) **읽기 기준(어떤 시점의 데이터 버전을 읽는지)**  
  2) **충돌 처리 방식(wait vs error)**

### 9.2 READ COMMITTED vs SERIALIZABLE (Oracle 기준)

#### (1) READ COMMITTED (기본)
- SELECT: 문장 실행 시점 기준으로 “최근 커밋 데이터”를 읽는 경향
- 같은 SELECT를 트랜잭션 내에서 다시 실행하면 결과가 바뀔 수 있다(Non-repeatable read 가능)
- 쓰기 충돌: 주로 **행 수준은 대기(TX 충돌)**

#### (2) SERIALIZABLE
- SELECT: 트랜잭션 시작 시점의 스냅샷(일관된 버전)을 유지하는 쪽으로 동작
- 중요한 차이: 어떤 동시 변경과 논리적으로 충돌하면 **대기보다 오류로 실패**하는 케이스가 생길 수 있음
  - 대표 에러: `ORA-08177: cannot serialize access for this transaction`
- 즉 “락이 더 강해진다”가 아니라, **직렬성 보장을 위해 충돌을 실패로 처리**하는 방향이 더 핵심

### 9.3 예시로 보는 SERIALIZABLE의 ‘범위 논리 충돌’ 감각
T1(SERIALIZABLE):
```sql
SELECT COUNT(*) FROM emp WHERE deptno = 10;
```

T2:
```sql
INSERT INTO emp (...) VALUES (..., 10);
COMMIT;
```

T1:
```sql
INSERT INTO emp (...) VALUES (..., 10);
-- 상황에 따라 ORA-08177 가능
```

이 예시는 “행 하나 충돌”이 아니라:
- T1이 읽은 조건 범위(deptno=10)에 대해
- 중간에 T2가 커밋 변경을 해버리면
- T1이 직렬성 가정을 유지할 수 없어서 오류로 중단될 수 있다는 감각을 보여준다.

---

## 10. DB마다 격리수준이 다르게 체감되는 이유(읽기 기준 + 충돌 처리)

같은 “SERIALIZABLE”이라도 DB가 선택한 구현 방식이 다르다. 핵심 축은 두 가지다.

### 10.1 읽기 기준(스냅샷이 statement 단위인지 transaction 단위인지)
- READ COMMITTED: statement 단위 스냅샷을 택하는 DB가 많다
- REPEATABLE READ: transaction 단위 스냅샷을 택하는 DB가 많다
- SERIALIZABLE: transaction 스냅샷 + 추가 제약(락/검증/abort) 중 하나를 더한다

### 10.2 충돌 처리 방식
- 어떤 DB는 충돌을 **대기(wait)** 로 해결(락을 더 적극적으로 사용)
- 어떤 DB는 충돌을 **실패(error/abort)** 로 해결(사후 검증, 직렬성 위반 시 중단)

### 10.3 대표적인 체감 차이(간단 비교)

#### Oracle
- 읽기: MVCC(Undo) 기반, 읽기 락을 최소화
- SERIALIZABLE: 충돌을 대기보다 오류(예: ORA-08177)로 처리하는 체감이 생길 수 있음

#### MySQL(InnoDB)
- REPEATABLE READ가 기본인 경우가 많고
- 범위(phantom) 보호를 위해 **gap lock / next-key lock** 등 “범위 락”이 강하게 개입할 수 있다  
  → 격리수준을 높이면 “대기”가 늘어난 것처럼 체감하기 쉬움

#### PostgreSQL
- MVCC 기반
- SERIALIZABLE 구현은 내부적으로 위험한 패턴을 감지해 **트랜잭션을 abort(실패)** 시키는 방식이 섞여 있어 재시도 패턴이 중요해질 수 있음

---

## 11. Spring에서 격리수준/락을 설정하지 않으면 무엇이 기본으로 적용되나?

### 11.1 Spring의 기본 격리수준
```java
@Transactional
public void service() { ... }
```

- `isolation`을 지정하지 않으면: `Isolation.DEFAULT`
- 의미: **Spring이 강제하지 않고 DB 기본 격리수준을 따른다**

Oracle이라면 보통:
- DB 기본 격리수준 = READ COMMITTED  
→ Spring도 결과적으로 READ COMMITTED를 따라간다.

### 11.2 Spring이 “행 락/테이블 락”을 기본으로 설정하나?
- 아니다. Spring/JPA는 “트랜잭션 경계/옵션”을 제공할 뿐
- 실제 락(TX/TM)은 DB가 SQL 실행 중 자동으로 결정한다

즉:
- INSERT/UPDATE/DELETE를 수행하면 Oracle이 자동으로 TX/TM을 건다
- `SELECT ... FOR UPDATE` 같은 잠금 읽기 또는
- `LOCK TABLE ...` 같은 명령을 사용했을 때에만 강한 TM 모드가 명시적으로 등장한다

---

## 12. 핵심 문장 10개

1) TM은 “테이블 접근 차단”이 아니라 **테이블 작업 규칙**을 관리한다.  
2) TX는 “행 접근 차단”이 아니라 **같은 행에 대한 수정 충돌**을 막는다.  
3) Oracle에서 일반 SELECT는 보통 락 없이 **MVCC(Undo)로 버전을 읽는다.**  
4) DDL 충돌은 주로 TM이 관여하고, DML 충돌은 주로 TX가 만든다.  
5) RS는 “행 락이 있거나 생길 수 있음”을 알리는 **표식 성격**이 강하다.  
6) 강한 테이블 봉인(X/SRX)은 “테이블이 안정적”이라는 전제를 필요로 한다.  
7) 행 변경(TX)이 존재하면 강한 봉인은 그 전제가 깨져 **대기/충돌**이 생긴다.  
8) “내가 락을 잡았는데도 내가 멈춤”은 보통 **락 업그레이드/추가 요청(request)** 때문이다.  
9) Oracle에서 격리수준은 락 구조(TX/TM)를 바꾸기보다 **읽기 기준과 충돌 처리 정책**을 바꾼다.  
10) Spring에서 isolation 미지정은 `DEFAULT`이며, **DB 기본 격리수준**을 따른다.

---

## 13. 부록: 확인용 SQL (v$lock 관점)

대기/중첩(보유 + 요청)을 보려면 “보유(lmode)”와 “요청(request)”을 구분한다.

```sql
SELECT type, lmode, request, block
FROM v$lock
WHERE sid = SYS_CONTEXT('USERENV','SID');
```

- `lmode > 0`: 현재 보유한 락
- `request > 0`: 추가로 요청 중인 락
- `lmode = 0 AND request > 0`: 못 받아서 대기 중

---


