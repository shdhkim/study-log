# Oracle에서 “읽기만 되고 수정이 안 되는 락”과 락 호환 조합 정리
(TX / TM, 읽기 전용 락, 충돌하지 않는 락 조합을 중심으로)

작성 기준: Oracle Database, READ COMMITTED

---

## 1. 먼저 결론부터

### 1️⃣ 읽기만 되고 수정이 안 되는 락은 **있다**
- 단, **행 락(TX)** 이 아니라
- **테이블 락(TM)의 SHARE 계열**이다.

### 2️⃣ 락은 “무조건 충돌”이 아니다
- Oracle 락에는 **호환성(Compatibility)** 이 존재
- 어떤 락 조합은 **서로 동시에 존재 가능**
- 어떤 조합은 **요청 단계에서 바로 대기**


### 보충) RS(Row Share) 락은 읽기 전용 락이 아니다

- RS는 테이블 락(TM)의 가장 약한 모드
- 의미: “이 테이블에서 행 락(TX)이 발생할 수 있음”을 선언
- SELECT FOR UPDATE에서 사용
- 읽기 전용 효과 없음
- DML 차단 목적도 아님

---

## 2. 읽기만 되고 수정이 안 되는 락

### 2.1 TM(S) – Table Lock, Share Mode

```sql
LOCK TABLE emp IN SHARE MODE;
```

의미:
- 테이블을 **논리적으로 읽기 전용** 상태로 만듦
- 다른 세션:
  - SELECT 가능
  - INSERT / UPDATE / DELETE 불가
  - DDL 불가

정리 표:

| 작업 | 가능 여부 |
|---|---|
| SELECT | 가능 |
| INSERT | 불가 |
| UPDATE | 불가 |
| DELETE | 불가 |
| DDL | 불가 |

이게 가장 전형적인  
👉 **“읽기만 되고 수정은 안 되는 락”**

---

### 2.2 TM(SRX) – Share Row Exclusive Mode

```sql
LOCK TABLE emp IN SHARE ROW EXCLUSIVE MODE;
```

특징:
- SELECT 가능
- 모든 DML 강하게 차단
- 실무에서는 거의 사용 안 함

체감:
- “읽기만 되고, 나 포함해서 아무도 못 고침”

---

## 3. 근데 UPDATE 중인데 SELECT는 왜 되나? (중요한 오해)

```sql
-- 세션 A
UPDATE emp SET sal = sal + 100 WHERE empno = 1;
```

```sql
-- 세션 B
SELECT * FROM emp WHERE empno = 1;
```

이건 **읽기 전용 락이 아님**.

이유:
- SELECT는 락을 공유해서 읽는 게 아니라
- **Undo(MVCC)** 로 과거 버전을 읽음

즉:
- “읽기만 된다” ≠ “읽기 락이 있다”
- **락 자체가 없음**

---

## 4. 락끼리 충돌 안 하는 조합 (핵심 파트)

Oracle 락은 **호환성 매트릭스**를 가진다.

---

### 4.1 TM 락 호환성 요약 (핵심만)


| 보유 락 \ 요청 락 | TM(RS) | TM(S) | TM(RX) | TM(SRX) | TM(X) |
|---|---|---|---|---|---|
| TM(RS)  | 가능 | 가능 | 가능 | 불가 | 불가 |
| TM(S)   | 가능 | 가능 | 불가 | 불가 | 불가 |
| TM(RX)  | 가능 | 불가 | 가능 | 불가 | 불가 |
| TM(SRX) | 불가 | 불가 | 불가 | 불가 | 불가 |
| TM(X)   | 불가 | 불가 | 불가 | 불가 | 불가 |


---

### 4.2 충돌 안 나는 대표 조합

#### ① TM(RX) ↔ TM(RX)
```sql
-- 세션 A
UPDATE emp SET sal = sal + 10 WHERE empno = 1;

-- 세션 B
UPDATE emp SET sal = sal + 10 WHERE empno = 2;
```

- 둘 다 TM(RX)
- 서로 공존 가능
- 실제 충돌은 **TX(행)** 에서만 발생

---

#### ② TM(S) ↔ TM(S)
```sql
-- 세션 A
LOCK TABLE emp IN SHARE MODE;

-- 세션 B
LOCK TABLE emp IN SHARE MODE;
```

- 여러 세션이 동시에 읽기 보호 가능
- DML은 모두 차단

---

#### ③ TX ↔ SELECT
```sql
-- 세션 A
UPDATE emp SET sal = sal + 10 WHERE empno = 1;

-- 세션 B
SELECT * FROM emp WHERE empno = 1;
```

- TX와 SELECT는 충돌 개념이 없음
- SELECT는 락을 잡지 않음

---


#### ④ TM(RS) ↔ TM(RS) / TM(RS) ↔ TM(RX)
```sql
-- 세션 A
SELECT * FROM emp WHERE empno = 1 FOR UPDATE;

-- 세션 B
UPDATE emp SET sal = sal + 10 WHERE empno = 2;


설명:
- SELECT FOR UPDATE → TM(RS)
- UPDATE → TM(RX)
- TM 레벨에서는 충돌 없음
- 실제 대기는 TX(행 락) 기준

## 5. “락을 걸었는데 나도 수정이 안 되는” 대표 패턴

### 5.1 TM(S) 보유 → UPDATE 시도

```sql
-- 세션 A
LOCK TABLE emp IN SHARE MODE;
```

```sql
-- 세션 A
UPDATE emp SET sal = sal + 1 WHERE empno = 1;
```

설명:
- UPDATE를 하려면 TM(RX)가 필요
- 이미 TM(S)를 가진 상태에서
- **S → RX 락 변환(업그레이드)** 시도
- 다른 세션이 TM(S)를 잡고 있으면
  → 변환이 막혀서 **본인도 대기**

---

## 6. TX 락에는 “읽기 전용” 개념이 없다

중요한 구분:

| 구분 | TX (행 락) | TM (테이블 락) |
|---|---|---|
| 읽기 전용 락 | 없음 | 있음 (S, SRX) |
| 공유 개념 | 없음 | 있음 |
| 목적 | 행 수정 충돌 방지 | 테이블 규칙/공존 관리 |

- TX는 항상 “수정 보호용”
- 읽기 전용 개념은 TM에서만 성립

---

## 7. 한 장 요약 (암기용)

1) **읽기만 되고 수정 안 되는 락은 TM(S) 계열**
2) UPDATE 중 SELECT가 되는 건 락 공유가 아니라 Undo
3) TM(RX) ↔ TM(RX)는 충돌 안 남 (DML 공존)
4) TM(S) ↔ TM(S)는 충돌 안 남 (읽기 보호)
5) TX에는 읽기 전용 개념이 없다
6) “나도 못 고치는 락”은 대부분 **락 업그레이드 대기**

---

## 8. 실무에서 이걸 왜 알아야 하나

- “읽기만 가능한 상태로 잠가야 할 때” → TM(S)
- “DML은 되는데 DDL만 막히는 이유” → TM(RX)
- “왜 SELECT는 항상 잘 되지?” → MVCC
- “왜 내가 락 걸었는데도 멈췄지?” → 락 변환

---
