# Oracle SQL 총정리 

> 기준: Oracle 11g ~ 19c


---

## 0. Oracle SQL 핵심 특징 요약

* NULL은 값이 아님 → `= NULL` ❌, `IS NULL` ✅
* 문자열 결합: `||`
* 날짜 기본 단위는 **일(day)**
* DDL은 **자동 COMMIT**
* `ROWNUM`은 `ORDER BY`보다 먼저 적용됨

---

## 1. SELECT 기본

```sql
SELECT col1, col2
FROM table_name
WHERE condition
ORDER BY col1 DESC;
```

```sql
SELECT DISTINCT deptno FROM emp;
```

---

## 2. SELECT 절 서브쿼리 (Scalar Subquery)

> SELECT 절에 들어가는 서브쿼리는 **반드시 단일 행 · 단일 컬럼**을 반환해야 하며,
> 이를 **스칼라 서브쿼리(Scalar Subquery)** 라고 한다.

---

### 2.1 기본 구조

```sql
SELECT empno,
       ename,
       (SELECT d.dname FROM dept d WHERE d.deptno = e.deptno) AS dept_name
FROM emp e;
```

* 각 행마다 내부 질의가 실행됨
* 결과는 컬럼처럼 사용 가능

---

### 2.2 집계 결과를 SELECT 절에서 사용

```sql
SELECT empno,
       ename,
       sal,
       (SELECT AVG(sal) FROM emp) AS company_avg_sal
FROM emp;
```

---

### 2.3 SELECT 절 서브쿼리 + CASE

```sql
SELECT empno,
       ename,
       sal,
       CASE
         WHEN sal > (SELECT AVG(sal) FROM emp) THEN 'ABOVE_AVG'
         ELSE 'BELOW_AVG'
       END AS sal_level
FROM emp;
```

---

### 2.4 SELECT 절 서브쿼리 vs JOIN

```sql
-- SELECT 절 서브쿼리
SELECT empno,
       ename,
       (SELECT d.dname FROM dept d WHERE d.deptno = e.deptno) AS dept_name
FROM emp e;

-- JOIN 방식 (대량 데이터 권장)
SELECT e.empno, e.ename, d.dname
FROM emp e
JOIN dept d ON d.deptno = e.deptno;
```

* 소량 데이터 → SELECT 절 서브쿼리 OK
* 대량 데이터 → JOIN 권장 (성능)

---

## 3. WHERE 조건

### 2.1 비교 / 논리

```sql
WHERE sal >= 3000
  AND deptno = 10
```

### 2.2 BETWEEN / IN / LIKE

```sql
WHERE sal BETWEEN 2000 AND 3000
WHERE deptno IN (10, 20)
WHERE ename LIKE 'S%'
```

### 2.3 NULL 처리

```sql
WHERE comm IS NULL
WHERE comm IS NOT NULL
```

### 2.4 WHERE 절 서브쿼리 (내부 질의)

#### 단일 행 서브쿼리

```sql
SELECT *
FROM emp
WHERE sal = (SELECT MAX(sal) FROM emp);
```

#### 다중 행 서브쿼리

```sql
SELECT *
FROM emp
WHERE deptno IN (SELECT deptno FROM dept WHERE loc = 'DALLAS');
```

#### EXISTS / NOT EXISTS

```sql
SELECT *
FROM emp e
WHERE EXISTS (
  SELECT 1
  FROM dept d
  WHERE d.deptno = e.deptno
);
```

```sql
SELECT *
FROM dept d
WHERE NOT EXISTS (
  SELECT 1
  FROM emp e
  WHERE e.deptno = d.deptno
);
```

---

## 3. 함수 총정리

### 3.1 NVL / COALESCE / NULLIF

```sql
SELECT NVL(comm, 0) FROM emp;
SELECT COALESCE(comm, bonus, 0) FROM emp;
SELECT NULLIF(a, b) FROM dual;
```

---

### 3.2 DECODE (Oracle 전용 조건 분기)

```sql
SELECT ename,
       DECODE(deptno,
              10, 'ACCOUNT',
              20, 'RESEARCH',
              'ETC') AS dept_name
FROM emp;
```

> CASE 문으로 대체 가능하지만 레거시 SQL에 매우 많음

---

### 3.3 CASE WHEN THEN

```sql
SELECT ename, sal,
       CASE
         WHEN sal >= 5000 THEN 'A'
         WHEN sal >= 3000 THEN 'B'
         ELSE 'C'
       END AS grade
FROM emp;
```

#### CASE + 집계

```sql
SELECT deptno,
       SUM(CASE WHEN sal >= 3000 THEN 1 ELSE 0 END) AS high_cnt
FROM emp
GROUP BY deptno;
```

---

### 3.4 문자 함수

```sql
SELECT UPPER('abc'), LOWER('ABC') FROM dual;
SELECT SUBSTR('HELLO',2,3) FROM dual;
SELECT INSTR('HELLO','L') FROM dual;
SELECT TRIM(' hi ') FROM dual;
```

---

### 3.5 숫자 함수

```sql
SELECT ROUND(3.14,1), TRUNC(3.14,1) FROM dual;
SELECT CEIL(1.2), FLOOR(1.8) FROM dual;
```

---

### 3.6 날짜 / 시간 함수

```sql
SELECT SYSDATE, SYSTIMESTAMP FROM dual;
```

```sql
SELECT SYSDATE + 1 AS tomorrow FROM dual;
SELECT ADD_MONTHS(SYSDATE, 1) FROM dual;
SELECT LAST_DAY(SYSDATE) FROM dual;
```

---

### 3.7 TO_CHAR / TO_DATE / TO_TIMESTAMP

```sql
SELECT TO_CHAR(SYSDATE, 'YYYY-MM-DD HH24:MI:SS') FROM dual;
```

```sql
SELECT TO_DATE('2026-01-16','YYYY-MM-DD') FROM dual;
```

```sql
SELECT TO_TIMESTAMP('2026-01-16 12:30:10.123',
                    'YYYY-MM-DD HH24:MI:SS.FF3') FROM dual;
```

---

## 4. JOIN (INNER / OUTER / SELF)

### 4.1 INNER JOIN (기본)

```sql
SELECT e.ename, d.dname
FROM emp e
JOIN dept d ON d.deptno = e.deptno;
```

---

### 4.2 OUTER JOIN (ANSI 표준)

#### LEFT OUTER JOIN

```sql
SELECT e.ename, d.dname
FROM emp e
LEFT JOIN dept d ON d.deptno = e.deptno;
```

* emp는 모두 유지
* dept가 없으면 NULL

#### RIGHT OUTER JOIN

```sql
SELECT e.ename, d.dname
FROM emp e
RIGHT JOIN dept d ON d.deptno = e.deptno;
```

#### FULL OUTER JOIN

```sql
SELECT e.ename, d.dname
FROM emp e
FULL OUTER JOIN dept d ON d.deptno = e.deptno;
```

---

### 4.3 Oracle 구식 OUTER JOIN (+)

```sql
SELECT e.ename, d.dname
FROM emp e, dept d
WHERE e.deptno = d.deptno(+);
```

* (+)가 붙은 쪽이 NULL 허용
* WHERE 절에만 사용 가능
* ANSI JOIN과 혼용 ❌

---

### 4.4 SELF JOIN

```sql
SELECT e.ename, m.ename AS manager
FROM emp e
LEFT JOIN emp m ON m.empno = e.mgr;
```

---

## 5. FROM 절 서브쿼리 (인라인 뷰)

> FROM 절에 들어가는 서브쿼리는 **테이블처럼 동작**하며, 이를 **인라인 뷰(Inline View)** 라고 부른다.

### 5.1 기본 구조

```sql
SELECT *
FROM (
  SELECT empno, ename, sal
  FROM emp
  WHERE sal >= 3000
) t
WHERE t.sal < 6000;
```

* FROM 절 서브쿼리는 **반드시 별칭(alias)** 필요
* 외부 SELECT는 내부 결과 집합을 대상으로 다시 조회

---

### 5.2 FROM 절 + GROUP BY 인라인 뷰

```sql
SELECT deptno, avg_sal
FROM (
  SELECT deptno, AVG(sal) AS avg_sal
  FROM emp
  GROUP BY deptno
)
WHERE avg_sal >= 3000;
```

> GROUP BY 결과를 WHERE에서 바로 쓰고 싶을 때 거의 필수 패턴

---

### 5.3 FROM 절 서브쿼리 + JOIN

```sql
SELECT e.ename, s.avg_sal
FROM emp e
JOIN (
  SELECT deptno, AVG(sal) AS avg_sal
  FROM emp
  GROUP BY deptno
) s ON s.deptno = e.deptno
WHERE e.sal > s.avg_sal;
```

---

### 5.4 FROM 절 서브쿼리 vs CTE(WITH)

```sql
-- 인라인 뷰
SELECT *
FROM (
  SELECT deptno, COUNT(*) cnt
  FROM emp
  GROUP BY deptno
) t;

-- CTE (가독성 우수)
WITH t AS (
  SELECT deptno, COUNT(*) cnt
  FROM emp
  GROUP BY deptno
)
SELECT * FROM t;
```

* **기능 동일**
* SQL이 길어질수록 CTE 권장

---

## 6. GROUP BY / HAVING

```sql
SELECT deptno, AVG(sal)
FROM emp
GROUP BY deptno
HAVING AVG(sal) >= 3000;
```

---

## 6. UNION / UNION ALL

```sql
SELECT empno, ename FROM emp WHERE deptno = 10
UNION ALL
SELECT empno, ename FROM emp WHERE deptno = 20;
```

* UNION: 중복 제거
* UNION ALL: 그대로 합침 (성능 좋음)

---

## 7. WITHIN GROUP

### LISTAGG

```sql
SELECT deptno,
       LISTAGG(ename, ', ') WITHIN GROUP (ORDER BY sal DESC) AS names
FROM emp
GROUP BY deptno;
```

### 중앙값

```sql
SELECT deptno,
       PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY sal) AS median_sal
FROM emp
GROUP BY deptno;
```

---

## 8. 윈도우 함수 (RANK / LAG / LEAD)

```sql
SELECT empno, sal,
       LAG(sal) OVER (PARTITION BY deptno ORDER BY sal) AS prev_sal,
       LEAD(sal) OVER (PARTITION BY deptno ORDER BY sal) AS next_sal
FROM emp;
```

* LAG: 이전 행 값 참조
* LEAD: 다음 행 값 참조
* PARTITION BY: 그룹 단위 계산
* ORDER BY: 행의 순서 정의

---

## 8-1. EXISTS / NOT EXISTS (내부 질의)

### EXISTS 기본 개념

* 내부 SELECT의 **결과 존재 여부(true/false)**만 판단
* 실제 SELECT 컬럼 값은 중요하지 않음

```sql
SELECT *
FROM emp e
WHERE EXISTS (
  SELECT 1
  FROM dept d
  WHERE d.deptno = e.deptno
);
```

### NOT EXISTS

```sql
SELECT *
FROM dept d
WHERE NOT EXISTS (
  SELECT 1
  FROM emp e
  WHERE e.deptno = d.deptno
);
```

* IN vs EXISTS

  * EXISTS: 상관 서브쿼리에서 유리
  * 대량 데이터에서 EXISTS가 성능상 유리한 경우 많음

---

## 8-2. 서브쿼리 종류 정리

### 단일 행 서브쿼리

```sql
SELECT * FROM emp
WHERE sal = (SELECT MAX(sal) FROM emp);
```

### 다중 행 서브쿼리

```sql
SELECT * FROM emp
WHERE deptno IN (SELECT deptno FROM dept WHERE loc = 'DALLAS');
```

### 상관 서브쿼리

```sql
SELECT e.*
FROM emp e
WHERE sal > (
  SELECT AVG(e2.sal)
  FROM emp e2
  WHERE e2.deptno = e.deptno
);
```

---

## 8-3. CTE (WITH 절)

### CTE 기본 구조

```sql
WITH temp AS (
  SELECT deptno, AVG(sal) avg_sal
  FROM emp
  GROUP BY deptno
)
SELECT e.*
FROM emp e
JOIN temp t ON t.deptno = e.deptno
WHERE e.sal > t.avg_sal;
```

### CTE 장점

* 복잡한 서브쿼리 가독성 향상
* 동일 로직 재사용
* 분석/리포팅 SQL에서 필수

### 다중 CTE

```sql
WITH a AS (
  SELECT * FROM emp WHERE deptno = 10
), b AS (
  SELECT * FROM emp WHERE deptno = 20
)
SELECT * FROM a
UNION ALL
SELECT * FROM b;
```

---

## 9. 페이징

### 9.1 Oracle 12c+

```sql
SELECT *
FROM board
ORDER BY created_at DESC
OFFSET 10 ROWS FETCH NEXT 10 ROWS ONLY;
```

### 9.2 Oracle 11g

```sql
SELECT *
FROM (
  SELECT t.*, ROWNUM rn
  FROM (
    SELECT * FROM board ORDER BY created_at DESC
  ) t
  WHERE ROWNUM <= 20
)
WHERE rn >= 11;
```

---

## 10. DML

```sql
INSERT INTO emp VALUES (9999,'KIM',10);
UPDATE emp SET sal = sal * 1.1 WHERE deptno = 10;
DELETE FROM emp WHERE empno = 9999;
```

---

## 11. MERGE (UPSERT)

```sql
MERGE INTO target t
USING source s
ON (t.id = s.id)
WHEN MATCHED THEN
  UPDATE SET t.name = s.name
WHEN NOT MATCHED THEN
  INSERT (id, name) VALUES (s.id, s.name);
```

---

## 12. 계층형 쿼리

```sql
SELECT LPAD(' ',(LEVEL-1)*2)||name AS tree
FROM category
START WITH parent_id IS NULL
CONNECT BY PRIOR id = parent_id;
```

---

## 13. 트랜잭션 / 락

```sql
SELECT * FROM emp WHERE empno = 7369 FOR UPDATE;
COMMIT;
ROLLBACK;
```

---

## 14. 실무 성능 팁

* 날짜 컬럼에 함수 적용 ❌ → 범위 조건 사용
* SELECT * 지양
* UNION보다 UNION ALL 우선 고려
* 인덱스 컬럼 타입 일치 중요

---


