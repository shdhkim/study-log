# 트랜잭션, 고립 수준(Isolation Level), Lock, JPA 락, 스프링 트랜잭션 정리

---

## 1. 트랜잭션(Transaction)

### 1-1. 정의

> **트랜잭션(Transaction)** = 여러 DB 작업(쿼리)을 하나의 논리적인 작업 단위로 묶어서  
> **모두 성공하거나(All-or-Nothing) 모두 실패하도록(롤백) 보장하는 것**

### 1-2. ACID 속성

| 속성 | 의미 |
|------|------|
| Atomicity (원자성) | 트랜잭션 내 연산은 전부 성공하거나 전부 실패해야 한다. |
| Consistency (일관성) | 트랜잭션 전후로 항상 데이터 무결성이 유지되어야 한다. |
| Isolation (격리성) | 동시에 여러 트랜잭션이 실행되어도 서로의 중간 결과를 보지 않는다. |
| Durability (지속성) | Commit 된 데이터는 장애가 나도 보존되어야 한다. |

---

## 2. Isolation Level(고립 수준)

> **트랜잭션 간의 간섭을 어느 정도까지 허용할 것인지** 정의하는 DB의 정책

### 2-1. 대표적인 동시성 문제

- **Dirty Read**
  - 커밋되지 않은 데이터를 다른 트랜잭션이 읽어버리는 문제
- **Non-Repeatable Read**
  - 같은 조건으로 두 번 조회했는데 그 사이 다른 트랜잭션이 업데이트/커밋 → 값이 달라지는 문제
- **Phantom Read**
  - 같은 조건으로 두 번 조회했는데 그 사이 다른 트랜잭션이 INSERT/DELETE → 레코드 개수가 달라지는 문제

### 2-2. 고립 수준별 특징

| Level | Dirty Read | Non-Repeatable Read | Phantom Read | 성능 |
|------|:----------:|:------------------:|:------------:|:---:|
| READ UNCOMMITTED | O | O | O | ⭐ 최고 |
| READ COMMITTED | X | O | O | ✔ 밸런스 |
| REPEATABLE READ | X | X | O | △ |
| SERIALIZABLE | X | X | X | ❌ 최악(가장 느림) |

- **낮은 수준**: 빠르지만 데이터 정합성이 떨어질 수 있음
- **높은 수준**: 안전하지만 락 경쟁, 대기, 데드락으로 성능 저하

### 2-3. 간단한 사례

#### (1) READ COMMITTED 예시 – Non-repeatable Read

- T1: `SELECT stock FROM product WHERE id=1;` → 10
- T2: `UPDATE product SET stock = 0 WHERE id=1;` → COMMIT
- T1: 같은 쿼리 재실행 → 0

→ 같은 트랜잭션(T1) 안에서 같은 조건 조회지만 결과가 달라진다.

#### (2) SERIALIZABLE 예시

- T1이 특정 범위를 조회하면, 그 범위에 대해 S-Lock / Range Lock을 사용해
  다른 트랜잭션의 INSERT/UPDATE/DELETE를 막는다.
- 사실상 트랜잭션들을 순서대로(직렬화) 실행한 것처럼 보이게 함.

---

## 3. DB Lock (S-Lock, X-Lock)

> **Lock = DB가 데이터에 대한 동시 접근을 제어하기 위한 실제 기계적 수단**

### 3-1. S-Lock (Shared Lock, 공유 락)

- **읽기 전용** 작업을 위한 락
- 여러 트랜잭션이 동시에 S-Lock을 획득할 수 있다.
- 하지만 S-Lock이 걸린 동안 **X-Lock(쓰기 락)** 은 획득할 수 없다.

### 3-2. X-Lock (Exclusive Lock, 배타 락 / 독점 락)

- **수정(UPDATE, DELETE, INSERT)** 작업을 위한 락
- X-Lock은 **그 행(또는 범위)에 대한 완전 독점**
  - 다른 트랜잭션은 S-Lock, X-Lock 모두 획득 불가
  - 보통 UPDATE/DELETE/INSERT 시 자동 발생

### 3-3. 락 호환 관계

| 기존 락 | 신규 락 | 가능 여부 |
|--------|--------|----------|
| S-Lock | S-Lock | ⭕ (읽기끼리는 공유 가능) |
| S-Lock | X-Lock | ❌ (쓰기 불가) |
| X-Lock | S-Lock | ❌ |
| X-Lock | X-Lock | ❌ |

### 3-4. 언제 어떤 락이 걸리나?

| SQL | 락 |
|-----|---|
| 일반 SELECT (MVCC 환경) | 보통 행 락 없음(스냅샷 읽기) |
| SELECT ... FOR SHARE / LOCK IN SHARE MODE | S-Lock |
| SELECT ... FOR UPDATE | X-Lock |
| UPDATE / DELETE | X-Lock |
| INSERT | 새로 생성된 Row에 X-Lock |

---

## 4. Isolation Level과 Lock의 관계

- **Isolation Level**은 “트랜잭션 간 간섭을 어떻게 막을 것인가?”에 대한 **정책**
- **Lock(S-Lock/X-Lock)** 은 그 정책을 **실제로 구현하는 도구**

### 4-1. 예시

- READ COMMITTED
  - 변경된 값이 커밋된 것만 읽도록 보장
  - SELECT 시에는 보통 MVCC 스냅샷 사용 (락 최소화)
  - UPDATE 시에만 X-Lock 사용
- SERIALIZABLE
  - 트랜잭션들이 순차적으로 실행된 것처럼 보이도록 보장
  - SELECT에도 S-Lock 또는 Range Lock을 사용하여 다른 트랜잭션 접근을 막음

> 정리: **고립 수준이 높을수록 더 많은/강한 락을 더 오래 잡는다.**

---

## 5. JPA 락 (Optimistic / Pessimistic)

JPA는 애플리케이션 레벨에서 **동시성 제어 전략**을 제공한다.

### 5-1. Optimistic Lock (낙관적 락)

> “충돌이 자주 일어나지 않을 거라 낙관적으로 가정하고,  
> 나중에 버전 비교로 충돌을 감지한다.”

- DB에 별도의 락을 걸지 않는다.
- 엔티티에 `@Version` 필드를 두고, UPDATE 시 버전을 이용해 충돌 여부를 체크한다.

```java
@Entity
public class Member {

    @Id
    @GeneratedValue
    private Long id;

    @Version
    private Long version;

    private String name;
}
```

UPDATE SQL 예시

```sql
UPDATE member
SET name = ?, version = version + 1
WHERE id = ? AND version = ?;
```

- WHERE절의 버전이 맞지 않으면 0행 업데이트 → JPA는 `OptimisticLockException` 발생
- 애플리케이션에서 재시도 로직 등을 구현해 처리

### 5-2. Pessimistic Lock (비관적 락)

> “충돌이 많이 날 것 같으니 아예 먼저 락을 걸어버리자.”

- JPA가 **DB의 락을 직접 사용**하도록 하는 방식
- 내부적으로는 `SELECT ... FOR UPDATE` 등을 수행해서 X-Lock을 건다.

```java
public interface MemberRepository extends JpaRepository<Member, Long> {

    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("select m from Member m where m.id = :id")
    Member findWithLock(@Param("id") Long id);
}
```

→ 내부 SQL (DB마다 조금씩 다름)

```sql
SELECT *
FROM member
WHERE id = ?
FOR UPDATE;
```

- 이 트랜잭션이 끝날 때까지 해당 row는 **다른 트랜잭션에서 읽기/쓰기 제한**

### 5-3. 정리

| 구분 | Optimistic Lock | Pessimistic Lock |
|------|-----------------|------------------|
| 전략 | 낙관적 | 비관적 |
| DB 락 사용 | ❌ 없음 | ⭕ X/S-Lock 사용 |
| 충돌 처리 | 버전 불일치 시 예외 → 재시도 | 다른 트랜잭션 대기 또는 데드락 |
| 적합한 상황 | 읽기 많고, 충돌 적은 경우 | 동시 수정이 잦고, 데이터가 아주 중요할 때 |

---

## 6. @Transactional과 Lock, Isolation Level 관계

### 6-1. @Transactional의 역할

스프링의 `@Transactional` 은 다음을 담당한다.

1. 트랜잭션 시작 (`BEGIN`)
2. 메소드(또는 코드 블록) 실행
3. 예외 여부에 따라 `COMMIT` 또는 `ROLLBACK`
4. 트랜잭션 범위 안에서 JPA의 영속성 컨텍스트를 묶어줌
   - 영속성 컨텍스트에 있는 엔티티 변경 → 트랜잭션 종료 시점에 한 번에 `flush` → SQL 실행

**중요한 점:**  
> `@Transactional` 자체가 락을 거는 것이 아니라,  
> 트랜잭션이 유지되는 동안 **DB가 건 락(X-Lock/S-Lock)** 이 유지되도록 만드는 역할을 한다.

### 6-2. 트랜잭션, 락, 영속성 컨텍스트 흐름

```java
@Service
public class AccountService {

    private final AccountRepository accountRepository;

    public AccountService(AccountRepository accountRepository) {
        this.accountRepository = accountRepository;
    }

    @Transactional
    public void transfer(Long fromId, Long toId, int amount) {
        // 1) 트랜잭션 시작

        // 2) 영속성 컨텍스트에 로딩 (SELECT)
        Account from = accountRepository.findById(fromId)
                .orElseThrow();
        Account to = accountRepository.findById(toId)
                .orElseThrow();

        // 3) 엔티티 값 변경 (아직 UPDATE SQL 안 날아감)
        from.withdraw(amount);  // from.balance -= amount;
        to.deposit(amount);     // to.balance += amount;

        // 4) 메소드 종료 시점
        //    - flush(): 변경 감지 → UPDATE SQL 생성 및 실행
        //    - DB는 UPDATE 시점에 해당 row에 X-Lock 획득
        //    - COMMIT → 락 해제
    }
}
```

내부 흐름(시간 순서):

1. `@Transactional` 진입 → 트랜잭션 시작
2. `findById()` 호출 → DB에서 SELECT (MVCC 스냅샷 or 필요한 수준의 락)
3. 엔티티 필드 변경 → JPA가 **변경 감지(Dirty Checking)** 수행 (아직 SQL X)
4. 메소드가 정상 종료되면 → 트랜잭션 commit 시점에 `flush()` 호출
   - `UPDATE account SET ... WHERE id = ?` SQL 실행
   - 이 때 DB가 해당 row에 X-Lock 획득
5. `COMMIT` 후 → X-Lock 해제

### 6-3. @Transactional 설정으로 Isolation Level 제어

스프링에서는 트랜잭션 단위로 Isolation Level을 지정할 수도 있다.

```java
@Transactional(isolation = Isolation.READ_COMMITTED)
public void doSomething() {
    ...
}
```

대표적인 값들:

```java
public enum Isolation {
    DEFAULT,
    READ_UNCOMMITTED,
    READ_COMMITTED,
    REPEATABLE_READ,
    SERIALIZABLE
}
```

- `DEFAULT` : DB 기본 설정을 따름 (예: MySQL-InnoDB는 REPEATABLE_READ)
- 특정 비즈니스에서만 강한 고립 수준이 필요한 경우 해당 메소드에만 높은 수준으로 설정 가능

---

## 7. Isolation Level vs Lock vs JPA 락 vs @Transactional 정리

### 7-1. 각각의 역할

| 개념 | 위치 | 역할 |
|------|------|------|
| 트랜잭션 | DB/스프링 | 여러 작업을 하나의 단위로 묶어 ACID 보장 |
| Isolation Level | DB | 트랜잭션 간 간섭 허용 정도(정책) |
| Lock(S/X) | DB | Isolation Level을 구현하는 실제 수단 |
| Optimistic Lock(@Version) | JPA/애플리케이션 | DB 락 없이 버전 비교로 충돌 감지 |
| Pessimistic Lock | JPA + DB | `SELECT ... FOR UPDATE` 등으로 DB 락 직접 사용 |
| @Transactional | 스프링 | 트랜잭션 경계를 선언적으로 지정, 커밋/롤백 제어 |

### 7-2. 한 문장으로 요약

> - **Isolation Level** 은 “얼마나 고립시킬 것인가”에 대한 **정책**
> - **Lock(X/S)** 은 그 정책을 지키기 위해 DB가 사용하는 **기술적인 수단**
> - **JPA의 Optimistic/ Pessimistic Lock** 은 애플리케이션이 동시성 충돌을 다루는 **전략**
> - **@Transactional** 은 트랜잭션 범위를 정의하고, 그 안에서 Lock과 Isolation이 효력을 발휘하게 하는 **틀**

---

## 8. 재고 감소 상세 예시로 전체 흐름 복습

### 상황

- 상품 재고(stock) = 10
- 동시에 두 명이 10개씩 주문(T1, T2)

### 8-1. 단순 트랜잭션 + READ COMMITTED + 락 고려

T1:

1. `SELECT stock FROM product WHERE id=1;` → 10
2. `UPDATE product SET stock = stock - 10 WHERE id=1;` → 0, X-Lock 획득
3. COMMIT → 락 해제

T2:

1. T1이 끝나기 전에 `UPDATE product SET stock = stock - 10 WHERE id=1;` 실행 시도
2. T1의 X-Lock 때문에 대기
3. T1 COMMIT 후 실행 → `0 - 10 = -10` (재고 음수, 초과 판매)

→ **트랜잭션 & Isolation Level만으로는 부족할 수 있다**

### 8-2. Optimistic Lock(@Version) 추가

- product 테이블에 `version` 컬럼 추가
- JPA 엔티티에 `@Version` 필드 추가

T1, T2가 동시에 재고 10, version 1을 읽음

T1 업데이트:

```sql
UPDATE product
SET stock = 0, version = 2
WHERE id = 1 AND version = 1;
-- 성공 (1 → 2)
```

T2 업데이트:

```sql
UPDATE product
SET stock = 0, version = 2
WHERE id = 1 AND version = 1;
-- 영향받은 row 수 = 0 → OptimisticLockException 발생
```

→ T2는 예외 발생 → 비즈니스 로직에서 재시도 or 사용자에게 안내

### 8-3. Pessimistic Lock 사용 시

T1:

```sql
SELECT * FROM product WHERE id=1 FOR UPDATE; -- X-Lock
UPDATE product SET stock = 0 WHERE id=1;
COMMIT; -- 락 해제
```

T2:

```sql
SELECT * FROM product WHERE id=1 FOR UPDATE; -- T1이 끝날 때까지 대기
```

→ T2는 아예 처음부터 T1이 끝날 때까지 대기  
→ 재고 0인 상태를 보고 “재고 부족” 처리 가능

---

## 9. 마무리 요약

1. **트랜잭션**은 DB 작업을 하나의 단위로 묶어서 ACID 보장
2. **Isolation Level**은 트랜잭션 간에 어느 정도까지 간섭을 허용할지 정한 정책
3. **DB Lock(X/S 락)** 은 이러한 고립 수준을 구현하기 위한 실제 수단
4. **JPA Optimistic Lock(@Version)** 은 DB 락 없이 버전 비교로 충돌 감지
5. **JPA Pessimistic Lock** 은 DB의 X-Lock/S-Lock을 직접 활용하는 전략
6. **@Transactional** 은 이 모든 것이 동작하는 트랜잭션 경계를 정의

> 실무에서는 **고립 수준 + JPA 락 전략 + 올바른 트랜잭션 범위**를 함께 설계해야  
> 동시성 문제(초과 판매, Double Spending, Dirty Read 등)를 안정적으로 막을 수 있다.
