
# 트랜잭션 · Lock · Isolation Level · JPA Lock · Spring 연계 정리 (개정판)

## 1. 핵심 용어 정리

| 용어 | 설명 |
|------|------|
| 트랜잭션(@Transactional) | 하나의 작업 단위를 보장, 실패 시 롤백, 성공 시 커밋 |
| 영속성 컨텍스트 | 엔티티 변경 감지(Dirty Checking) 수행 |
| Dirty Checking | 엔티티 변경을 감지 → 트랜잭션 종료 시 UPDATE SQL 실행 |
| X-Lock (Exclusive Lock) | 수정 시 걸리는 락 → 읽기/쓰기 모두 차단 |
| S-Lock (Shared Lock) | 일반적으로 읽기 보호 → 읽기 공유 가능, 수정 차단 |
| Isolation Level | DB가 락을 언제/얼마나 사용할지 정책 |
| Optimistic Lock | 락 없이 버전 비교로 충돌 감지(Commit 시 예외) |
| Pessimistic Lock | SELECT 시점에 DB락 강제 획득(`FOR UPDATE`) |

> **주의:** SERIALIZABLE 고립수준에서는 단순 S-Lock이 아니라 **범위 잠금(Range Lock)** 을 적용하여 다른 SELECT도 차단할 수 있음.

---

## 2. Spring + JPA 트랜잭션 동작 흐름

```text
Controller
 ↓
Service (@Transactional 시작)
 ↓
1) SELECT 실행 (MVCC 기반, 기본은 락 없이 읽기)
 ↓
2) 엔티티 변경 (Dirty Checking 기록)
 ↓
3) 트랜잭션 종료 시 → flush
 ↓
4) UPDATE SQL 실행 → X-Lock 획득
 ↓
5) Commit → 락 해제
```

> 락은 DB가 걸고, 락 유지 기간은 **@Transactional** 이 정한다.

---

## 3. Isolation Level 설정

### A) 스프링에서 설정

```java
@Transactional(isolation = Isolation.SERIALIZABLE)
public void process() {}
```

➡ 해당 메소드 트랜잭션 동안만 SERIALIZABLE 적용

### B) DB 기본 설정

| DB | 기본 Isolation Level |
|----|---------------------|
| MySQL InnoDB | REPEATABLE READ |
| Oracle | READ COMMITTED |

---

## 4. Isolation Level의 이상 현상 허용 표

| 고립수준 | Dirty Read | Non-repeatable Read | Phantom Read |
|------|:---:|:---:|:---:|
| READ UNCOMMITTED | ⭕ | ⭕ | ⭕ |
| READ COMMITTED | ❌ | ⭕ | ⭕ |
| REPEATABLE READ | ❌ | ❌ | ⭕ |
| SERIALIZABLE | ❌ | ❌ | ❌ |

---

## 5. JPA Lock (Spring 사용 예)

### Optimistic Lock
```java
@Entity
public class Item {
    @Version
    private Long version;
}
```

### Pessimistic Lock
```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("select i from Item i where i.id = :id")
Item findItemForUpdate(Long id);
```

→ 즉시 X-Lock 획득(`FOR UPDATE`)

---

## 6. 상세 예제 – 재고 감소(동시 주문)

초기 재고: 10개  
동시 주문: T1, T2

공통 코드:
```java
@Transactional
public void order(Long itemId) {
    Item item = itemRepository.findById(itemId).orElseThrow();
    item.removeStock(10);
}
```

---

### Case A) 기본 READ COMMITTED

| 시점 | T1 | T2 |
|---|---|---|
| t1 | SELECT(10) | |
| t2 | | SELECT(10) |
| t3 | UPDATE(0) → X-Lock → COMMIT | |
| t4 | | UPDATE(-10) → COMMIT |

❌ 초과판매 발생

---

### Case B) SERIALIZABLE 사용 (범위 잠금)

```java
@Transactional(isolation = Isolation.SERIALIZABLE)
```

| 시점 | T1 | T2 |
|---|---|---|
| t1 | SELECT 시 범위 S-Lock 획득 | |
| t2 | | SELECT **대기** (SERIALIZABLE은 읽기도 제한) |
| t3 | UPDATE/COMMIT → 락 해제 | |
| t4 | | SELECT → 재고 부족 감지 |

⭕ 초과판매 방지  
⚠️ 팬텀/경쟁 상황 방지 위한 강한 잠금 → 성능 저하

> 일반 S-Lock과 다르게 SERIALIZABLE의 S-Lock은 **미래의 쓰기 위험이 있는 SELECT도 차단**한다.

---

### Case C) Optimistic Lock (충돌 감지)

| 시점 | T1 | T2 |
|---|---|---|
| t1 | v=1 조회 | v=1 조회 |
| t2 | v=2로 UPDATE 성공 | UPDATE 실패(예외) |

⚠️ 예외 발생 시 재시도 필요

---

### Case D) Pessimistic Lock (즉시 차단)

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
```

| 시점 | T1 | T2 |
|---|---|---|
| t1 | SELECT FOR UPDATE → X-Lock | |
| t2 | | SELECT FOR UPDATE 대기 |
| t3 | COMMIT | |
| t4 | | UPDATE 실행 |

⭕ 충돌 강하게 차단  
⚠ Deadlock 관리 필요

---

## 7. Phantom Read 예제

READ COMMITTED → 유령 레코드 발생  
SERIALIZABLE → 범위 잠금으로 차단

---

## 8. 최종 비교 요약

| 전략 | 초과판매 | 팬텀리드 | 성능 | 특징 |
|------|---------|---------|------|------|
| 기본 @Transactional | ❌ | ❌ | ⭐⭐⭐⭐⭐ | 읽기 성능 최고 |
| SERIALIZABLE | ⭕ | ⭕ | ⭐ | 가장 안정적 |
| Optimistic Lock | ⭕(예외) | ❌ | ⭐⭐⭐⭐ | 충돌 적은 환경 |
| Pessimistic Lock | ⭕ | ❌ | ⭐⭐⭐ | 충돌 많은 환경 |

---

## 핵심 한 줄 요약

> **트랜잭션은 범위를 제공하고,  
> DB는 락을 걸고,  
> Isolation Level은 정책을 정하고,  
> JPA Lock은 언제 락을 걸지 결정한다.  
> SERIALIZABLE에서는 읽기도 쓰기처럼 엄격히 관리한다.**
