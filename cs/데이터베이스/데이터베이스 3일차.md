
# 트랜잭션 · Lock · Isolation Level · JPA Lock · Spring 연계 정리

## 1. 핵심 용어 정리

| 용어 | 설명 |
|------|------|
| 트랜잭션(@Transactional) | 하나의 작업 단위를 보장, 실패 시 **롤백**, 성공 시 **커밋** |
| 영속성 컨텍스트 | 엔티티 변경 감지(Dirty Checking) 수행 |
| Dirty Checking | 값 변경을 감지해 **트랜잭션 종료 시 UPDATE 실행** |
| X-Lock (Exclusive Lock) | 수정 시 걸리는 락 → 읽기/쓰기 모두 차단 |
| S-Lock (Shared Lock) | 읽기 보호 락 → 읽기 공유 가능, 수정 차단 |
| Isolation Level | DB가 **락을 언제/얼마나** 사용할지 정책 |
| Optimistic Lock | 락 없이 버전 비교로 충돌 감지 |
| Pessimistic Lock | SELECT 시점에 DB락 강제 획득 (`FOR UPDATE`) |

---

## 2. Spring + JPA 트랜잭션 동작 흐름

```text
Controller
   ↓
Service (@Transactional 시작)
   ↓
1) SELECT 실행 (영속 상태)
   ↓
2) 엔티티 값 변경 (Dirty Checking 대상 기록)
   ↓
3) 트랜잭션 종료 순간 → flush 실행
   ↓
4) UPDATE SQL 실행 → X-Lock 획득
   ↓
5) Commit → 락 해제
```

### 핵심 포인트
> **락은 DB가 건다**  
> **언제 커밋/해제될지는 스프링 @Transactional이 결정한다**

---

## 3. Isolation Level 설정

### A) 스프링에서 설정

```java
@Transactional(isolation = Isolation.SERIALIZABLE)
public void process() {}
```

➡ 해당 메소드의 트랜잭션 동안만 DB에게 **SERIALIZABLE로 실행** 지시

### B) DB 기본 설정

| DB | 기본 Isolation Level |
|----|---------------------|
| MySQL InnoDB | REPEATABLE READ |
| Oracle | READ COMMITTED |

---

## 4. Isolation Level의 이상 현상 허용 표

| 고립수준 | Dirty Read | Non-repeatable | Phantom |
|------|:---:|:---:|:---:|
| READ UNCOMMITTED | ⭕ | ⭕ | ⭕ |
| READ COMMITTED | ❌ | ⭕ | ⭕ |
| REPEATABLE READ | ❌ | ❌ | ⭕ |
| SERIALIZABLE | ❌ | ❌ | ❌ |

> 고립수준이 낮을수록 성능 ↑, 데이터 정합성 ↓  
> 고립수준이 높을수록 성능 ↓, 데이터 정합성 ↑

---

## 5. JPA Lock (Spring 사용 예)

### Optimistic Lock

```java
@Entity
public class Item {
    @Version
    private Long version;
}
```

→ Commit 시 버전 비교로 충돌 감지 (예외 발생 → 재시도 필요)

---

### Pessimistic Lock

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
@Query("select i from Item i where i.id = :id")
Item findItemForUpdate(Long id);
```

→ 즉시 **X-Lock** 획득 (`FOR UPDATE`)

---

## 6. 상세 예제 – 재고 감소(동시 주문)

초기 재고: 10개  
동시 주문 T1, T2 발생

공통 코드

```java
@Transactional
public void order(Long itemId) {
    Item item = itemRepository.findById(itemId).orElseThrow();
    item.removeStock(10);  // Dirty Checking 기록
}
```

---

### Case A) READ COMMITTED (기본)

| 시점 | T1 | T2 |
|---|---|---|
| t1 | SELECT(10) | |
| t2 | | SELECT(10) |
| t3 | UPDATE(0) → X락 → COMMIT | |
| t4 | | UPDATE(-10) → COMMIT |

❌ **초과 판매 발생**
→ Non-repeatable Read 문제

---

### Case B) SERIALIZABLE 사용

```java
@Transactional(isolation = Isolation.SERIALIZABLE)
```

| 시점 | T1 | T2 |
|---|---|---|
| t1 | SELECT 시 S락 획득 | |
| t2 | | SELECT 대기 |
| t3 | UPDATE/COMMIT | |
| t4 | | SELECT 후 재고 부족 감지 |

⭕ 초과판매 방지  
❌ 성능 저하 (모두 줄 세움)

---

### Case C) Optimistic Lock

| 시점 | T1 | T2 |
|---|---|---|
| t1 | v=1 조회 | v=1 조회 |
| t2 | commit 업데이트 성공 (v=2) | UPDATE 실패 (OptimisticLockException) |

⭕ 성능 좋음  
⚠ 재시도 로직 필요

---

### Case D) Pessimistic Lock

```java
@Lock(LockModeType.PESSIMISTIC_WRITE)
```

| 시점 | T1 | T2 |
|---|---|---|
| t1 | SELECT FOR UPDATE (X-Lock) | |
| t2 | | SELECT 대기 |
| t3 | COMMIT | |
| t4 | | UPDATE/COMMIT |

⭕ 안정적  
⚠ 데드락 관리 필요

---

## 7. Phantom Read 예제 (Spring)

```java
@Transactional
public void countHighPrice() {
    long c1 = orderRepository.countByAmountGreaterThan(20000);
    Thread.sleep(5000);
    long c2 = orderRepository.countByAmountGreaterThan(20000);
    System.out.println(c1 + " → " + c2);
}
```

동시에

```java
@Transactional
public void addOrder() {
    orderRepository.save(new Order("U4", 30000));
}
```

### READ COMMITTED
```
2 → 3  // Phantom Read 발생
```

### SERIALIZABLE
```
2 → 2  // 유령 레코드 차단 (범위 잠금)
```

---

## 8. 최종 비교 요약

| 전략 | 초과판매 | 팬텀리드 | 성능 | 특징 |
|------|---------|---------|------|------|
| 기본 @Transactional | ❌ | ❌ | ⭐⭐⭐⭐⭐ | 동시성 최고 |
| SERIALIZABLE | ⭕ | ⭕ | ⭐ | 가장 안전·가장 느림 |
| Optimistic Lock | ⭕(예외) | ❌ | ⭐⭐⭐⭐ | 충돌 적을 때 최적 |
| Pessimistic Lock | ⭕ | ❌ | ⭐⭐⭐ | Deadlock 위험 |

---

## 핵심 한 줄

> **트랜잭션은 범위를 제공하고,  
> DB는 락을 걸고,  
> Isolation Level은 정책을 정하고,  
> JPA Lock은 타이밍을 조절한다.**  
