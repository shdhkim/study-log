# Oracle CRUD + 겹치는 락(중첩 락) 상세 정리
(약어 + 풀네임 병기, 단계별 락 획득 흐름, 충돌/공존 시나리오, FK/DDL 연쇄까지)

작성 기준: Oracle Database, 기본 격리수준 READ COMMITTED, 일반적인 OLTP 환경

---

## 0. 이 문서의 목표

1) CRUD(INSERT/SELECT/UPDATE/DELETE) 각각이 **실제로 어떤 락을 잡는지**  
2) “락을 하나만 거는 게 아니라 왜 여러 락이 겹치는지”를 **단계별로**  
3) FK/DDL/SELECT FOR UPDATE 같은 실무 상황에서 락이 **어떻게 연쇄되는지**  
4) 대기/데드락 분석을 위해 `v$lock` 관점에서 **어떻게 보이는지**  
까지 한 번에 정리한다.

---

## 1. 용어/약어 정리(약어 + 풀네임)

### 1.1 락 타입(Oracle v$lock.type에서 주로 보는 것)
| 약어 | 풀네임 | 보통 의미 |
|---|---|---|
| TX | Transaction Lock | DML로 인한 행(트랜잭션) 관련 락. 주로 “행을 누가 수정 중인지”와 연결 |
| TM | DML Table Lock | 테이블 단위 규칙(주로 DML/DDL 공존)을 관리하는 락 |

주의:
- “TX가 곧 행락”이라고 많이 말하지만, 실제로는 트랜잭션 엔큐(Enqueue)로서 행 변경과 연동된다.
- “TM이 곧 테이블 전체 배타”는 아니다. TM은 모드에 따라 공존 가능하다.

### 1.2 락 모드(주요 모드만)
| 약어 | 풀네임 | Oracle에서의 감각 |
|---|---|---|
| RS | Row Share (for TM) | SELECT FOR UPDATE 시 “행 잠금 가능성” 선언용 |
| X | Exclusive | 독점. 같은 자원에 대해 다른 독점/상충 요청은 대기 |
| RX | Row Exclusive (for TM) | 일반 DML에서 기본. 다른 DML은 공존, DDL은 차단 |
| S | Share (for TM) | 읽기 전용에 가깝게 “쓰기”를 막는 용도로 사용 |
| SRX | Share Row Exclusive (for TM) | 매우 강한 테이블 락. 실무에서는 드묾 |

---

## 2. “겹치는 락(중첩 락)”이 생기는 이유(핵심 원리)

Oracle에서 한 SQL이 여러 락을 동시에 잡는 이유는 크게 3가지다.

### 2.1 데이터(행) 보호: TX
- “같은 행을 동시에 수정하면 안 된다”를 보장한다.
- UPDATE/DELETE/INSERT된 새 행에 대해 TX가 개입한다.

### 2.2 테이블 규칙/DDL 공존: TM
- 같은 테이블에서 DML이 진행 중일 때, DDL(ALTER/DROP/TRUNCATE 등)이 들어오면 구조/메타가 흔들릴 수 있다.
- 그래서 DML은 보통 TM(RX)을 잡아 “DML 중임”을 표시하고, DDL과 충돌시키는 방식으로 안전을 확보한다.

### 2.3 무결성/제약조건(FK, UNIQUE 등) 검사로 인한 연쇄
- 자식 테이블 DML은 부모 키 존재 여부를 검사해야 한다.
- 부모 테이블 변경은 자식 참조가 깨지지 않는지 검사해야 한다.
- 이 과정에서 “다른 테이블”에 대한 락 접근이 추가로 생긴다.

---

## 3. CRUD별 락: 기본 락 묶음(lock set) + 단계별 흐름

---

## 3.1 C – CREATE (INSERT)

### 3.1.1 기본 INSERT가 잡는 락(중첩)

예제:
```sql
INSERT INTO emp(empno, ename) VALUES (1, 'A');
-- COMMIT 하지 않은 상태
```

동시에 잡히는 락(개념):
1) `TX (X)` = Transaction Exclusive Lock (새로 삽입된 행)
2) `TM (RX)` = Table Lock – Row Exclusive Mode (emp 테이블)

정리 표:
| 단계 | 약어 | 풀네임 | 대상 | 왜 필요한가 |
|---|---|---|---|---|
| 1 | TX (X) | Transaction Exclusive Lock | 삽입된 행 | 그 행을 다른 트랜잭션이 수정/삭제하지 못하게 |
| 2 | TM (RX) | Table Lock – Row Exclusive Mode | emp 테이블 | DDL과 충돌시켜 구조 변경을 차단 |

### 3.1.2 동시 접근 시나리오(INSERT 중 다른 세션)

세션 A:
```sql
INSERT INTO emp VALUES (1, 'A');
-- COMMIT 안 함
```

세션 B:
```sql
INSERT INTO emp VALUES (2, 'B');            -- 가능 (TM(RX) 공존, 다른 행)
UPDATE emp SET ename='X' WHERE empno=1;     -- 대기 (TX 충돌)
SELECT * FROM emp WHERE empno=1;            -- 가능 (Undo 기반 일관읽기)
ALTER TABLE emp ADD col1 NUMBER;            -- 대기 (TM(RX) vs DDL)
```

핵심:
- INSERT가 “테이블 전체를 배타적으로” 잠그는 것이 아니라, TM(RX)로 **DDL을 막고 DML은 공존**시킨다.
- 실제로 막히는 대부분의 충돌은 “같은 행”의 TX에서 발생한다.

### 3.1.3 INSERT + FK가 만드는 연쇄(다른 테이블 락 추가)

구조:
```sql
CREATE TABLE parent (
  id NUMBER PRIMARY KEY
);

CREATE TABLE child (
  id NUMBER PRIMARY KEY,
  parent_id NUMBER NOT NULL,
  CONSTRAINT fk_child_parent FOREIGN KEY(parent_id) REFERENCES parent(id)
);
```

자식 INSERT:
```sql
INSERT INTO child(id, parent_id) VALUES (10, 1);
```

개념적 락 묶음:
- child: TX(X) + TM(RX)
- parent: FK 존재성 확인을 위한 보호 락(테이블/인덱스 접근과 연동)

실무 포인트:
- FK 검사 때문에 “child만 건드렸는데 parent 쪽에서 DDL/DML이 대기”하는 상황이 생길 수 있다.
- FK 컬럼/부모 키 인덱스 설계가 락/성능 모두에 영향을 준다.

---

## 3.2 R – READ (SELECT)

### 3.2.1 일반 SELECT는 락을 잡지 않는다(공유락 불필요)

예제:
```sql
SELECT * FROM emp WHERE empno = 1;
```

- 기본적으로 TX/TM 같은 락을 잡지 않는다.
- Oracle은 MVCC + Undo로 “그 시점의 스냅샷”을 읽는다.

왜 공유락이 필요 없는가(짧게 정리):
- 읽기는 “잠그는” 방식이 아니라 “버전을 읽는” 방식이다.
- 쓰기 트랜잭션이 커밋하지 않은 변경은 Undo로 되돌려 읽기 일관성을 맞춘다.
- 결과: SELECT가 UPDATE를 막지 않고, UPDATE도 SELECT를 막지 않는다.

### 3.2.2 예외: SELECT FOR UPDATE는 ‘읽기’가 아니라 ‘선점 잠금’

```sql
SELECT * FROM emp WHERE empno = 1 FOR UPDATE;
```

락:
- TX(X): empno=1 행 (선점)
- TM(RS): emp 테이블 (행 잠금 가능성 선언)


```md
보충 설명:
- SELECT FOR UPDATE는 DML이 아니므로 TM(RX)가 아니라 TM(RS)를 획득한다.
- RS는 “이 테이블에서 TX(행 락)가 발생할 수 있음”을 알리는 선언적 락이다.
- 실제 UPDATE / DELETE / FOR UPDATE 대기는 모두 TX 충돌로 발생한다.
- 일반 SELECT는 RS/TX와 무관하게 항상 가능하다.
```

---

동시 접근:
```sql
-- 다른 세션
UPDATE emp SET sal=sal+1 WHERE empno=1;   -- 대기
DELETE FROM emp WHERE empno=1;            -- 대기
SELECT * FROM emp WHERE empno=1 FOR UPDATE; -- 대기
SELECT * FROM emp WHERE empno=1;          -- 가능 (일반 SELECT)
```

핵심:
- 일반 SELECT는 계속 가능
- “FOR UPDATE 계열”만 TX 충돌로 대기

---

## 3.3 U – UPDATE

### 3.3.1 UPDATE 기본 락(중첩)

```sql
UPDATE emp SET sal = sal + 100 WHERE empno = 1;
```

락 묶음:
- TX(X): 수정 대상 행
- TM(RX): emp 테이블

동시 접근:
```sql
UPDATE emp SET sal=0 WHERE empno=1;  -- 대기 (TX 충돌)
UPDATE emp SET sal=0 WHERE empno=2;  -- 가능 (다른 행)
ALTER TABLE emp ADD col2 NUMBER;     -- 대기 (TM vs DDL)
SELECT * FROM emp WHERE empno=1;     -- 가능 (Undo)
```

### 3.3.2 UPDATE + FK로 발생하는 TX–TM–TX 교차(대표 연쇄)

세션 A:
```sql
UPDATE parent SET id = 10 WHERE id = 1;
-- (PK 변경은 강한 연쇄를 만든다. 실무에서는 매우 지양)
```

이때 내부적으로는:
- parent 쪽 TX/TM 뿐 아니라
- child 쪽에서 참조 무결성 확인 때문에 추가 락 접근이 발생할 수 있다.

또 다른 대표 패턴:
- 세션 A가 parent 행을 먼저 잠금
- 세션 B가 child 행을 먼저 잠금
- 서로 반대 순서로 상대를 잠그려고 시도하면 데드락 가능성이 커진다.

---

## 3.4 D – DELETE

### 3.4.1 DELETE 기본 락(중첩)

```sql
DELETE FROM emp WHERE empno = 1;
```

락 묶음:
- TX(X): 삭제 대상 행
- TM(RX): emp 테이블

동시 접근:
```sql
SELECT * FROM emp WHERE empno=1;    -- 가능 (Undo)
UPDATE emp SET sal=0 WHERE empno=1; -- 대기 (TX 충돌)
ALTER TABLE emp DROP COLUMN sal;    -- 대기 (TM vs DDL)
```

### 3.4.2 DELETE + FK(자식 인덱스 유무가 락 폭발을 결정)

부모 삭제:
```sql
DELETE FROM parent WHERE id = 1;
```

자식 FK 컬럼 인덱스가 없을 때 발생 가능한 문제:
- parent 삭제 시 자식에서 참조 여부를 확인하려고 “자식 전체 스캔”이 필요해짐
- 이 과정에서 자식 테이블에 강한 TM(SRX) 성격의 락이 개입할 수 있고,
  결과적으로 자식 테이블 DML이 대기하는 상황이 발생할 수 있다.

권장:
```sql
CREATE INDEX idx_child_parent_id ON child(parent_id);
```

효과:
- 필요한 자식 행만 빠르게 검사
- 자식 전체 락/스캔 가능성 감소

---

## 4. “락을 잡은 상태에서 다른 락을 추가로 요청”하는 중첩

이 케이스가 실무에서 가장 헷갈린다.  
이미 락을 보유한 상태에서도, 같은 세션이 다른 락을 요청하다가 대기할 수 있다.

### 4.1 예제: TM(RX) 보유 중 TM(X) 업그레이드 요청

세션 A:
```sql
UPDATE emp SET sal = 100 WHERE empno = 1;
-- TM(RX) + TX 보유
```

세션 A(같은 세션):
```sql
LOCK TABLE emp IN EXCLUSIVE MODE;
```

- TM(RX) 상태에서 TM(X)로 “업그레이드”하려는 요청
- 다른 세션들이 TM(RX)를 이미 보유하고 있으면 호환 불가로 대기 가능
- 즉, “내가 이미 락을 잡고 있는데도” 추가 요청 때문에 멈출 수 있다.

---

## 5. TM 모드 공존 감각(간단 호환성)

실무 감각 요약:
- TM(RX) ↔ TM(RX): 공존 가능 (여러 DML 동시 수행의 기반)
- TM(S): 읽기 전용에 가깝게 DML을 막음
- TM(X): 모두 막음
- TM(SRX): 강하게 막음(드묾)

---

## 6. v$lock에서 “보유”와 “요청”을 구분하는 법(중요)

대기 중인 세션은 “락을 보유한 게 아니라 요청 중”일 수 있다.

```sql
SELECT type, lmode, request, block
FROM v$lock
WHERE sid = SYS_CONTEXT('USERENV','SID');
```

- `lmode > 0`: 현재 보유한 락 모드
- `request > 0`: 추가로 요청 중인 락 모드
- `lmode = 0 AND request > 0`: 락을 아직 못 받아서 대기 중

이 관점이 있어야 “겹치는 락 구조”를 실제로 추적할 수 있다.

---

## 7. CRUD + 겹치는 락 요약(최종 암기용)

| 작업 | 기본 락 묶음 | 겹쳐질 수 있는 추가 락 |
|---|---|---|
| INSERT | TX(X) + TM(RX) | FK 검사로 부모 테이블 락 접근 |
| SELECT | 없음 | FOR UPDATE 사용 시 TX(X) + TM(RX) |
| UPDATE | TX(X) + TM(RX) | FK/제약조건/다른 테이블 참조로 연쇄 |
| DELETE | TX(X) + TM(RX) | FK 인덱스 없으면 자식 락/스캔 폭발 가능 |

---

## 8. 실무에서 자주 쓰는 판단 기준

1) “같은 행을 만지는데 기다린다”  
- 원인: TX 충돌 가능성이 높다.

2) “UPDATE 중 ALTER TABLE이 대기한다”  
- 원인: TM(RX) vs DDL 충돌.

3) “부모 DELETE 하나로 자식 DML이 멈춘다”  
- 원인: FK 인덱스 부재 가능성. 자식 검사 비용 및 락 개입 증가.

4) “내 세션이 락을 잡았는데도 멈춘다”  
- 원인: 보유(lmode) + 추가 요청(request)이 겹친 상태일 수 있다.

---
