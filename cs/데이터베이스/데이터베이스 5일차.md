# Oracle CRUD + 중첩 락 정리
(CREATE / READ / UPDATE / DELETE + TX/TM 중첩 구조)

작성 기준: Oracle Database (기본 격리수준 READ COMMITTED)

---

## 0. 핵심 전제

Oracle에서는 **하나의 SQL이 하나의 락만 거는 경우가 거의 없다**.  
대부분의 DML은 아래 **락 묶음(lock set)** 을 동시에 건다.

- 행 보호: **TX (Transaction Lock, Exclusive)**
- 테이블 규칙 보호: **TM (Table Lock, Row Exclusive Mode)**

상황에 따라 **다른 테이블의 TM**, **추가 TX**, **락 요청(Request)** 까지 겹친다.

---

## 1. 락 약어와 풀네임

| 약어 | 풀네임 | 의미 |
|---|---|---|
| TX | Transaction Lock | 행(Row) 단위 트랜잭션 락 |
| TM | Table Lock | 테이블 단위 규칙/무결성 관리 락 |
| X | Exclusive | 독점 |
| RX | Row Exclusive | DML 공존 가능, DDL 차단 |
| S | Share | 공유(읽기 중심) |
| SRX | Share Row Exclusive | 매우 강한 테이블 락 |

---

## 2. C – CREATE (INSERT) + 겹치는 락

### 예제 C-1: 기본 INSERT

```sql
INSERT INTO emp(empno, ename) VALUES (1, 'A');
-- COMMIT 안 함
```

### 동시에 걸리는 락(중첩)

| 순서 | 약어 | 풀네임 | 대상 |
|---|---|---|---|
| ① | TX (X) | Transaction Exclusive Lock | 새로 삽입된 행 |
| ② | TM (RX) | Table Lock – Row Exclusive Mode | emp 테이블 |

### 이 상태에서 다른 세션 동작

```sql
INSERT INTO emp VALUES (2,'B');      -- 가능 (TM(RX) 공유)
UPDATE emp SET ename='X' WHERE empno=1; -- 대기 (TX 충돌)
ALTER TABLE emp ADD col1 NUMBER;     -- 대기 (TM vs DDL)
```

---

### 예제 C-2: INSERT + FK → 다른 테이블 락까지 겹침

```sql
INSERT INTO child(id, parent_id) VALUES (10, 1);
```

겹치는 락 구조:

| 대상 | 락 |
|---|---|
| child 행 | TX (Transaction Exclusive Lock) |
| child 테이블 | TM (Row Exclusive Mode) |
| parent 테이블 | TM (Share Mode 계열, FK 검사) |

---

## 3. R – READ (SELECT) + 예외적 중첩

### 예제 R-1: 일반 SELECT

```sql
SELECT * FROM emp WHERE empno = 1;
```

- 락 없음
- Undo 기반 일관 읽기

---

### 예제 R-2: SELECT FOR UPDATE (읽기처럼 보이는 중첩 락)

```sql
SELECT * FROM emp WHERE empno = 1 FOR UPDATE;
```

겹치는 락:

| 약어 | 풀네임 | 대상 |
|---|---|---|
| TX (X) | Transaction Exclusive Lock | empno=1 행 |
| TM (RX) | Table Lock – Row Exclusive Mode | emp 테이블 |

---

## 4. U – UPDATE + 겹치는 락

### 예제 U-1: UPDATE 단일 테이블

```sql
UPDATE emp SET sal = sal + 100 WHERE empno = 1;
```

겹치는 락:

| 순서 | 락 | 대상 |
|---|---|---|
| ① | TX (Exclusive) | empno=1 행 |
| ② | TM (Row Exclusive) | emp 테이블 |

다른 세션:
```sql
UPDATE emp SET sal=0 WHERE empno=1; -- 대기 (TX)
UPDATE emp SET sal=0 WHERE empno=2; -- 가능
ALTER TABLE emp ADD col2 NUMBER;    -- 대기 (TM)
```

---

### 예제 U-2: UPDATE + FK → TX–TM–TX 구조

```sql
UPDATE child SET v = v + 1 WHERE parent_id = 1;
```

겹치는 락 구조:

| 대상 | 락 |
|---|---|
| child 행들 | TX |
| child 테이블 | TM (RX) |
| parent 테이블 | TM (S 계열, FK 검사) |

---

## 5. D – DELETE + 겹치는 락

### 예제 D-1: DELETE 기본

```sql
DELETE FROM emp WHERE empno = 1;
```

겹치는 락:

| 약어 | 풀네임 | 대상 |
|---|---|---|
| TX (X) | Transaction Exclusive Lock | empno=1 행 |
| TM (RX) | Table Lock – Row Exclusive Mode | emp 테이블 |

---

### 예제 D-2: DELETE + FK 인덱스 없음 (강한 중첩)

```sql
DELETE FROM parent WHERE id = 1;
```

겹치는 락:

| 대상 | 락 |
|---|---|
| parent 행 | TX |
| parent 테이블 | TM (RX) |
| child 테이블 | TM (SRX) |

결과:
- child 테이블의 INSERT/UPDATE/DELETE 전부 대기

---

## 6. “락을 가진 채 다른 락을 요청”하는 중첩 예제

### 예제 6-1: RX 보유 상태에서 X 요청

```sql
-- 이미 UPDATE 수행
UPDATE emp SET sal = 100 WHERE empno = 1;
-- TM(RX) 보유
```

```sql
LOCK TABLE emp IN EXCLUSIVE MODE;
```

상태:
- TM(RX) 보유
- TM(X) 요청 → 자기 자신도 대기 가능

---

## 7. CRUD + 겹치는 락 요약표

| 작업 | 기본 락 | 추가로 겹칠 수 있는 락 |
|---|---|---|
| INSERT | TX + TM(RX) | FK로 부모 TM(S) |
| SELECT | 없음 | FOR UPDATE 시 TX + TM |
| UPDATE | TX + TM(RX) | FK로 다른 테이블 TM |
| DELETE | TX + TM(RX) | FK 없으면 자식 TM(SRX) |

---

## 8. 핵심 요약

1) Oracle DML은 **항상 TX + TM을 함께** 건다.  
2) FK/제약조건/DDL 시도로 인해 **다른 테이블 락이 연쇄적으로 겹친다**.  
3) 락 문제는 단일 락이 아니라 **겹친 구조(TX–TM–TX)** 에서 터진다.  
4) 읽기(SELECT)는 락을 겹치지 않고 Undo로 해결한다.

---
