
# Oracle 윈도우 함수: ROWS vs RANGE 정리

작성 기준: Oracle Database(기본 동작 중심)  


---

## 0. 결론

- **ROWS**: *물리적인 “행 개수”* 기준 프레임
- **RANGE**: *ORDER BY 값의 “논리적 범위”* 기준 프레임
- Oracle에서 **집계 윈도우 함수 + ORDER BY** 를 쓰고 프레임을 생략하면 기본은 보통  
  **`RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW`** 로 동작한다.

> 실무 팁: “누적합/이동합/이동평균을 행 단위로 정확히” 만들려면 **ROWS를 명시**하는 게 안전하다.

---


## 0-1. 핵심 요약 표 (Oracle 기준)

| 함수 종류 | ORDER BY 유무 | 기본 프레임 |
|---|---|---|
| 집계 윈도우 함수 (SUM, AVG 등) | ❌ 없음 | PARTITION 전체<br>→ `ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING` |
| 집계 윈도우 함수 (SUM, AVG 등) | ✅ 있음 | `RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW` |
| 분석 함수 (ROW_NUMBER, RANK 등) | 관계없음 | **프레임 개념 자체가 없음** |

> 주의  
> - ORDER BY가 **없는** 집계 윈도우 함수는 “누적”이 아니라 **그룹 전체 집계값을 모든 행에 반복 출력**한다.  
> - ORDER BY가 **있는** 집계 윈도우 함수는 프레임을 생략하면 Oracle이 **RANGE 기준**으로 해석한다.  
> - `ROW_NUMBER`, `RANK`, `DENSE_RANK` 같은 분석 함수는 **프레임 기반 집계가 아니므로 ROWS/RANGE 의미가 없다.**


---

## 1. 윈도우 함수에서 “프레임(Frame)”이란?

윈도우 함수는 `OVER (...)` 안에서 **현재 행을 기준으로 어떤 행들의 묶음(프레임)** 을 잡아서 계산한다.

프레임은 보통 아래 3요소로 결정된다.

1) `PARTITION BY` : 그룹 경계(부서별, 사용자별 등)  
2) `ORDER BY` : 그룹 내부 정렬(시간순, 금액순 등)  
3) `ROWS/RANGE BETWEEN ... AND ...` : **현재 행 기준으로 포함할 범위(프레임)**

---

## 2. ROWS vs RANGE 차이 (표로 한 번에)

| 구분 | ROWS | RANGE |
|---|---|---|
| 기준 | **행의 개수(물리적)** | **ORDER BY 값(논리적)** |
| “CURRENT ROW” 의미 | 현재 **1행** | ORDER BY 값이 **같은 모든 행(동점/tie 묶음)** |
| 중복값(동점) 처리 | 행마다 개별 계산 | 같은 값이면 **한 번에 묶여 동일 결과**가 나올 수 있음 |
| 프레임 예시 | `ROWS BETWEEN 6 PRECEDING AND CURRENT ROW` = 7행 이동 | `RANGE BETWEEN 7 PRECEDING AND CURRENT ROW` = “값이 7 이내” |
| 실무 안정성(누적/이동) | 높음 | 낮음(동점/중복값에서 결과가 달라져 “버그처럼” 보이기 쉬움) |
| Oracle 기본(집계+ORDER BY, 프레임 생략) | ❌ | ✅ (대개 RANGE) |

---

## 3. “CURRENT ROW”가 다르게 해석되는 게 핵심

### 3.1 ROWS의 CURRENT ROW
- “현재 행”은 **정렬된 결과에서 딱 지금 이 행 1개**

### 3.2 RANGE의 CURRENT ROW
- “현재 행”은 **ORDER BY 값이 같은 행 전체**
- 즉, `ORDER BY sales_date` 에서 같은 날짜가 여러 행이면
  RANGE 기준 CURRENT ROW는 “그 날짜 그룹 전체”가 된다.

이 차이 때문에 **동일한 ORDER BY 값이 있을 때 결과가 크게 달라진다.**

---

## 4. 예제로 체감: 동점(중복 ORDER BY 값) 있을 때

### 4.1 예제 데이터

```sql
-- 예시 테이블: SALES
-- (id는 정렬을 안정적으로 만들기 위한 키라고 가정)

ID | SALES_DATE  | SALES
---+-------------+------
 1 | 2024-01-01  | 100
 2 | 2024-01-01  | 200
 3 | 2024-01-02  | 300
```

---

### 4.2 RANGE (Oracle 기본 동작에 가까움)

```sql
SELECT
  id, sales_date, sales,
  SUM(sales) OVER (
    ORDER BY sales_date
  ) AS running_sum
FROM sales
ORDER BY sales_date, id;
```

Oracle에서 집계 윈도우 함수에 `ORDER BY`만 두고 프레임을 생략하면 보통 아래처럼 해석된다:

```sql
SUM(sales) OVER (
  ORDER BY sales_date
  RANGE BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
)
```

결과:

| id | sales_date | sales | running_sum |
|---:|:----------:|-----:|------------:|
| 1 | 2024-01-01 | 100 | **300** |
| 2 | 2024-01-01 | 200 | **300** |
| 3 | 2024-01-02 | 300 | **600** |

**같은 날짜(동점)가 한 묶음**으로 계산되어 1,2행의 누적합이 동일해진다.

---

### 4.3 ROWS (행 단위 누적)

```sql
SELECT
  id, sales_date, sales,
  SUM(sales) OVER (
    ORDER BY sales_date, id
    ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
  ) AS running_sum
FROM sales
ORDER BY sales_date, id;
```

결과:

| id | sales_date | sales | running_sum |
|---:|:----------:|-----:|------------:|
| 1 | 2024-01-01 | 100 | 100 |
| 2 | 2024-01-01 | 200 | 300 |
| 3 | 2024-01-02 | 300 | 600 |

**각 행마다 누적이 진행**된다.

> 핵심: **동점이 있을 수 있는 ORDER BY 컬럼**(날짜, 금액, 점수 등)에서  
> 행 단위 누적/이동을 기대하면 **ROWS를 명시**해야 한다.

---

## 5. “1 PRECEDING”에서도 차이가 난다

### 5.1 ROWS: 바로 이전 “행” + 현재 “행”

```sql
SUM(sales) OVER (
  ORDER BY sales_date, id
  ROWS BETWEEN 1 PRECEDING AND CURRENT ROW
)
```

- 현재 행 + 바로 직전 행 = 총 2행(가능하면)

---

### 5.2 RANGE: ORDER BY 값의 “범위”

```sql
-- 주의: RANGE는 ORDER BY 값의 범위를 의미한다.
-- 숫자/날짜 등 타입과 표현이 중요하다.
SUM(sales) OVER (
  ORDER BY sales_amount
  RANGE BETWEEN 1 PRECEDING AND CURRENT ROW
)
```

의미는 대략 다음과 같다:

- `sales_amount`가 현재 값이라면  
  **`sales_amount >= (현재값 - 1)` 이면서 `<= 현재값`** 인 모든 행이 포함

즉, “이전 1행”이 아니라 “값이 1 이내인 행들”이다.

---

## 6. RANGE는 어떤 때 유용한가?

### 6.1 “동점은 한 덩어리로 취급”이 목표일 때
예: “같은 날짜에 발생한 매출은 같은 누적 포인트로 처리”

- 같은 `sales_date`면 동일 누적합이 나오도록 하고 싶다 → RANGE가 더 자연스러울 수 있음

### 6.2 시계열에서 “값/기간 범위” 분석
예: “최근 7일 범위의 합(날짜 범위)”

Oracle에서는 날짜 범위 RANGE를 쓰려면 보통 `INTERVAL`을 사용한다.

```sql
SUM(sales) OVER (
  ORDER BY sales_date
  RANGE BETWEEN INTERVAL '7' DAY PRECEDING AND CURRENT ROW
)
```

> 다만, “최근 7일”은 중복 날짜/데이터 밀집 형태에 따라 의미가 달라질 수 있으니  
> 요구사항(일 단위인지, 행 단위인지)을 먼저 확정해야 한다.

---

## 7. Oracle에서 프레임 생략 시 기본 동작 정리

### 7.1 ORDER BY가 없는 집계 윈도우
```sql
SUM(sales) OVER (PARTITION BY dept)
```

- `PARTITION BY dept`의 **전체 행을 대상으로 동일 값**이 나온다.
- 사실상 아래와 같은 “전체 프레임”과 유사하게 볼 수 있다.

```sql
ROWS BETWEEN UNBOUNDED PRECEDING AND UNBOUNDED FOLLOWING
```

(이 경우 RANGE/ROWS 차이가 크게 드러나지 않는다)

---

### 7.2 ORDER BY가 있는 집계 윈도우 (프레임 생략)
```sql
SUM(sales) OVER (PARTITION BY dept ORDER BY sales_date)
```

- Oracle에서 대체로 기본 프레임이 **RANGE 기반**으로 적용되어
  동점 값은 묶여서 동일 결과가 나올 수 있다.

> 그래서 “누적합”을 만들 때는 대개 `ROWS ...`를 명시하는 게 안전하다.

---

## 8. 프레임이 “없는” 윈도우 함수도 있다

아래 함수들은 “프레임으로 집계하는 방식”이 아니라 **정렬 결과에 대한 순위/번호**를 부여한다.

- `ROW_NUMBER()`
- `RANK()`
- `DENSE_RANK()`
- `NTILE()`

예:

```sql
ROW_NUMBER() OVER (ORDER BY sales DESC)
```

이들은 `ROWS BETWEEN ...` 같은 프레임을 붙인다고 해서 “집계 프레임”처럼 동작하지 않는다
(의미가 없거나 DB에 따라 허용/제약이 다를 수 있음).

---

## 9. 실무 체크리스트 (이대로 하면 사고 안 남)

### 9.1 누적합(running total)
- **행 단위 누적**을 원하면:

```sql
SUM(x) OVER (
  PARTITION BY grp
  ORDER BY sort_key, pk
  ROWS BETWEEN UNBOUNDED PRECEDING AND CURRENT ROW
)
```

- `sort_key`에 중복이 있을 수 있으므로 **pk를 함께 ORDER BY** 해서 안정화

---

### 9.2 이동합/이동평균(최근 N행)
- 최근 7행 이동합:

```sql
SUM(x) OVER (
  PARTITION BY grp
  ORDER BY sort_key, pk
  ROWS BETWEEN 6 PRECEDING AND CURRENT ROW
)
```

---

### 9.3 최근 7일(기간 범위) 이동합이 정말 필요할 때
- 날짜 범위 기반:

```sql
SUM(x) OVER (
  PARTITION BY grp
  ORDER BY dt
  RANGE BETWEEN INTERVAL '7' DAY PRECEDING AND CURRENT ROW
)
```

> “7일”이 **행 개수 7개**가 아니라 **날짜 범위 7일**이라는 점이 핵심.

---

## 10. 한 문장 요약(면접/시험용)

> **ROWS는 행 기준, RANGE는 값 기준이다.  
> Oracle에서 집계 윈도우 함수에 ORDER BY만 쓰면 기본이 RANGE라서  
> 동점(중복 ORDER BY 값)이 있으면 결과가 묶여 보일 수 있다.  
> 행 단위 누적/이동은 ROWS를 명시하는 게 안전하다.**

---
