# 세션 탈취형 XSS가 어떻게 발생하는가 (React + Spring Boot 기준, 상세 설명)

> 이 문서는   
> React + Spring Boot(세션 기반 인증) 환경에서  
> **세션 탈취형 XSS(Session Hijacking XSS)**가  
> *어떤 흐름으로 발생하는지*를 단계별로 설명한다.

---

## 1. 세션 탈취형 XSS 한 줄 정의

세션 탈취형 XSS란,

> **공격자가 피해자 브라우저에서 실행되는 스크립트를 주입하여  
> HttpOnly가 없는 세션 쿠키 값을 읽고,  
> 그 값을 외부로 전송해 동일한 로그인 상태를 복제하는 공격**

이다.

핵심은:
- 공격자 브라우저 ❌
- **피해자 브라우저에서 코드 실행 ✅**

---

## 2. 전체 흐름 요약 (한 번에 보기)

```
[공격자]
  ↓ (악성 스크립트 문자열 입력)
[Spring 서버]
  ↓ (문자열 그대로 저장/응답)
[React 관리자 화면]
  ↓ (HTML 문맥으로 렌더링)
[피해자 브라우저]
  ↓ (HTML 파싱)
<script> 실행
  ↓
document.cookie 읽기 (HttpOnly ❌)
  ↓
외부 서버로 전송
  ↓
공격자 브라우저에서 쿠키 설정
  ↓
피해자 세션 완전 탈취
```

---

## 3. 전제 조건 (이 중 하나라도 없으면 불가)

1. 사용자 입력이 화면에 출력되는 지점 존재
2. 해당 출력이 **HTML 문맥(innerHTML 계열)**
3. 세션 쿠키에 **HttpOnly 미설정**
4. 피해자가 로그인한 상태

---

## 4. Spring Boot에서 “받는 데이터”의 정체

### 4.1 댓글/게시글 입력 예시

```http
POST /api/comments
Content-Type: application/json

{
  "content": "<script>...</script>"
}
```

Spring이 받는 값:

```java
String content = "<script>...</script>";
```

Spring 관점:
- 타입: String
- 의미: 단순 문자열
- 실행: ❌ 절대 안 함

> Spring은 HTML도, JS도 **해석하지 않는다**.

---

## 5. Spring Boot가 응답으로 보내는 것

```http
HTTP/1.1 200 OK
Content-Type: application/json

{
  "id": 1,
  "content": "<script>...</script>"
}
```

이 단계에서도:
- 실행 ❌
- 단순 데이터

---

## 6. React에서 응답을 받는 단계 (아직 안전)

```jsx
const res = await fetch("/api/admin/comments");
const data = await res.json();
```

React가 가진 것:

```js
data.content === "<script>...</script>";
```

- 타입: 문자열
- HTML 파싱 ❌
- 실행 ❌

---

## 7. 취약점 발생 지점: React 렌더링

### 7.1 안전한 렌더링 (XSS 발생 ❌)

```jsx
<li>{comment.content}</li>
```

- React가 자동 escape
- 브라우저는 텍스트로만 처리
- `<script>`는 글자로 출력

---

### 7.2 취약한 렌더링 (XSS 발생 ✅)

```jsx
<li dangerouslySetInnerHTML={{ __html: comment.content }} />
```

내부 동작 개념:

```js
element.innerHTML = comment.content;
```

이 순간:

1. 문자열이 HTML로 해석됨
2. 브라우저 HTML 파서 실행
3. `<script>` 태그 발견
4. **즉시 실행**

---

## 8. 왜 “피해자 브라우저에서” 실행되는가?

- 해당 HTML은 **관리자 페이지의 일부**
- 관리자가 로그인한 상태로 페이지 접근
- 스크립트 실행 주체 = 관리자 브라우저

즉:

> 공격자가 실행한 것이 아니라  
> **관리자가 자기 브라우저에서 실행한 것처럼 보이게 됨**

---

## 9. 세션 쿠키는 어디에 있는가?

세션 쿠키는:
- 서버 ❌
- DB ❌
- **피해자 브라우저 내부 쿠키 저장소**에 존재

예:

```
JSESSIONID=ABC123
```

---

## 10. document.cookie가 하는 일

```js
document.cookie
```

의미:
- 현재 도메인 쿠키 중
- **HttpOnly가 아닌 쿠키만**
- 문자열로 반환

예:

```
"JSESSIONID=ABC123"
```

👉 이 순간 세션 ID가 **문자열로 복사됨**

---

## 11. 왜 HttpOnly가 없으면 위험한가?

- HttpOnly ❌ → JS 접근 가능
- HttpOnly ✅ → JS 접근 불가

HttpOnly는:
- 쿠키 전송 ❌ 막지 않음
- **쿠키 “읽기”만 차단**

세션 탈취형 XSS는 “읽기”가 핵심이므로,
HttpOnly가 없으면 공격 가능.

---

## 12. 외부 전송이 왜 가능한가?

- JS는 네트워크 요청을 보낼 수 있음
- 요청 주체 = 피해자 브라우저
- 목적지 = 공격자 서버

결과:
- 쿠키 값이 네트워크로 유출
- 공격자는 세션 ID를 알게 됨

---

## 13. 공격자는 무엇을 얻는가?

```
JSESSIONID=ABC123
```

이 값을 자기 브라우저에 설정하면:

```http
Cookie: JSESSIONID=ABC123
```

서버 판단:
- 세션 유효
- 기존 사용자와 동일

👉 **완전한 신분 도용(세션 하이재킹)**

---

## 14. 왜 자동 전송만으로는 탈취가 안 되나?

자동 전송:
- 피해자 브라우저 → 서버

세션 탈취:
- 피해자 브라우저 → 공격자 → 공격자 브라우저

즉:
- 자동 전송 = 대리 행동
- 쿠키 탈취 = 신분 복제

---

## 15. 방어 요약 (React + Spring 기준)

### React
- `dangerouslySetInnerHTML` 최소화
- 사용자 콘텐츠는 `{text}` 렌더링
- 줄바꿈은 CSS로 처리

```jsx
<div style={{ whiteSpace: "pre-wrap" }}>{content}</div>
```

### Spring
- 세션 쿠키에 HttpOnly 반드시 설정
- 관리자 페이지에 사용자 입력 출력 시 특별 주의
- 가능하면 CSP 적용

---

## 16. 최종 정리

세션 탈취형 XSS는  
**Spring이 문자열을 받아 저장한 뒤,  
React가 그 문자열을 HTML 문맥으로 렌더링하면서  
피해자 브라우저에서 스크립트가 실행되고,  
HttpOnly가 없는 세션 쿠키가 읽혀 외부로 유출되는 공격**이다.
