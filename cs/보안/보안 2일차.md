
# XSS · Session(HttpOnly) · React/Spring 실전 코드 & 상세 예시 (

> 목적: “JSON으로 받은 사용자 입력이 어떻게 DOM/HTML 문맥으로 들어가 XSS가 되는지”와  
> “HttpOnly가 있어도 왜 ‘행위 실행형’이 가능한지”를 **Spring Boot + Spring Security + React 기준**으로 코드와 함께 정리한다.  


---

## 0. 용어 한 번에 정리

- **세션 쿠키(Session Cookie)**: 서버 세션을 식별하는 키(예: `JSESSIONID`)를 브라우저 쿠키로 들고 다님.
- **HttpOnly**: JS에서 `document.cookie`로 쿠키 값을 “읽는 것”을 막음(전송 자체는 막지 못함).
- **XSS**: 신뢰되지 않은 문자열이 브라우저에서 **코드로 해석되는 문맥**(HTML/JS/CSS)에 들어가 실행되는 문제.
- **Escape(인코딩)**: 브라우저가 특수 문자를 태그/코드로 해석하지 못하도록 변환하는 처리(문맥별로 다름).
- **innerHTML**: 문자열을 HTML로 파싱해 DOM을 만드는 API(문자열을 코드로 승격).

---

## 1. 핵심 결론

### 1) JSON 자체는 실행되지 않는다
```json
{ "content": "<script>alert(1)</script>" }
```
이건 “그냥 문자열”이다. DOM에 `innerHTML`류로 넣기 전까지 실행되지 않는다.

### 2) XSS는 “렌더링 선택”에서 발생한다
- 안전: `textContent` / React의 `{value}` 렌더링(기본 자동 escape)
- 위험: `innerHTML` / React `dangerouslySetInnerHTML` / 특정 라이브러리의 raw HTML 렌더링

### 3) HttpOnly는 “탈취형”은 완화하지만 “행위 실행형”은 못 막는다
- HttpOnly: 쿠키 값 “읽기” 방지  
- 하지만 브라우저는 같은 사이트 요청에 쿠키를 “자동 포함” → 피해자 권한으로 요청이 수행될 수 있음

---

## 2. Stored XSS 전체 흐름(저장형) - 한 장 요약

1) 공격자가 댓글/게시글에 “HTML로 해석되면 위험한 문자열” 저장  
2) Spring이 DB에 문자열로 저장(실행 없음)  
3) React가 API(JSON)로 받아 state에 저장(실행 없음)  
4) React가 출력할 때 `innerHTML` 계열을 사용 → **HTML 파싱** → 실행

---

## 3. Spring Boot: “저장 → 조회 → JSON 응답” 예시

### 3.1 엔티티/리포지토리 (예시)
```java
@Entity
public class Post {
    @Id @GeneratedValue
    private Long id;

    private String title;

    @Lob
    private String content; // 사용자 입력(게시글 본문)
}
```

```java
public interface PostRepository extends JpaRepository<Post, Long> {}
```

### 3.2 컨트롤러: 저장 API
```java
@RestController
@RequiredArgsConstructor
@RequestMapping("/api/posts")
public class PostController {
    private final PostRepository repo;

    @PostMapping
    public Post create(@RequestBody Post req) {
        // (취약한 설계 예시) content에 대해 별도 처리 없이 그대로 저장
        return repo.save(req);
    }

    @GetMapping("/{id}")
    public Post get(@PathVariable Long id) {
        return repo.findById(id).orElseThrow();
    }
}
```

- 이 단계에서 `content`가 `<img ...>` 같은 문자열이어도 **서버/DB는 실행하지 않는다.**
- 문제는 **프론트가 이를 HTML로 렌더링할 때** 발생한다.

---

## 4. React: JSON을 “어떻게 쓰느냐”에 따라 안전/위험이 갈린다

### 4.1 API 호출(공통)
```jsx
import { useEffect, useState } from "react";

export default function PostPage({ id }) {
  const [post, setPost] = useState(null);

  useEffect(() => {
    (async () => {
      const res = await fetch(`/api/posts/${id}`);
      const data = await res.json();
      setPost(data); // data.content는 그냥 문자열
    })();
  }, [id]);

  if (!post) return <div>Loading...</div>;

  return (
    <div>
      <h1>{post.title}</h1>
      {/* 아래 출력 방식이 핵심 */}
    </div>
  );
}
```

---

## 5. 안전한 렌더링: React 기본 출력은 자동 escape

### 5.1 안전 코드
```jsx
<div>{post.content}</div>
```

### 5.2 왜 안전한가(개념)
React는 `{post.content}`를 DOM에 넣을 때, 내부적으로 “텍스트로 삽입”하는 방식에 가깝다.
즉 `<script>` 같은 문자가 와도 **태그가 아니라 글자**로 보여준다.

- 결과: `"<script>alert(1)</script>"`가 화면에 **문자 그대로** 나타남
- 실행: 되지 않음

---

## 6. 위험한 렌더링: dangerouslySetInnerHTML(= innerHTML)

### 6.1 위험 코드
```jsx
<div dangerouslySetInnerHTML={{ __html: post.content }} />
```

### 6.2 왜 위험한가
위 코드는 의미상 다음과 같다:
```js
element.innerHTML = post.content;
```
즉 문자열을 “HTML로 해석해 DOM으로 만들라”고 브라우저에 지시한다.

### 6.3 무해한 예시로 관찰(교육용)
예를 들어 content가 다음 문자열이면:
```html
<b>굵게</b>
```
- `{content}`로 출력 → `<b>굵게</b>`가 문자로 보임
- `dangerouslySetInnerHTML` → 굵게 표시됨(태그로 해석)

**태그로 해석되는 순간, 이벤트/스크립트 계열도 같이 해석될 수 있어 XSS가 성립한다.**

---

## 7. innerHTML vs textContent 차이(순수 JS 예시)

### 7.1 안전(textContent)
```js
const el = document.getElementById("box");
el.textContent = '<b>Hello</b>'; // 태그 해석 안 함
```

### 7.2 위험(innerHTML)
```js
const el = document.getElementById("box");
el.innerHTML = '<b>Hello</b>'; // 태그로 파싱해서 DOM 생성
```

- `textContent` = 데이터(문자)로 취급
- `innerHTML` = 코드(태그)로 취급

---

## 8. “HttpOnly가 있어도” 행위 실행형이 가능한 이유 (Spring Security 관점)

### 8.1 쿠키의 두 가지 능력: “읽기” vs “전송”
- HttpOnly는 **읽기(document.cookie)**만 막는다.
- 요청에 쿠키를 붙여 보내는 건 **브라우저 네트워크 스택의 기본 동작**이다.

즉:
- JS는 쿠키 값을 몰라도 된다.
- JS가 같은 사이트로 요청만 보내면, 브라우저가 쿠키를 자동 포함한다.

### 8.2 Spring Security의 인증 흐름(개념)
세션 기반이면 대략 이런 일이 일어난다:

1) 요청 도착
2) Spring Security 필터 체인이 `JSESSIONID`를 보고 세션 조회
3) 세션에 인증 정보(SecurityContext)가 있으면 “인증됨”
4) URL 권한 규칙이 맞으면 컨트롤러 실행

서버가 보는 건 “유효한 세션인지”이므로,  
요청이 사용자 클릭인지, 페이지에 삽입된 스크립트에 의한 것인지 구분이 어렵다.

---

## 9. 방어 1순위: HTML 렌더링을 원칙적으로 금지/최소화

### 9.1 권장 원칙
- 사용자 생성 콘텐츠(댓글/게시글/프로필)는 기본적으로 `{text}`로만 렌더링
- 정말 서식이 필요하면 “허용된 마크업만” 통과

### 9.2 줄바꿈만 필요하면 innerHTML 쓰지 말 것
- 위험한 방식: `text.replace(/\n/g, "<br>")` 후 innerHTML 삽입
- 안전한 방식: CSS 사용
```css
.content { white-space: pre-wrap; }
```
```jsx
<div className="content">{post.content}</div>
```

---

## 10. 방어 2순위: HTML이 필요하면 “sanitize(정화)” + “허용 목록”

> sanitize는 escape의 대체가 아니다.  
> 하지만 “불가피하게 HTML 렌더링”해야 한다면 sanitize가 필요하다.

### 10.1 React 예시(개념)
- post.content를 HTML로 보여줘야 하는 요구가 있을 때:
  - 서버 또는 프론트에서 sanitize(허용 태그만 남기기)
  - 그 결과만 `dangerouslySetInnerHTML`에 넣기

주의:
- 라이브러리/설정에 따라 허용 태그/속성 정책이 달라짐
- 운영에서는 **CSP와 함께** 사용하는 것이 일반적

---

## 11. 방어 3순위: Spring Security에서 CSRF를 제대로 쓰기 (세션 기반이면 중요)

### 11.1 왜 필요한가
세션+쿠키 인증에서는 상태 변경(POST/PUT/DELETE)이 “쿠키 자동 포함” 덕에 위험해진다.  
CSRF 토큰은 “정상 UI에서 만든 요청”인지 확인하는 추가 장치다.

### 11.2 Spring Security (SPA에 맞는 CSRF 토큰 저장소 예시)
```java
@Bean
SecurityFilterChain security(HttpSecurity http) throws Exception {
    http
      .csrf(csrf -> csrf
        .csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
      )
      .authorizeHttpRequests(auth -> auth
        .requestMatchers("/api/admin/**").hasRole("ADMIN")
        .anyRequest().permitAll()
      );
    return http.build();
}
```

- `withHttpOnlyFalse()`는 “프론트가 CSRF 토큰을 읽어 헤더에 담을 수 있게” 하기 위함
- 세션 쿠키(HttpOnly)와는 별개 토큰이다

### 11.3 React에서 CSRF 토큰을 헤더로 전송(예시)
- 서버가 `XSRF-TOKEN` 같은 쿠키로 토큰을 내려주고
- React가 요청 시 `X-XSRF-TOKEN` 헤더로 올려 보냄

(프로젝트 설정마다 토큰 이름은 달라질 수 있음)

---

## 12. 방어 4순위: CSP(Content-Security-Policy)로 “실행” 자체를 제약

CSP는 XSS가 삽입되더라도 “스크립트 실행”을 어렵게 만든다.

### 12.1 Spring에서 헤더로 CSP 추가(개념)
```java
http.headers(headers -> headers
  .contentSecurityPolicy(csp -> csp
    .policyDirectives("default-src 'self'; script-src 'self'; object-src 'none'; base-uri 'self'")
  )
);
```

- 운영에서는 nonce 기반 등 더 정교한 정책을 사용하기도 한다.
- CSP는 만능이 아니며, **escape/렌더링 안전성**이 1순위다.

---

## 13. Escape(인코딩)란 무엇인가

Escape는 “의미 있는 문자”를 브라우저가 태그/코드로 해석하지 못하게 바꾸는 것이다.

### 13.1 HTML Escape
| 원본 | 변환 |
|---|---|
| `<` | `&lt;` |
| `>` | `&gt;` |
| `"` | `&quot;` |
| `'` | `&#39;` |
| `&` | `&amp;` |

### 13.2 중요: 문맥별 escape
- HTML 본문: HTML escape
- HTML 속성: attribute escape
- JS 문자열: JS escape
- URL: `encodeURIComponent`

문맥이 달라지면 escape도 달라진다.

---

## 14. `\"` `\'` 는 escape인가? (정확히)
- 맞다: **문자열 문법을 위한 escape**다(JS/JSON 등에서 따옴표를 문자로 표현).
- 하지만 XSS 방어 효과는 없다. 브라우저에 도달하기 전에 역슬래시가 해석되어 사라진다.

예:
```json
{ "content": "<img onerror=\"alert(1)\">" }
```
JSON 파싱 후 실제 문자열:
```text
<img onerror="alert(1)">
```
즉 `\"`는 보안이 아니라 “문자열 표기” 문제 해결용이다.

---

## 15. 실무 체크리스트(React + Spring)

### React
- 사용자 입력 출력은 기본 `{text}` 사용
- `dangerouslySetInnerHTML` 최소화
- HTML 필요 시: sanitize + 허용 목록 + 테스트
- 줄바꿈은 `white-space: pre-wrap`로 해결

### Spring / Spring Security
- 세션 쿠키: `HttpOnly`, `Secure`, `SameSite` 적절히 설정
- 세션 기반이라면 CSRF를 SPA 방식으로 제대로 적용
- 관리자 화면에서 사용자 콘텐츠 렌더링 특히 주의
- CSP 적용으로 XSS 실행 난이도 상승

---

## 16. 최종 요약(한 문단)
JSON으로 받은 문자열은 그 자체로 실행되지 않는다.  
XSS는 프론트가 그 문자열을 `innerHTML` 계열로 DOM에 삽입해 “HTML 파싱”이 일어나게 할 때 발생한다.  
세션 쿠키가 HttpOnly여도 브라우저는 요청에 쿠키를 자동 포함하므로, XSS는 쿠키를 훔치지 않고도 피해자 권한으로 요청을 실행할 수 있다.  
따라서 1순위는 안전한 렌더링(escape)이고, 필요 시 sanitize/CSP/CSRF 등 계층 방어를 적용한다.
