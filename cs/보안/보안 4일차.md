# 세션 · 쿠키 · 인증 · CSRF · SSO (Opaque / JWT) 정리

작성 기준  
- Spring / Spring Security 관점  
- 웹 인증 구조를 “상태(Session)”와 “신원(Authentication)”으로 분리해서 이해  
- 쿠키 / 세션 / 토큰 / SSO 개념 혼동 제거 목적

---

## 1. 세션(Session)과 인증(Authentication)의 관계

### 1.1 세션이란?
- 서버가 클라이언트를 구분하기 위해 만드는 **저장 공간**
- 본질은 서버 메모리/Redis 등에 존재하는 **Map**
- 세션 ID(JSESSIONID)는 이 저장 공간을 가리키는 **식별자**

```java
HttpSession session = request.getSession();
```

이 코드가 의미하는 것:
- 서버에 빈 저장 공간 생성
- 고유 ID 부여
- 그 ID를 쿠키(JSESSIONID)로 브라우저에 전달

#### 핵심
- 세션은 비어 있을 수 있음
- 세션 생성 자체는 인증과 무관

---

### 1.2 인증(Authentication)이란?
- “이 사용자가 누구인지 검증되었다”는 상태
- 로그인 성공 시에만 발생
- Spring Security 기준으로는 `Authentication` 객체의 존재 여부가 기준

```text
인증됨 ⇔ Authentication 객체 존재
```

---

### 1.3 가장 중요한 구분
```text
세션 있음 ≠ 로그인됨
```

| 개념 | 의미 |
|---|---|
| 세션 | 상태 저장 공간 |
| 인증 | 사용자 신원 확인 결과 |

---

## 2. 쿠키는 있는데 로그인 안 된 세션 (익명 세션)

### 2.1 상태 설명
```http
Cookie: JSESSIONID=ABC123
```

- 서버에 세션 존재
- 하지만 세션 안에 인증 정보 없음
- 서버 판단: “이 사용자가 누구인지는 모름”

이 상태를 **익명 세션(Anonymous Session)** 이라고 부른다.

---

### 2.2 왜 이런 세션이 생기나?

#### (1) CSRF 토큰 저장
```java
session.setAttribute("_csrf", token);
```

#### (2) 로그인 실패 메시지
```java
session.setAttribute("loginError", "비밀번호 오류");
```

#### (3) 이전 페이지 정보 저장
```java
session.setAttribute("redirectUrl", "/admin");
```

→ 인증과 무관하지만 세션은 필요함

---

### 2.3 Spring Security 내부 상태

익명 세션의 실제 모습:

```text
HttpSession
 └─ (CSRF 토큰 등만 존재)
SPRING_SECURITY_CONTEXT ❌
```

요청 처리 중에는 임시로 다음 객체가 생성된다:

```java
AnonymousAuthenticationToken
```

- 요청 단위 객체
- 세션에 저장되지 않음
- 요청 종료 시 폐기

---

## 3. “세션이 생성되면 인증된 것 아닌가?”에 대한 정답

### 결론
```text
세션 생성 ≠ 인증
```

### 이유
- 세션은 단순 저장 공간
- 인증은 로그인 성공 시에만 명시적으로 생성됨

### 비유
- 세션: 사물함
- 인증: 사물함 안에 넣은 신분증

사물함이 있다고 사람이 누구인지 알 수는 없음

---

## 4. 로그인 시 실제 흐름 (Spring Security 기준)

### 4.1 로그인 요청 도착
```http
POST /login
Cookie: (있을 수도 / 없을 수도 있음)
```

---

### 4.2 인증 수행 (세션과 무관)
```java
authenticationManager.authenticate(
    new UsernamePasswordAuthenticationToken(id, pw)
);
```

---

### 4.3 로그인 성공 시 인증 정보 생성
```java
Authentication auth = ...
SecurityContext context = SecurityContextHolder.createEmptyContext();
context.setAuthentication(auth);
```

---

### 4.4 세션에 인증 정보 저장 (세션 방식일 경우)
```java
session.setAttribute("SPRING_SECURITY_CONTEXT", context);
```

---

### 4.5 보안상 세션 ID 변경
```java
request.changeSessionId();
```

- 세션 고정 공격 방지
- 로그인 성공의 본질은 아님

---

## 5. CSRF (Cross-Site Request Forgery)

### 5.1 CSRF란?
- 로그인된 사용자의 쿠키를 악용해
- 사용자가 의도하지 않은 요청을 보내게 하는 공격

핵심 원인:
```text
브라우저는 요청 시 쿠키를 자동 전송한다
```

---

### 5.2 CSRF 토큰의 역할
- “이 요청이 우리 사이트에서 만들어진 요청임”을 증명
- 서버가 생성한 랜덤 값
- 세션에 저장됨

```java
session.setAttribute("_csrf", token);
```

---

### 5.3 요청 검증 방식
- 쿠키: 자동 전송 (위험)
- CSRF 토큰: 명시적으로 포함해야 함 (안전)

```http
X-CSRF-TOKEN: a9f3k2m8x
```

---

## 6. 쿠키 기반 SSO를 토큰 관점으로 이해하기

### 6.1 SSO의 본질
```text
중앙 인증 서버가 발급한 토큰을
여러 서비스가 공통으로 신뢰
```

- 쿠키는 전송 수단
- 토큰이 인증의 본질

---

### 6.2 SSO 흐름 요약
1. 서비스 접근 (비인증)
2. 인증 서버(IdP)로 리다이렉트
3. 로그인 성공
4. SSO 토큰 발급 (쿠키에 저장)
5. 여러 서비스에서 자동 로그인

---

## 7. Opaque Token vs 서명 토큰(JWT 계열)

### 7.1 Opaque Token (참조형 토큰)

**특징**
- 의미 없는 랜덤 문자열
- 사용자 정보는 인증 서버에 저장

**검증 방식**
```text
Service → Auth Server (introspection)
```

**장점**
- 즉시 폐기 가능
- 중앙 통제 쉬움
- 사내 SSO에 적합

**단점**
- 인증 서버 의존
- 네트워크 비용 발생

---

### 7.2 서명 토큰 (JWT 등)

**특징**
- 토큰 자체에 사용자 정보 포함
- 서명으로 위변조 방지

**검증 방식**
```text
Service 내부에서 서명 검증
```

**장점**
- 인증 서버 호출 없음
- 확장성 우수

**단점**
- 즉시 폐기 어려움
- 키 관리 필요

---

### 7.3 핵심 차이 요약

| 항목 | Opaque | 서명 토큰 |
|---|---|---|
| 상태 저장 | 서버 | 토큰 자체 |
| 인증 서버 호출 | 필요 | 불필요 |
| 즉시 로그아웃 | 가능 | 어려움 |
| 확장성 | 보통 | 매우 높음 |

---

## 8. Opaque Token은 세션인가?

### 정확한 정의
```text
Opaque 토큰은 세션이 아니다
하지만 동작 방식은 세션과 동일하다
```

- 세션: 서비스 내부 상태
- Opaque: 인증 서버에 중앙 집중된 세션 ID

따라서:
```text
Opaque = 중앙 인증 서버가 관리하는 전역 세션 ID
```

---

## 9. 전체 구조 한 줄 정리
```text
세션은 저장 공간이다
인증은 저장된 정보다
쿠키는 운반 수단이다
토큰은 신원의 증명서다
```

---

## 10. 최종 핵심 문장

세션이 생겼다고 인증된 것이 아니다  
인증은 오직 로그인 성공 시에만 발생한다  
Opaque 토큰은 세션처럼 동작하는 중앙 인증 식별자다  
JWT는 세션 없이 인증을 증명하는 자급형 토큰이다
